# ──────────────────────────────────────────────────────────────────────────────
# 임포트 섹션: 필요한 라이브러리 및 모듈을 가져옵니다.
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: 운영체제와 상호작용하는 기능을 사용하기 위해 'os' 모듈을 임포트합니다.
# 📊 상    태: 파일 경로 설정, 환경 변수 조회 등의 기능을 사용할 수 있게 됩니다.
import os

# 💬 시나리오: JSON 형식의 데이터를 다루기 위한 'json' 모듈을 임포트합니다.
# 📊 상    태: 이 코드에서는 직접 사용되진 않지만, 데이터 직렬화/역직렬화가 필요할 때 사용할 수 있습니다.
import json

# 💬 시나리오: 코드의 가독성과 안정성을 높이기 위해 타입 힌트 관련 도구들을 'typing' 모듈에서 가져옵니다.
# 📊 상    태: TypedDict, Optional 등의 타입 힌트를 사용하여 데이터 구조를 명확하게 정의할 수 있게 됩니다.
from typing import TypedDict, Optional, Any, Dict, List

# 💬 시나리오: 파일 시스템 경로를 객체 지향적인 방식으로 다루기 위해 'pathlib' 모듈의 'Path' 클래스를 임포트합니다.
# 📊 상    태: 문자열 경로 대신 Path 객체를 사용하여 파일을 다룰 수 있게 되어 코드가 더 명확해집니다.
from pathlib import Path

# 💬 시나리오: .env 파일에서 환경 변수를 로드하기 위해 'dotenv' 라이브러리의 함수들을 임포트합니다.
# 📊 상    태: load_dotenv() 함수를 호출하여 .env 파일에 정의된 변수들을 프로그램의 환경 변수로 설정할 수 있습니다.
from dotenv import load_dotenv, find_dotenv

# 💬 시나리오: 데이터의 고유한 식별값(해시)을 생성하기 위해 'hashlib' 모듈을 임포트합니다.
# 📊 상    태: 이 코드에서는 직접 사용되지 않지만, 데이터의 무결성 검사 등에 활용할 수 있습니다.
import hashlib

# 💬 시나리오: 콘솔에 진행률을 실시간으로 출력하는 등 시스템 관련 기능을 사용하기 위해 'sys' 모듈을 임포트합니다.
# 📊 상    태: sys.stdout을 사용하여 콘솔의 같은 줄에 텍스트를 덮어쓸 수 있게 됩니다.
import sys

# 💬 시나리오: 작업 소요 시간(ETA) 계산 등 시간 관련 기능을 사용하기 위해 'time' 모듈을 임포트합니다.
# 📊 상    태: time.time()으로 현재 시간을 측정하여 경과 시간을 계산할 수 있게 됩니다.
import time

# 💬 시나리오: 수학적 계산(나머지 연산, 무한대 확인 등)을 위해 'math' 모듈을 임포트합니다.
# 📊 상    태: math.isinf, math.isnan 등의 함수를 사용하여 숫자 상태를 확인할 수 있습니다.
import math

# 💬 시나리오: LangChain 라이브러리에서 문서 로딩을 위한 클래스들을 임포트합니다.
# 📊 상    태: TextLoader는 .txt 파일을, PyPDFLoader는 .pdf 파일을 읽어 LangChain의 Document 객체로 변환할 수 있습니다.
from langchain_community.document_loaders import TextLoader, PyPDFLoader

# 💬 시나리오: 긴 텍스트를 정해진 크기의 조각(청크)으로 나누기 위한 클래스를 임포트합니다.
# 📊 상    태: RecursiveCharacterTextSplitter를 사용하여 문서를 의미적으로 유사한 작은 단위로 분할할 수 있습니다.
from langchain_text_splitters import RecursiveCharacterTextSplitter

# 💬 시나리오: Hugging Face 트랜스포머 모델을 사용하여 텍스트를 벡터로 변환(임베딩)하는 클래스를 임포트합니다.
# 📊 상    태: HuggingFaceEmbeddings 객체를 통해 텍스트 데이터를 숫자 벡터로 변환할 수 있게 됩니다.
from langchain_huggingface import HuggingFaceEmbeddings

# 💬 시나리오: 임베딩된 벡터 데이터를 저장하고 검색하기 위한 Milvus 벡터스토어 클래스를 임포트합니다.
# 📊 상    태: Milvus 클래스를 사용하여 벡터 데이터를 Milvus DB에 저장하고 유사도 검색을 수행할 수 있습니다.
from langchain_community.vectorstores import Milvus

# 💬 시나리오: LangChain 내에서 텍스트와 메타데이터를 함께 다루는 기본 구조인 Document 클래스를 임포트합니다.
# 📊 상    태: 로드된 모든 텍스트는 Document 객체 형태로 처리됩니다.
from langchain_core.documents import Document


# ──────────────────────────────────────────────────────────────────────────────
# 환경 변수 로드 및 설정
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: 프로젝트 내의 .env 파일을 찾아 그 안의 설정들을 환경 변수로 로드합니다.
# 📊 상    태: os.getenv() 함수가 .env 파일에 정의된 값들을 읽을 수 있게 됩니다.
load_dotenv(find_dotenv())

# --- Milvus / Embedding 설정 ---
# 💬 시나리오: Milvus 서버의 주소를 환경 변수에서 가져옵니다. .env 파일에 없으면 기본값으로 'http://localhost:19530'을 사용합니다.
# 📊 상    태: MILVUS_URI 변수에 Milvus 접속 주소가 문자열로 저장됩니다.
MILVUS_URI = os.getenv("MILVUS_URI", "http://localhost:19530")

# 💬 시나리오: Milvus 서버의 인증 토큰을 환경 변수에서 가져옵니다. 없으면 기본값 'root:milvus'를 사용합니다.
# 📊 상    태: MILVUS_TOKEN 변수에 인증 정보가 저장됩니다.
MILVUS_TOKEN = os.getenv("MILVUS_TOKEN", "root:milvus")

# 💬 시나리오: Milvus에 생성할 컬렉션(데이터 테이블)의 이름을 환경 변수에서 가져옵니다. 없으면 'hongyoungjun'을 사용합니다.
# 📊 상    태: MILVUS_COLLECTION 변수에 사용할 컬렉션 이름이 저장됩니다.
MILVUS_COLLECTION = os.getenv("MILVUS_COLLECTION", "hongyoungjun")

# 💬 시나리오: 텍스트 임베딩에 사용할 Hugging Face 모델의 이름을 환경 변수에서 가져옵니다. 없으면 'jhgan/ko-sroberta-multitask'를 사용합니다.
# 📊 상    태: EMBED_MODEL_NAME 변수에 임베딩 모델 이름이 저장됩니다.
EMBED_MODEL_NAME = os.getenv("EMBED_MODEL_NAME", "jhgan/ko-sroberta-multitask")

# --- 입력 문서 폴더 ---
# 💬 시나리오: 인제스트할 문서들이 위치한 폴더 경로를 환경 변수에서 가져옵니다. 없으면 기본 경로를 사용합니다.
# 📊 상    태: DOCS_DIR 변수에 문서 폴더를 가리키는 Path 객체가 저장됩니다.
DOCS_DIR = Path(os.getenv("DOCS_DIR", r"C:\Rookies_project\cropinfo"))

# 💬 시나리오: DOCS_DIR 경로에 해당하는 폴더가 존재하지 않으면, 상위 폴더를 포함하여 새로 생성합니다.
# 📊 상    태: 프로그램 실행에 필요한 문서 폴더가 항상 존재하도록 보장합니다.
DOCS_DIR.mkdir(parents=True, exist_ok=True)

# --- 청크/임베딩 파라미터 ---
# 💬 시나리오: 텍스트를 나눌 청크의 최대 크기를 환경 변수에서 가져옵니다. 없으면 800으로 설정합니다.
# 📊 상    태: CHUNK_SIZE 변수에 정수 800이 저장됩니다.
CHUNK_SIZE = int(os.getenv("CHUNK_SIZE", "800"))

# 💬 시나리오: 청크와 청크 사이에 겹치게 할 글자 수를 환경 변수에서 가져옵니다. 없으면 120으로 설정합니다.
# 📊 상    태: CHUNK_OVERLAP 변수에 정수 120이 저장됩니다. 문맥 유지를 돕습니다.
CHUNK_OVERLAP = int(os.getenv("CHUNK_OVERLAP", "120"))

# ✨ 임베딩 진행률 설정 ---
# 💬 시나리오: 한 번에 몇 개의 청크를 임베딩할지 배치 크기를 환경 변수에서 가져옵니다. 없으면 32로 설정합니다.
# 📊 상    태: EMBED_BATCH_SIZE 변수에 정수 32가 저장됩니다.
EMBED_BATCH_SIZE = int(os.getenv("EMBED_BATCH_SIZE", "32"))

# 💬 시나리오: 콘솔에 진행률을 얼마나 자주 업데이트할지 최소 시간 간격(초)을 환경 변수에서 가져옵니다. 없으면 0.2초로 설정합니다.
# 📊 상    태: EMBED_PROGRESS_INTERVAL 변수에 실수 0.2가 저장됩니다.
EMBED_PROGRESS_INTERVAL = float(os.getenv("EMBED_PROGRESS_INTERVAL", "0.2"))


# ──────────────────────────────────────────────────────────────────────────────
# Embeddings 모델 초기화
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: 지정된 모델 이름과 설정으로 HuggingFaceEmbeddings 객체를 생성합니다.
# 📊 상    태: embedding_model 변수에 텍스트를 벡터로 변환할 수 있는 객체가 할당됩니다. CPU를 사용하도록 설정됩니다.
embedding_model = HuggingFaceEmbeddings(
    model_name=EMBED_MODEL_NAME,
    model_kwargs={"device": "cpu"}
)

# 💬 시나리오: 테스트 쿼리를 임베딩하여 결과 벡터의 차원(길이)을 알아냅니다.
# 📊 상    태: EMBEDDING_DIM 변수에 모델이 생성하는 벡터의 차원 수(예: 768)가 저장됩니다.
EMBEDDING_DIM = len(embedding_model.embed_query("test"))


# ──────────────────────────────────────────────────────────────────────────────
# ✨ 진행률/ETA 표시용 유틸리티 함수
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: 남은 시간을 초 단위로 받아 '분:초' 또는 '시:분:초' 형태의 문자열로 변환하는 함수를 정의합니다.
# 📊 상    태: 이 함수는 ETA(Estimated Time of Arrival, 예상 완료 시간)를 사람이 읽기 쉽게 표현하는 데 사용됩니다.
def _format_eta(seconds: Optional[float]) -> str:
    
    # 💬 시나리오: 유효하지 않은 시간 값(None, 음수, 무한대 등)이 들어오면 '--:--'를 반환합니다.
    if not seconds or seconds < 0 or math.isinf(seconds) or math.isnan(seconds):
        
        return "--:--"
    
    # 💬 시나리오: 전체 초를 60으로 나누어 분(m)과 초(s)를 구합니다.
    m, s = divmod(int(seconds), 60)
    
    # 💬 시나리오: 분이 60 이상이면, 다시 60으로 나누어 시(h)와 분(m)을 구합니다.
    if m >= 60:
        
        h, m = divmod(m, 60)
        
        # 💬 시나리오: 시, 분, 초를 두 자리 숫자로 포맷팅하여 반환합니다.
        return f"{h:02d}:{m:02d}:{s:02d}"
    
    # 💬 시나리오: 분, 초를 두 자리 숫자로 포맷팅하여 반환합니다.
    return f"{m:02d}:{s:02d}"

# 💬 시나리오: 현재 진행 상황을 받아 콘솔에 프로그레스 바 형태로 출력하는 함수를 정의합니다.
# 📊 상    태: 이 함수는 실시간으로 작업 진행률과 ETA를 시각적으로 보여줍니다.
def _render_progress(prefix: str, done: int, total: int, start_ts: float) -> None:
    
    # 💬 시나리오: 완료된 개수가 전체 개수를 넘지 않도록 조정합니다.
    done = min(done, total)
    
    # 💬 시나리오: 완료된 비율을 퍼센트로 계산합니다. 전체가 0일 경우 100%로 처리합니다.
    percent = int((done / total) * 100) if total else 100
    
    # 💬 시나리오: 시작 시간으로부터 현재까지 경과된 시간을 계산합니다.
    elapsed = time.time() - start_ts
    
    # 💬 시나리오: 경과 시간 동안의 처리 속도(개/초)를 계산합니다.
    rate = (done / elapsed) if elapsed > 0 else None
    
    # 💬 시나리오: 남은 개수를 처리 속도로 나누어 예상 완료 시간을 계산합니다.
    remain = ((total - done) / rate) if rate else None
    
    # 💬 시나리오: 남은 시간을 사람이 읽기 쉬운 포맷으로 변환합니다.
    eta = _format_eta(remain)
    
    # 💬 시나리오: 프로그레스 바의 전체 길이를 24 문자로 설정합니다.
    bar_len = 24
    
    # 💬 시나리오: 퍼센트에 맞춰 채워질 바의 길이를 계산합니다.
    filled = int(bar_len * percent / 100)
    
    # 💬 시나리오: 채워진 부분(█)과 비워진 부분(░)으로 구성된 바 문자열을 생성합니다.
    bar = "█" * filled + "░" * (bar_len - filled)
    
    # 💬 시나리오: 콘솔의 현재 줄 맨 앞으로 커서를 이동(\r)시키고, 접두사, 프로그레스 바, 진행률 정보를 출력합니다.
    sys.stdout.write(f"\r{prefix} [{bar}] {percent:3d}%  ({done}/{total})  ETA {eta}")
    
    # 💬 시나리오: 출력 버퍼를 비워 즉시 콘솔에 표시되도록 합니다.
    sys.stdout.flush()
    
    # 💬 시나리오: 작업이 완료되면 줄바꿈을 하여 다음 출력이 새 줄에서 시작되도록 합니다.
    if done >= total:
        
        sys.stdout.write("\n")


# ──────────────────────────────────────────────────────────────────────────────
# ✨ 임베딩 진행률을 표시하는 래퍼 클래스
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: LangChain의 임베딩 클래스를 감싸서 진행률 표시 기능을 추가하는 클래스를 정의합니다.
# 📊 상    태: 이 클래스의 객체는 기존 HuggingFaceEmbeddings 객체처럼 동작하지만, embed_documents 메소드 호출 시 콘솔에 진행률을 출력합니다.
class ProgressEmbeddings:
    
    # 💬 시나리오: 클래스 초기화 메소드를 정의합니다.
    def __init__(self, base: HuggingFaceEmbeddings, total_texts: int, batch_size: int = 32, desc: str = "임베딩"):
        
        # 💬 시나리오: 원본 임베딩 객체를 저장합니다.
        self.base = base
        
        # 💬 시나리오: 처리할 전체 텍스트 개수를 저장합니다. (최소 1)
        self.total_texts = max(total_texts, 1)
        
        # 💬 시나리오: 배치 크기를 저장합니다. (최소 1)
        self.batch_size = max(1, batch_size)
        
        # 💬 시나리오: 진행률 표시에 사용할 설명 텍스트를 저장합니다.
        self.desc = desc
        
        # 💬 시나리오: 마지막으로 진행률을 출력한 시간을 기록하기 위한 변수를 초기화합니다.
        self._last_print = 0.0

    # 💬 시나리오: LangChain의 기본 인터페이스를 유지하기 위해 단일 쿼리 임베딩 메소드를 정의합니다.
    # 📊 상    태: 이 메소드는 원본 객체의 embed_query를 그대로 호출하여 결과를 반환합니다.
    def embed_query(self, text: str) -> List[float]:
        
        return self.base.embed_query(text)

    # 💬 시나리오: 여러 문서를 임베딩하는 핵심 메소드를 정의하며, 여기에 진행률 표시 로직이 들어갑니다.
    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        
        # 💬 시나리오: 입력된 텍스트 리스트의 길이를 구합니다.
        n = len(texts)
        
        # 💬 시나리오: 전체 작업량을 설정합니다. Milvus.from_documents는 모든 텍스트를 한 번에 전달합니다.
        total = n
        
        # 💬 시나리오: 작업 시작 시간을 기록합니다.
        start_ts = time.time()
        
        # 💬 시나리오: 임베딩 결과를 저장할 빈 리스트를 초기화합니다.
        results: List[List[float]] = []
        
        # 💬 시나리오: 처리된 텍스트 개수를 기록할 변수를 초기화합니다.
        processed = 0

        # 💬 시나리오: 임베딩 시작을 알리는 메시지를 콘솔에 출력합니다.
        print(f"🧮 {self.desc} 시작: 총 {total}개 청크 | 배치 {self.batch_size} | 진행률 및 ETA 표출")

        # 💬 시나리오: 전체 텍스트를 배치 크기만큼씩 나누어 처리하기 위한 루프를 시작합니다.
        for i in range(0, n, self.batch_size):
            
            # 💬 시나리오: 현재 루프에서 처리할 텍스트 배치(조각)를 슬라이싱하여 가져옵니다.
            batch = texts[i:i + self.batch_size]

            # 💬 시나리오: 원본 임베딩 객체를 사용하여 실제 임베딩 계산을 수행합니다.
            emb = self.base.embed_documents(batch)
            
            # 💬 시나리오: 계산된 임베딩 결과를 전체 결과 리스트에 추가합니다.
            results.extend(emb)
            
            # 💬 시나리오: 현재까지 처리된 총 개수를 업데이트합니다.
            processed = min(i + len(batch), total)

            # 💬 시나리오: 너무 잦은 콘솔 업데이트를 방지하기 위한 조건을 확인합니다.
            now = time.time()
            
            # 💬 시나리오: 마지막 출력 이후 일정 시간(EMBED_PROGRESS_INTERVAL)이 지났거나 작업이 완료되었으면 진행률을 출력합니다.
            if now - self._last_print >= EMBED_PROGRESS_INTERVAL or processed == total:
                
                # 💬 시나리오: _render_progress 함수를 호출하여 콘솔에 프로그레스 바를 표시합니다.
                _render_progress("🔄 임베딩", processed, total, start_ts)
                
                # 💬 시나리오: 마지막 출력 시간을 현재 시간으로 업데이트합니다.
                self._last_print = now

        # 💬 시나리오: 루프가 끝난 후, 100% 완료된 상태의 프로그레스 바를 한 번 더 출력하여 완료를 보장합니다.
        _render_progress("✅ 임베딩", total, total, start_ts)
        
        # 💬 시나리오: 모든 텍스트의 임베딩 결과가 담긴 리스트를 반환합니다.
        return results


# ──────────────────────────────────────────────────────────────────────────────
# 상태 정의: LangGraph의 각 노드 간에 전달될 데이터 구조
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: LangGraph의 상태(state)를 정의하기 위한 TypedDict 클래스를 생성합니다.
# 📊 상    태: 이 구조는 그래프의 작업 흐름 동안 모든 데이터를 담는 컨테이너 역할을 합니다.
class IngestState(TypedDict):
    
    # 💬 시나리오: 문서가 있는 폴더의 경로를 저장할 필드를 정의합니다.
    docsPath: str
    
    # 💬 시나리오: 처리할 파일들의 경로 리스트를 저장할 필드를 정의합니다.
    files: List[str]
    
    # 💬 시나리오: 파일에서 로드한 원본 Document 객체 리스트를 저장할 필드를 정의합니다.
    rawDocs: List[Document]
    
    # 💬 시나리오: Milvus 벡터스토어 객체를 저장할 필드를 정의합니다. (작업 실패 시 None일 수 있음)
    vectorstore: Optional[Milvus]
    
    # 💬 시나리오: Milvus에 최종적으로 삽입된 청크의 개수를 저장할 필드를 정의합니다.
    inserted: int
    
    # 💬 시나리오: 사용할 Milvus 컬렉션의 이름을 저장할 필드를 정의합니다.
    collectionName: str


# ──────────────────────────────────────────────────────────────────────────────
# LangGraph 노드(작업 단위) 정의
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: LangGraph 관련 클래스들을 임포트합니다.
# 📊 상    태: StateGraph로 워크플로우를 정의하고, END로 종료를 표시하며, MermaidDrawMethod로 시각화할 수 있게 됩니다.
from langgraph.graph import StateGraph, END

from langchain_core.runnables.graph import MermaidDrawMethod

# 💬 시나리오: Milvus DB를 직접 제어하기 위한 클라이언트 관련 클래스들을 임포트합니다.
# 📊 상    태: MilvusClient를 사용하여 컬렉션 존재 여부 확인, 삭제 등의 작업을 수행할 수 있습니다.
from pymilvus import connections, MilvusClient, DataType

# 💬 시나리오: 파이프라인 시작 시 Milvus 연결을 확인하고 기존 컬렉션을 정리하는 노드 함수를 정의합니다.
# 📊 상    태: 이 노드는 state를 직접 수정하지는 않지만, Milvus DB의 상태를 다음 작업을 위해 준비시킵니다.
def ensure_milvus_node(state: IngestState) -> IngestState:
    
    # 💬 시나리오: 노드 시작을 알리는 메시지를 출력합니다.
    print("🧩 노드: ensure_milvus (컬렉션 확인)")
    
    # 💬 시나리오: 이전에 설정된 'default' 연결이 있다면, 깨끗한 상태에서 시작하기 위해 연결을 끊습니다.
    if "default" in connections.list_connections():
        
        connections.disconnect("default")
    
    # 💬 시나리오: Milvus 서버에 'default'라는 별칭으로 새로 연결합니다.
    connections.connect(alias="default", host="localhost", port="19530")

    # 💬 시나리오: Milvus DB를 제어하기 위한 클라이언트 객체를 생성합니다.
    client = MilvusClient(uri=MILVUS_URI, token=MILVUS_TOKEN)
    
    # 💬 시나리오: 작업 대상 컬렉션이 이미 존재하는지 확인합니다.
    if client.has_collection(MILVUS_COLLECTION):
        
        # 💬 시나리오: 컬렉션이 존재하면, 데이터를 새로 인제스트하기 위해 기존 컬렉션을 삭제합니다.
        print(f"  ↪ 기존 컬렉션 '{MILVUS_COLLECTION}' 삭제")
        
        client.drop_collection(MILVUS_COLLECTION)
    
    # 💬 시나리오: Milvus 준비가 완료되었음을 알리는 메시지를 출력합니다.
    print(f"  ↪ Milvus 연결 및 컬렉션 준비 완료.")
    
    # 💬 시나리오: 입력받은 state를 수정 없이 그대로 다음 노드로 전달합니다.
    return state

# 💬 시나리오: 지정된 폴더에서 처리할 파일 목록을 찾는 노드 함수를 정의합니다.
# 📊 상    태: 이 노드는 state의 'docsPath'를 읽고, 찾은 파일 목록을 'files' 키에 저장하여 state를 업데이트합니다.
def list_files_node(state: IngestState) -> IngestState:
    
    # 💬 시나리오: 노드 시작을 알리는 메시지를 출력합니다.
    print("🧩 노드: list_files")
    
    # 💬 시나리오: state에서 문서 폴더 경로를 가져와 Path 객체로 만듭니다.
    docs_path = Path(state["docsPath"])
    
    # 💬 시나리오: 허용할 파일 확장자(.txt, .md, .pdf)를 집합으로 정의합니다.
    allow_ext = {".txt", ".md", ".pdf"}
    
    # 💬 시나리오: 지정된 폴더와 그 하위 폴더를 모두 탐색하여, 허용된 확장자를 가진 파일들의 전체 경로 리스트를 생성합니다.
    files = [str(p) for p in sorted(docs_path.rglob("*")) if p.is_file() and p.suffix.lower() in allow_ext]
    
    # 💬 시나리오: 찾은 파일의 개수를 출력합니다.
    print(f"  ↪ 대상 파일 {len(files)}개")
    
    # 💬 시나리오: 만약 파일을 하나도 찾지 못했다면, 사용자에게 안내 메시지를 출력합니다.
    if not files:
        
        print("  ⚠️ 'ingest_docs' 폴더에 .txt/.md/.pdf 파일을 넣어주세요.")
    
    # 💬 시나리오: 기존 state에 'files' 키를 추가(업데이트)하여 다음 노드로 전달합니다.
    return {**state, "files": files}

# 💬 시나리오: 파일들을 로드하여 청크로 나누고, 임베딩하여 Milvus에 삽입하는 메인 노드 함수를 정의합니다.
# 📊 상    태: 이 노드는 'files'를 읽어 작업을 수행하고, 그 결과를 'inserted', 'rawDocs', 'vectorstore' 키에 담아 state를 업데이트합니다.
def load_and_ingest_node(state: IngestState) -> IngestState:
    
    # 💬 시나리오: 노드 시작을 알리는 메시지를 출력합니다.
    print("🧩 노드: load_and_ingest_node (문서 로드 & Milvus에 인제스트)")
    
    # 💬 시나리오: 모든 문서의 청크를 저장할 빈 리스트를 초기화합니다.
    all_docs: List[Document] = []
    
    # 💬 시나리오: 설정된 청크 크기와 겹침 옵션으로 텍스트 분할기 객체를 생성합니다.
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=CHUNK_SIZE,
        chunk_overlap=CHUNK_OVERLAP,
        length_function=len,
    )

    # 💬 시나리오: 파일 목록을 순회하며 각 파일을 로드하고 청크로 나눕니다.
    for fp in state["files"]:
        
        # 💬 시나리오: 파일 경로 문자열을 Path 객체로 변환합니다.
        path = Path(fp)
        
        # 💬 시나리오: 파일 처리 중 발생할 수 있는 오류를 잡기 위해 try-except 블록을 사용합니다.
        try:
            
            # 💬 시나리오: 파일 확장자에 따라 적절한 로더를 선택합니다.
            if path.suffix.lower() in {".txt", ".md"}:
                
                # 💬 시나리오: 텍스트 파일 로더를 사용하여 문서를 로드합니다. 인코딩은 자동으로 감지합니다.
                docs = TextLoader(str(path), autodetect_encoding=True).load()
                
            elif path.suffix.lower() == ".pdf":
                
                # 💬 시나리오: PDF 파일 로더를 사용하여 문서를 로드합니다.
                docs = PyPDFLoader(str(path)).load()
                
            else:
                
                # 💬 시나리오: 허용되지 않은 확장자 파일은 건너뜁니다.
                continue

            # 💬 시나리오: 로드된 문서(페이지)들에 메타데이터를 추가합니다.
            for d in docs:
                
                # 💬 시나리오: 'source' 메타데이터가 없으면 파일 이름을 기본값으로 설정합니다.
                d.metadata.setdefault("source", str(path.name))
                
                # 💬 시나리오: PDF가 아닌 경우 'page' 메타데이터가 없으므로 0으로 설정합니다.
                if "page" not in d.metadata:
                    
                    d.metadata["page"] = 0

            # 💬 시나리오: 로드된 문서를 텍스트 분할기를 사용해 여러 개의 청크로 나눕니다.
            chunks = text_splitter.split_documents(docs)
            
            # 💬 시나리오: 생성된 청크들을 전체 청크 리스트에 추가합니다.
            all_docs.extend(chunks)
            
            # 💬 시나리오: 현재 파일의 처리 완료 및 생성된 청크 개수를 출력합니다.
            print(f"  ↪ 로드 및 청크 완료: {path.name} ({len(chunks)}개 청크)")

        # 💬 시나리오: 파일 처리 중 오류가 발생하면, 오류 메시지를 출력하고 다음 파일로 넘어갑니다.
        except Exception as e:
            
            print(f"  ⚠️ 처리 실패: {path.name} | {e}")

    # 💬 시나리오: 모든 파일 처리 후 청크가 하나도 없으면, 경고 메시지를 출력하고 빈 결과로 state를 업데이트한 후 종료합니다.
    if not all_docs:
        
        print("  ⚠️ 처리할 문서가 없습니다.")
        
        return {**state, "inserted": 0, "rawDocs": [], "vectorstore": None}

    # 💬 시나리오: Milvus에 삽입할 전체 청크 개수를 알리는 메시지를 출력합니다.
    print(f"🆕 총 {len(all_docs)}개 청크를 벡터스토어에 삽입 중...")

    # 💬 시나리오: Milvus 삽입 중 발생할 수 있는 오류를 처리하기 위해 try-except 블록을 사용합니다.
    try:
        
        # 💬 시나리오: 앞서 정의한 ProgressEmbeddings 래퍼 클래스의 객체를 생성합니다.
        # 📊 상    태: 이 객체는 임베딩 작업을 수행하면서 콘솔에 진행률을 자동으로 출력합니다.
        progress_embedder = ProgressEmbeddings(
            base=embedding_model,
            total_texts=len(all_docs),
            batch_size=EMBED_BATCH_SIZE,
            desc="임베딩"
        )

        # 💬 시나리오: Milvus.from_documents를 호출하여 문서 삽입을 시작합니다.
        # 📊 상    태: 이 함수는 내부적으로 progress_embedder의 embed_documents를 호출하므로, 콘솔에 진행률이 표시됩니다.
        vectorstore = Milvus.from_documents(
            documents=all_docs,
            embedding=progress_embedder,  # ✨ 진행률 표시 기능이 활성화된 임베더를 전달합니다.
            collection_name=state["collectionName"],
            connection_args={"host": "localhost", "port": "19530"}
        )
        
        # 💬 시나리오: 작업이 성공적으로 완료되었음을 알리는 메시지를 출력합니다.
        print("✅ 벡터스토어 생성 및 문서 삽입 완료.")
        
        # 💬 시나리오: 삽입된 청크의 개수를 기록합니다.
        inserted_count = len(all_docs)

    # 💬 시나리오: Milvus 삽입 중 오류가 발생하면, 오류 메시지를 출력합니다.
    except Exception as e:
        
        print(f"❌ Milvus 삽입 오류: {e}")
        
        # 💬 시나리오: 삽입된 개수를 0으로 설정하고, 벡터스토어 객체를 None으로 설정합니다.
        inserted_count = 0
        
        vectorstore = None

    # 💬 시나리오: 최종 결과를 담아 업데이트된 state를 반환합니다.
    return {**state, "inserted": inserted_count, "rawDocs": all_docs, "vectorstore": vectorstore}


# ──────────────────────────────────────────────────────────────────────────────
# 그래프(워크플로우) 빌드
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: LangGraph 워크플로우를 구성하고 컴파일하는 함수를 정의합니다.
# 📊 상    태: 이 함수는 실행 가능한 agent_app 객체를 생성하여 반환합니다.
def build_graph():
    
    # 💬 시나리오: IngestState를 상태로 사용하는 StateGraph 객체를 생성합니다.
    g = StateGraph(IngestState)
    
    # 💬 시나리오: 'ensure_milvus'라는 이름으로 ensure_milvus_node 함수를 그래프에 노드로 추가합니다.
    g.add_node("ensure_milvus", ensure_milvus_node)
    
    # 💬 시나리오: 'list_files'라는 이름으로 list_files_node 함수를 노드로 추가합니다.
    g.add_node("list_files", list_files_node)
    
    # 💬 시나리오: 'load_and_ingest'라는 이름으로 load_and_ingest_node 함수를 노드로 추가합니다.
    g.add_node("load_and_ingest", load_and_ingest_node)

    # 💬 시나리오: 'ensure_milvus' 노드를 파이프라인의 시작점으로 설정합니다.
    g.set_entry_point("ensure_milvus")
    
    # 💬 시나리오: 'ensure_milvus' 노드가 끝나면 'list_files' 노드로 이동하도록 엣지(연결선)를 추가합니다.
    g.add_edge("ensure_milvus", "list_files")
    
    # 💬 시나리오: 'list_files' 노드가 끝나면 'load_and_ingest' 노드로 이동하도록 엣지를 추가합니다.
    g.add_edge("list_files", "load_and_ingest")
    
    # 💬 시나리오: 'load_and_ingest' 노드가 끝나면 파이프라인을 종료(END)하도록 엣지를 추가합니다.
    g.add_edge("load_and_ingest", END)

    # 💬 시나리오: 정의된 노드와 엣지를 바탕으로 실행 가능한 그래프를 컴파일하여 반환합니다.
    return g.compile()


# ──────────────────────────────────────────────────────────────────────────────
# 메인 실행 함수
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: 프로그램의 주 실행 로직을 담고 있는 main 함수를 정의합니다.
def main():
    
    # 💬 시나리오: 파이프라인 시작을 알리는 메시지를 출력합니다.
    print("🚀 LangGraph 기반 Milvus Ingest 파이프라인 시작")
    
    # 💬 시나리오: build_graph 함수를 호출하여 실행 가능한 에이전트 앱을 생성합니다.
    agent_app = build_graph()

    # 💬 시나리오: 그래프 시각화 중 발생할 수 있는 오류를 처리하기 위해 try-except 블록을 사용합니다.
    try:
        
        # 💬 시나리오: 그래프 구조를 저장할 파일 경로를 지정합니다.
        graph_image_path = "milvus_agent_workflow_rag.png"
        
        # 💬 시나리오: 그래프 구조를 Mermaid 다이어그램 PNG 이미지 바이트로 렌더링합니다.
        png_bytes = agent_app.get_graph().draw_mermaid_png(draw_method=MermaidDrawMethod.API)
        
        # 💬 시나리오: PNG 파일을 바이너리 쓰기 모드로 열고, 렌더링된 이미지 바이트를 파일에 씁니다.
        with open(graph_image_path, "wb") as f:
            
            f.write(png_bytes)
            
        # 💬 시나리오: 그래프 이미지가 성공적으로 저장되었음을 알리는 메시지를 출력합니다.
        print(f"\n✅ LangGraph 구조가 '{graph_image_path}' 파일로 저장되었습니다.")
        
    # 💬 시나리오: 시각화 중 오류가 발생하면, 오류 메시지를 출력합니다.
    except Exception as e:
        
        print(f"그래프 시각화 중 오류 발생: {e}")

    # 💬 시나리오: 파이프라인을 시작할 때 사용할 초기 상태(initial_state) 딕셔너리를 정의합니다.
    initial_state: IngestState = {
        "docsPath": str(DOCS_DIR),
        "files": [],
        "rawDocs": [],
        "vectorstore": None,
        "inserted": 0,
        "collectionName": MILVUS_COLLECTION,
    }

    # 💬 시나리오: agent_app.invoke를 호출하여 정의된 초기 상태로 LangGraph 파이프라인 전체를 실행합니다.
    # 📊 상    태: 파이프라인이 모두 실행된 후, 모든 노드의 작업 결과가 누적된 최종 상태가 final_state 변수에 저장됩니다.
    final_state = agent_app.invoke(initial_state)

    # 💬 시나리오: 파이프라인 실행 결과를 요약하여 출력합니다.
    print("\n📦 결과 요약")
    
    # 💬 시나리오: 최종 상태에서 처리된 파일 수를 가져와 출력합니다.
    print(f"  - 처리된 파일 수: {len(final_state['files'])}")
    
    # 💬 시나리오: 최종 상태에서 사용된 Milvus 컬렉션 이름을 가져와 출력합니다.
    print(f"  - Milvus 컬렉션: {final_state['collectionName']}")
    
    # 💬 시나리오: 최종 상태에서 삽입된 총 청크 수를 가져와 출력합니다.
    print(f"  - 삽입된 청크 수: {final_state['inserted']}")


# ──────────────────────────────────────────────────────────────────────────────
# 스크립트 실행 지점
# ──────────────────────────────────────────────────────────────────────────────
# 💬 시나리오: 이 파이썬 파일이 직접 실행되었을 때만 아래 코드를 실행하도록 하는 표준적인 파이썬 구문입니다.
if __name__ == "__main__":
    
    # 💬 시나리오: main 함수를 호출하여 전체 인제스트 파이프라인을 시작합니다.
    main()