# 필요한 라이브러리 및 모듈을 임포트합니다.
import os  # 파일 경로, 환경 변수 등 운영체제 기능에 접근하기 위해 사용합니다.
import json  # JSON 데이터를 다루기 위해 사용하지만, 이 코드에서는 직접 사용되지 않습니다.
from typing import TypedDict, Optional, Any, Dict, List  # 타입 힌트
from pathlib import Path  # 파일 시스템 경로를 객체지향적으로 다루기 위해 사용합니다.
from dotenv import load_dotenv, find_dotenv  # .env 로더
import hashlib  # 데이터의 해시값을 생성
import sys      # ✨ 진행률 출력용
import time     # ✨ ETA 계산용
import math     # ✨ 시간 포맷 등에 사용

# LangChain과 관련된 클래스들을 임포트합니다.
from langchain_community.document_loaders import TextLoader, PyPDFLoader  # 파일 로더
from langchain_text_splitters import RecursiveCharacterTextSplitter  # 텍스트 분할기
from langchain_huggingface import HuggingFaceEmbeddings  # 임베딩 모델
from langchain_community.vectorstores import Milvus  # Milvus 벡터스토어
from langchain_core.documents import Document  # 문서 구조

# ──────────────────────────────────────────────────────────────────────────────
# 환경 변수 로드
# ──────────────────────────────────────────────────────────────────────────────
load_dotenv(find_dotenv())

# Milvus / Embedding 설정
MILVUS_URI = os.getenv("MILVUS_URI", "http://localhost:19530")
MILVUS_TOKEN = os.getenv("MILVUS_TOKEN", "root:milvus")
MILVUS_COLLECTION = os.getenv("MILVUS_COLLECTION", "hongyoungjun")
EMBED_MODEL_NAME = os.getenv("EMBED_MODEL_NAME", "jhgan/ko-sroberta-multitask")

# 입력 문서 폴더
DOCS_DIR = Path(os.getenv("DOCS_DIR", r"C:\Rookies_project\cropinfo"))
DOCS_DIR.mkdir(parents=True, exist_ok=True)

# 청크/임베딩 파라미터
CHUNK_SIZE = int(os.getenv("CHUNK_SIZE", "800"))
CHUNK_OVERLAP = int(os.getenv("CHUNK_OVERLAP", "120"))

# ✨ 임베딩 진행률 설정(환경변수로 조정 가능)
EMBED_BATCH_SIZE = int(os.getenv("EMBED_BATCH_SIZE", "32"))              # 배치 크기
EMBED_PROGRESS_INTERVAL = float(os.getenv("EMBED_PROGRESS_INTERVAL", "0.2"))  # 초 단위 진행률 업데이트 최소 간격

# ──────────────────────────────────────────────────────────────────────────────
# Embeddings
# ──────────────────────────────────────────────────────────────────────────────
embedding_model = HuggingFaceEmbeddings(
    model_name=EMBED_MODEL_NAME,
    model_kwargs={"device": "cpu"}
)
EMBEDDING_DIM = len(embedding_model.embed_query("test"))

# ✨ 진행률/ETA 표시용 유틸
def _format_eta(seconds: Optional[float]) -> str:
    if not seconds or seconds < 0 or math.isinf(seconds) or math.isnan(seconds):
        return "--:--"
    m, s = divmod(int(seconds), 60)
    if m >= 60:
        h, m = divmod(m, 60)
        return f"{h:02d}:{m:02d}:{s:02d}"
    return f"{m:02d}:{s:02d}"

def _render_progress(prefix: str, done: int, total: int, start_ts: float) -> None:
    done = min(done, total)
    percent = int((done / total) * 100) if total else 100
    elapsed = time.time() - start_ts
    rate = (done / elapsed) if elapsed > 0 else None
    remain = ((total - done) / rate) if rate else None
    eta = _format_eta(remain)
    bar_len = 24
    filled = int(bar_len * percent / 100)
    bar = "█" * filled + "░" * (bar_len - filled)
    sys.stdout.write(f"\r{prefix} [{bar}] {percent:3d}%  ({done}/{total})  ETA {eta}")
    sys.stdout.flush()
    if done >= total:
        sys.stdout.write("\n")

# ✨ 임베딩 진행률을 표시하는 래퍼
class ProgressEmbeddings:
    """
    LangChain 임베딩 인터페이스를 감싸서 embed_documents 호출 시
    배치 단위로 진행률(0~100%)과 ETA를 콘솔에 표시합니다.
    """
    def __init__(self, base: HuggingFaceEmbeddings, total_texts: int, batch_size: int = 32, desc: str = "임베딩"):
        self.base = base
        self.total_texts = max(total_texts, 1)
        self.batch_size = max(1, batch_size)
        self.desc = desc
        self._last_print = 0.0

    # LangChain 인터페이스 유지
    def embed_query(self, text: str) -> List[float]:
        return self.base.embed_query(text)

    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        n = len(texts)
        # Milvus.from_documents 가 한 번에 texts 전체를 넘기므로, 내부에서 배치로 나눠 진행률 표시
        total = n
        start_ts = time.time()
        results: List[List[float]] = []
        processed = 0

        # 첫 메시지
        print(f"🧮 {self.desc} 시작: 총 {total}개 청크 | 배치 {self.batch_size} | 진행률 및 ETA 표출")

        for i in range(0, n, self.batch_size):
            batch = texts[i:i + self.batch_size]

            # 실제 임베딩 계산
            emb = self.base.embed_documents(batch)
            results.extend(emb)
            processed = min(i + len(batch), total)

            # 너무 잦은 출력 방지(EMBED_PROGRESS_INTERVAL 간격)
            now = time.time()
            if now - self._last_print >= EMBED_PROGRESS_INTERVAL or processed == total:
                _render_progress("🔄 임베딩", processed, total, start_ts)
                self._last_print = now

        # 완료 라인 보장
        _render_progress("✅ 임베딩", total, total, start_ts)
        return results

# ──────────────────────────────────────────────────────────────────────────────
# 상태 정의
# ──────────────────────────────────────────────────────────────────────────────
class IngestState(TypedDict):
    docsPath: str
    files: List[str]
    rawDocs: List[Document]
    vectorstore: Optional[Milvus]
    inserted: int
    collectionName: str

# ──────────────────────────────────────────────────────────────────────────────
# LangGraph 노드들
# ──────────────────────────────────────────────────────────────────────────────
from langgraph.graph import StateGraph, END
from langchain_core.runnables.graph import MermaidDrawMethod
from pymilvus import connections, MilvusClient, DataType

def ensure_milvus_node(state: IngestState) -> IngestState:
    print("🧩 노드: ensure_milvus (컬렉션 확인)")
    if "default" in connections.list_connections():
        connections.disconnect("default")
    connections.connect(alias="default", host="localhost", port="19530")

    client = MilvusClient(uri=MILVUS_URI, token=MILVUS_TOKEN)
    if client.has_collection(MILVUS_COLLECTION):
        print(f"  ↪ 기존 컬렉션 '{MILVUS_COLLECTION}' 삭제")
        client.drop_collection(MILVUS_COLLECTION)
    print(f"  ↪ Milvus 연결 및 컬렉션 준비 완료.")
    return state

def list_files_node(state: IngestState) -> IngestState:
    print("🧩 노드: list_files")
    docs_path = Path(state["docsPath"])
    allow_ext = {".txt", ".md", ".pdf"}
    files = [str(p) for p in sorted(docs_path.rglob("*")) if p.is_file() and p.suffix.lower() in allow_ext]
    print(f"  ↪ 대상 파일 {len(files)}개")
    if not files:
        print("  ⚠️ 'ingest_docs' 폴더에 .txt/.md/.pdf 파일을 넣어주세요.")
    return {**state, "files": files}

def load_and_ingest_node(state: IngestState) -> IngestState:
    print("🧩 노드: load_and_ingest_node (문서 로드 & Milvus에 인제스트)")
    all_docs: List[Document] = []
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=CHUNK_SIZE,
        chunk_overlap=CHUNK_OVERLAP,
        length_function=len,
    )

    # 로드 & 청크
    for fp in state["files"]:
        path = Path(fp)
        try:
            if path.suffix.lower() in {".txt", ".md"}:
                docs = TextLoader(str(path), autodetect_encoding=True).load()
            elif path.suffix.lower() == ".pdf":
                docs = PyPDFLoader(str(path)).load()
            else:
                continue

            for d in docs:
                d.metadata.setdefault("source", str(path.name))
                if "page" not in d.metadata:
                    d.metadata["page"] = 0

            chunks = text_splitter.split_documents(docs)
            all_docs.extend(chunks)
            print(f"  ↪ 로드 및 청크 완료: {path.name} ({len(chunks)}개 청크)")

        except Exception as e:
            print(f"  ⚠️ 처리 실패: {path.name} | {e}")

    if not all_docs:
        print("  ⚠️ 처리할 문서가 없습니다.")
        return {**state, "inserted": 0, "rawDocs": [], "vectorstore": None}

    print(f"🆕 총 {len(all_docs)}개 청크를 벡터스토어에 삽입 중...")

    # ✨ 진행률 표시용 임베딩 래퍼 적용
    try:
        progress_embedder = ProgressEmbeddings(
            base=embedding_model,
            total_texts=len(all_docs),
            batch_size=EMBED_BATCH_SIZE,
            desc="임베딩"
        )

        # Milvus.from_documents 내부에서 embed_documents를 호출하므로,
        # ProgressEmbeddings가 배치/진행률/ETA를 콘솔에 출력합니다.
        vectorstore = Milvus.from_documents(
            documents=all_docs,
            embedding=progress_embedder,  # ✨ 여기서 진행률 출력
            collection_name=state["collectionName"],
            connection_args={"host": "localhost", "port": "19530"}
        )
        print("✅ 벡터스토어 생성 및 문서 삽입 완료.")
        inserted_count = len(all_docs)

    except Exception as e:
        print(f"❌ Milvus 삽입 오류: {e}")
        inserted_count = 0
        vectorstore = None

    return {**state, "inserted": inserted_count, "rawDocs": all_docs, "vectorstore": vectorstore}

# ──────────────────────────────────────────────────────────────────────────────
# 그래프 빌드
# ──────────────────────────────────────────────────────────────────────────────
def build_graph():
    g = StateGraph(IngestState)
    g.add_node("ensure_milvus", ensure_milvus_node)
    g.add_node("list_files", list_files_node)
    g.add_node("load_and_ingest", load_and_ingest_node)

    g.set_entry_point("ensure_milvus")
    g.add_edge("ensure_milvus", "list_files")
    g.add_edge("list_files", "load_and_ingest")
    g.add_edge("load_and_ingest", END)

    return g.compile()

# ──────────────────────────────────────────────────────────────────────────────
# 메인
# ──────────────────────────────────────────────────────────────────────────────
def main():
    print("🚀 LangGraph 기반 Milvus Ingest 파이프라인 시작")
    agent_app = build_graph()

    try:
        graph_image_path = "milvus_agent_workflow_rag.png"
        png_bytes = agent_app.get_graph().draw_mermaid_png(draw_method=MermaidDrawMethod.API)
        with open(graph_image_path, "wb") as f:
            f.write(png_bytes)
        print(f"\n✅ LangGraph 구조가 '{graph_image_path}' 파일로 저장되었습니다.")
    except Exception as e:
        print(f"그래프 시각화 중 오류 발생: {e}")

    initial_state: IngestState = {
        "docsPath": str(DOCS_DIR),
        "files": [],
        "rawDocs": [],
        "vectorstore": None,
        "inserted": 0,
        "collectionName": MILVUS_COLLECTION,
    }

    final_state = agent_app.invoke(initial_state)

    print("\n📦 결과 요약")
    print(f"  - 처리된 파일 수: {len(final_state['files'])}")
    print(f"  - Milvus 컬렉션: {final_state['collectionName']}")
    print(f"  - 삽입된 청크 수: {final_state['inserted']}")

if __name__ == "__main__":
    main()
