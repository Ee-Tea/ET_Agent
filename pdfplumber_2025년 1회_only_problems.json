[
  {
    "question": "1. 소프트웨어 공학에서 워크스루(Walkthrough)에 대한 설명으로 틀린 것은?",
    "options": [
      "사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있다.",
      "복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.",
      "인스펙션(Inspection)과 동일한 의미를 가진다.",
      "단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 행해 보는 것이다."
    ]
  },
  {
    "question": "2. 애자일 방법론에 해당하지 않는 것은?",
    "options": [
      "기능 중심 개발",
      "개발 및 검증",
      "익스트림 프로그래밍",
      "칸반"
    ]
  },
  {
    "question": "2. { ob1.a = ob1.a + ob1.c[i]; ob2.a = ob2.a + ob2.c[i]; } printf(\"%d\", ob1.a + ob2.a); return 0; } ① 30 ② 60 ③ 80 ④ 120",
    "options": [
      "{ ob1.a = ob1.a + ob1.c[i]; ob2.a = ob2.a + ob2.c[i]; } printf(\"%d\", ob1.a + ob2.a); return 0; } ① 30 ② 60 ③ 80 ④ 120",
      "{ ob",
      "a = ob",
      "a + ob"
    ]
  },
  {
    "question": "3. 익스트림 프로그래밍에 대한 설명으로 틀린 것은?",
    "options": [
      "대표적인 구조적 방법론 중 하나이다.",
      "소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.",
      "익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다.",
      "구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스 코드에 중점을 둔다."
    ]
  },
  {
    "question": "4. 럼바우(Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며, 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?",
    "options": [
      "Object",
      "Dynamic",
      "Function",
      "Static"
    ]
  },
  {
    "question": "5. 설계 기법 중 하향식 설계 방법과 상향식 설계 방법에 대한 비교 설명으로 가장 옳지 않은 것은?",
    "options": [
      "하향식 설계에서는 통합 검사 시 인터페이스가 이미 정의되어 있어 통합이 간단하다.",
      "하향식 설계에서 레벨이 낮은 데이터 구조의 세부 사항은 설계 초기 단계에서 필요하다.",
      "상향식 설계는 최하위 수준에서 각각의 모듈들을 설계하고 러한 모듈이 완성되면 이들을 결합하여 검사한다.",
      "상향식 설계에서는 인터페이스가 이미 성립되어 있지 않더라 도 기능 추가가 쉽다."
    ]
  },
  {
    "question": "6. 요구사항 명세에 대한 설명으로 틀린 것은? ① 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것 이다. ② 기능 요구사항은 빠짐없이 완전하고 명확하게 기술해야 한다. ③ 잘못된 부분이 확인될 경우 그 내용을 요구사항 정의서에서 추적할 수 있어야 한다. ④ 구체적인 명세를 위해 자료 사전(DD)가 사용될 수 있다.",
    "options": [
      "요구사항 명세에 대한 설명으로 틀린 것은? ① 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것 이다. ② 기능 요구사항은 빠짐없이 완전하고 명확하게 기술해야 한다. ③ 잘못된 부분이 확인될 경우 그 내용을 요구사항 정의서에서 추적할 수 있어야 한다. ④ 구체적인 명세를 위해 자료 사전(DD)가 사용될 수 있다.",
      "요구사항 명세에 대한 설명으로 틀린 것은?",
      "분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것 이다.",
      "기능 요구사항은 빠짐없이 완전하고 명확하게 기술해야 한다."
    ]
  },
  {
    "question": "7. 바람직한 소프트웨어 설계 지침이 아닌 것은? ① 결합도를 최소화하고 응집도를 최대화한다. ② 복잡도와 중복성을 줄이고 일관성을 유지시킨다. ③ 하나의 입구와 하나의 출구를 갖도록 해야 한다. ④ 모듈의 크기를 가능한 작게 구성하여 병행성 수준을 높여야 한다. 수",
    "options": [
      "바람직한 소프트웨어 설계 지침이 아닌 것은? ① 결합도를 최소화하고 응집도를 최대화한다. ② 복잡도와 중복성을 줄이고 일관성을 유지시킨다. ③ 하나의 입구와 하나의 출구를 갖도록 해야 한다. ④ 모듈의 크기를 가능한 작게 구성하여 병행성 수준을 높여야 한다. 수",
      "바람직한 소프트웨어 설계 지침이 아닌 것은?",
      "결합도를 최소화하고 응집도를 최대화한다.",
      "복잡도와 중복성을 줄이고 일관성을 유지시킨다."
    ]
  },
  {
    "question": "8. UML(Unified Modeling Language)에 대한 설명 중 틀린 것은? ① 기능적 모델은 사용자 측면에서 본 시스템 기능이며, UML에서 는 Use Case Diagram을 사용한다. ② 정적 모델은 객체, 속성, 연관관계, 오퍼레이션의 시스템의 구 조를 나타내며, UML에서는 Class Diagram을 사용한다. ③ 동적 모델은 시스템의 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사 용한다. ④ State Diagram은 객체들 사이의 메시지 교환을 나타내며, Sequence Diagram은 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작 순서를 나타낸다.",
    "options": [
      "UML(Unified Modeling Language)에 대한 설명 중 틀린 것은? ① 기능적 모델은 사용자 측면에서 본 시스템 기능이며, UML에서 는 Use Case Diagram을 사용한다. ② 정적 모델은 객체, 속성, 연관관계, 오퍼레이션의 시스템의 구 조를 나타내며, UML에서는 Class Diagram을 사용한다. ③ 동적 모델은 시스템의 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사 용한다. ④ State Diagram은 객체들 사이의 메시지 교환을 나타내며, Sequence Diagram은 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작 순서를 나타낸다.",
      "UML(Unified Modeling Languag",
      "에 대한 설명 중 틀린 것은?",
      "기능적 모델은 사용자 측면에서 본 시스템 기능이며, UML에서 는 Use Case Diagram을 사용한다."
    ]
  },
  {
    "question": "9. 코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는? ① 연상 코드 ② 블록 코드 ③ 순차 코드 ④ 표의 숫자 코드",
    "options": [
      "코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는? ① 연상 코드 ② 블록 코드 ③ 순차 코드 ④ 표의 숫자 코드",
      "코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?",
      "연상 코드",
      "블록 코드"
    ]
  },
  {
    "question": "10. 시스템의 구성 요소로 볼 수 없는 것은? ① Process ② Feedback ③ Maintenance ④ Control",
    "options": [
      "시스템의 구성 요소로 볼 수 없는 것은? ① Process ② Feedback ③ Maintenance ④ Control",
      "시스템의 구성 요소로 볼 수 없는 것은?",
      "Process",
      "Feedback"
    ]
  },
  {
    "question": "11. 파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은? ① 노드와 간선으로 구성된다. ② 서브시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복한다. ③ 계층 모델이라고도 한다. ④ 3개의 서브시스템(모델, 뷰, 제어)으로 구성되어 있다. 이",
    "options": [
      "파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은? ① 노드와 간선으로 구성된다. ② 서브시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복한다. ③ 계층 모델이라고도 한다. ④ 3개의 서브시스템(모델, 뷰, 제어)으로 구성되어 있다. 이",
      "파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은?",
      "노드와 간선으로 구성된다.",
      "서브시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복한다."
    ]
  },
  {
    "question": "12. 데이터 흐름도(DFD)의 구성 요소에 포함되지 않는 것은? ① Data Flow ② Data Dictionary ③ Process ④ Data Store - 1 --- 페이지 2 오른쪽 --것은?",
    "options": [
      "데이터 흐름도(DFD)의 구성 요소에 포함되지 않는 것은? ① Data Flow ② Data Dictionary ③ Process ④ Data Store - 1 --- 페이지 2 오른쪽 --것은?",
      "데이터 흐름도(DF",
      "의 구성 요소에 포함되지 않는 것은?",
      "Data Flow"
    ]
  },
  {
    "question": "13. 사용자 인터페이스의 설계 지침에 대한 설명으로 옳지 않은",
    "options": [
      "조작 방법을 가능한 다양화하여 많은 기능이 들어갈 수 구성해야 한다.",
      "버튼이나 조작 방법 등을 일관성 있게 제공해야 한다.",
      "작동시킬 기능만 보고도 결과를 미리 예측할 수 있게 설계해야 한다.",
      "사용자가 쉽게 이해하고 편리하게 사용할 수 있는 환경을 해야 한다."
    ]
  },
  {
    "question": "14. UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 것은?",
    "options": [
      "유효성",
      "직관성",
      "학습성",
      "유연성"
    ]
  },
  {
    "question": "15. 디자인 패턴 사용의 장단점에 대한 설명으로 거리가 먼",
    "options": [
      "소프트웨어 구조 파악이 용이하다.",
      "초기 투자 비용 및 개발 시간이 절약된다.",
      "재사용을 위한 개발 시간이 단축된다.",
      "객체지향 설계 및 구현의 생산성을 높이는데 적합하다."
    ]
  },
  {
    "question": "16. UML에서 시퀀스 다이어그램의 구성 항목에 해당하지 않는",
    "options": [
      "생명선",
      "실행",
      "확장",
      "메시지"
    ]
  },
  {
    "question": "17. 소프트웨어 설계에서 각 모듈의 세분화된 역할이나 모듈들 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미하는 것은?",
    "options": [
      "모듈 분해",
      "클래스 도출",
      "연관 관계",
      "디자인 패턴"
    ]
  },
  {
    "question": "18. 소프트웨어 모델링과 관련한 설명으로 틀린 것은?",
    "options": [
      "모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수",
      "구조적 방법론에서는 DFD(Data Flow Diagram), DD(Data Dictionary) 등을 사용하여 요구사항의 결과를 표현한다.",
      "객체지향 방법론에서는 UML 표기법을 사용한다.",
      "소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 해도 및 이해 당사자 간의 의사소통 향상에 도움이"
    ]
  },
  {
    "question": "19. UML 모델에서 사용하는 구조적 다이어그램에 속하지 않은",
    "options": [
      "State Diagram",
      "Object Diagram",
      "Component Diagram",
      "Class Diagram"
    ]
  },
  {
    "question": "20. 객체 지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 표현한 데이터 추상화를 의미하는 것은?",
    "options": [
      "Method",
      "Class",
      "Field",
      "Message"
    ]
  },
  {
    "question": "21. 소스 코드 품질 분석 도구 중 정적 분석 도구가 아닌 것은?",
    "options": [
      "pmd",
      "cppcheck",
      "valMeter",
      "checkstyle"
    ]
  },
  {
    "question": "22. White Box Testing에 대한 설명으로 옳지 않은 것은? 있도록 ① Base Path Testing, Boundary Value Analysis가 대표적인 기법이다. ② Source Code의 모든 문장을 한 번 이상 수행함으로써 진행 된다. ③ 모듈 안의 작동을 직접 관찰할 수 있다. 제공 ④ 산출물의 각 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한 다. 한다는",
    "options": [
      "White Box Testing에 대한 설명으로 옳지 않은 것은? 있도록 ① Base Path Testing, Boundary Value Analysis가 대표적인 기법이다. ② Source Code의 모든 문장을 한 번 이상 수행함으로써 진행 된다. ③ 모듈 안의 작동을 직접 관찰할 수 있다. 제공 ④ 산출물의 각 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한 다. 한다는",
      "White Box Testing에 대한 설명으로 옳지 않은 것은? 있도록",
      "Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.",
      "Source Code의 모든 문장을 한 번 이상 수행함으로써 진행 된다."
    ]
  },
  {
    "question": "23. 소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은? ① Brooks의 법칙 ② Boehm의 법칙 ③ Pareto의 법칙 ④ Jackson의 법칙 것은?",
    "options": [
      "소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은? ① Brooks의 법칙 ② Boehm의 법칙 ③ Pareto의 법칙 ④ Jackson의 법칙 것은?",
      "소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?",
      "Brooks의 법칙",
      "Boehm의 법칙"
    ]
  },
  {
    "question": "24. 다음 트리의 차수(degree)는? 것은? ① 2 ② 3 간의 ③ 4 ④ 5 방안을",
    "options": [
      "다음 트리의 차수(degree)는? 것은? ① 2 ② 3 간의 ③ 4 ④ 5 방안을",
      "다음 트리의 차수(degre",
      "는? 것은?",
      "3 간의"
    ]
  },
  {
    "question": "25. 디지털 저작권 관리(DRM) 기술과 거리가 먼 것은? ① 콘텐츠 암호화 및 키 관리 ② 콘텐츠 식별체계 표현 ③ 콘텐츠 오류 감지 및 복구 ④ 라이센스 발급 및 관리 없다.",
    "options": [
      "디지털 저작권 관리(DRM) 기술과 거리가 먼 것은? ① 콘텐츠 암호화 및 키 관리 ② 콘텐츠 식별체계 표현 ③ 콘텐츠 오류 감지 및 복구 ④ 라이센스 발급 및 관리 없다.",
      "디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?",
      "콘텐츠 암호화 및 키 관리",
      "콘텐츠 식별체계 표현"
    ]
  },
  {
    "question": "26. 다음 자료에 대하여 “Selection Sort”를 사용하여 오름차순으로 정렬한 경우 PASS 3의 결과는? 초기상태 : 8, 3, 4, 9, 7 이 ① 3, 4, 7, 9, 8 ② 3, 4, 8, 9, 7 된다. ③ 3, 8, 4, 9, 7 ④ 3, 4, 7, 8, 9 것은?",
    "options": [
      "다음 자료에 대하여 “Selection Sort”를 사용하여 오름차순으로 정렬한 경우 PASS 3의 결과는? 초기상태 : 8, 3, 4, 9, 7 이 ① 3, 4, 7, 9, 8 ② 3, 4, 8, 9, 7 된다. ③ 3, 8, 4, 9, 7 ④ 3, 4, 7, 8, 9 것은?",
      "다음 자료에 대하여 “Selection Sort”를 사용하여 오름차순으로 정렬한 경우 PASS 3의 결과는? 초기상태 : 8, 3, 4, 9, 7 이",
      "3, 4, 7, 9, 8",
      "3, 4, 8, 9, 7 된다."
    ]
  },
  {
    "question": "27. 소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은? ① 품질 높은 소프트웨어 상품 개발 ② 지속적인 검증 시행 ③ 결과에 대한 명확한 기록 유지 ④ 최대한 많은 인력 투입 특성을",
    "options": [
      "소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은? ① 품질 높은 소프트웨어 상품 개발 ② 지속적인 검증 시행 ③ 결과에 대한 명확한 기록 유지 ④ 최대한 많은 인력 투입 특성을",
      "소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은?",
      "품질 높은 소프트웨어 상품 개발",
      "지속적인 검증 시행"
    ]
  },
  {
    "question": "28. 빌드 자동화 도구에 대한 설명으로 틀린 것은? ① Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다. ② 빌드 자동화 도구는 지속적인 통합 개발 환경에서 유용하게 활용된다. ③ 빌드 자동화 도구에는 Ant, Gradle, Jenkins 등이 있다. ④ Jenkins는 Groovy를 기반으로 한 오픈 소스로 안드로이드 앱 개발 환경에서 사용된다.",
    "options": [
      "빌드 자동화 도구에 대한 설명으로 틀린 것은? ① Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다. ② 빌드 자동화 도구는 지속적인 통합 개발 환경에서 유용하게 활용된다. ③ 빌드 자동화 도구에는 Ant, Gradle, Jenkins 등이 있다. ④ Jenkins는 Groovy를 기반으로 한 오픈 소스로 안드로이드 앱 개발 환경에서 사용된다.",
      "빌드 자동화 도구에 대한 설명으로 틀린 것은?",
      "Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다.",
      "빌드 자동화 도구는 지속적인 통합 개발 환경에서 유용하게 활용된다."
    ]
  },
  {
    "question": "29. 소프트웨어 형상 관리에서 관리 항목에 포함되지 않는 것은? ① 운영 및 설치 지침서 ② 프로젝트 개발 비용 ③ 소스 코드 ④ 프로젝트 요구 분석서 - 2 --- 페이지 3 오른쪽 --대한 ③ 검증은 작업 제품이 요구 명세의 기능, 비기능 요구사항을 얼마 나 잘 준수하는지 측정하는 작업이다. ④ 검증은 작업 제품이 사용자의 요구에 적합한지 측정하며, 확인 은 작업 제품이 개발자의 기대를 충족시키는지를 측정한다.",
    "options": [
      "소프트웨어 형상 관리에서 관리 항목에 포함되지 않는 것은? ① 운영 및 설치 지침서 ② 프로젝트 개발 비용 ③ 소스 코드 ④ 프로젝트 요구 분석서 - 2 --- 페이지 3 오른쪽 --대한 ③ 검증은 작업 제품이 요구 명세의 기능, 비기능 요구사항을 얼마 나 잘 준수하는지 측정하는 작업이다. ④ 검증은 작업 제품이 사용자의 요구에 적합한지 측정하며, 확인 은 작업 제품이 개발자의 기대를 충족시키는지를 측정한다.",
      "소프트웨어 형상 관리에서 관리 항목에 포함되지 않는 것은?",
      "운영 및 설치 지침서",
      "프로젝트 개발 비용"
    ]
  },
  {
    "question": "30. EAI(Enterprise Application Integration) 구축 유형 중 Hybrid에 설명으로 틀린 것은? ① Hub & Spoke와 Message Bus의 혼합 방식이다. ② 필요한 경우 한 가지 방식으로 EAI 구현이 가능하다. ③ 데이터 병목 현상을 최소화할 수 있다. ④ 중간에 미들웨어를 두지 않고 각 애플리케이션을 point point로 연결한다.",
    "options": [
      "EAI(Enterprise Application Integration) 구축 유형 중 Hybrid에 설명으로 틀린 것은? ① Hub & Spoke와 Message Bus의 혼합 방식이다. ② 필요한 경우 한 가지 방식으로 EAI 구현이 가능하다. ③ 데이터 병목 현상을 최소화할 수 있다. ④ 중간에 미들웨어를 두지 않고 각 애플리케이션을 point point로 연결한다.",
      "EAI(Enterprise Application Integration) 구축 유형 중 Hybrid에 설명으로 틀린 것은?",
      "Hub & Spoke와 Message Bus의 혼합 방식이다.",
      "필요한 경우 한 가지 방식으로 EAI 구현이 가능하다."
    ]
  },
  {
    "question": "31. 자료 구조에 대한 설명으로 틀린 것은? ① 큐는 비선형 구조에 해당한다. ② 큐는 First In – First Out 처리를 수행한다. ③ 스택은 Last In – First Out 처리를 수행한다. ④ 스택은 서브루틴 호출, 인터럽트 처리, 수식 계산 및 수식 법에 응용된다.",
    "options": [
      "자료 구조에 대한 설명으로 틀린 것은? ① 큐는 비선형 구조에 해당한다. ② 큐는 First In – First Out 처리를 수행한다. ③ 스택은 Last In – First Out 처리를 수행한다. ④ 스택은 서브루틴 호출, 인터럽트 처리, 수식 계산 및 수식 법에 응용된다.",
      "자료 구조에 대한 설명으로 틀린 것은?",
      "큐는 비선형 구조에 해당한다.",
      "큐는 First In – First Out 처리를 수행한다."
    ]
  },
  {
    "question": "32. 그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조는? ① tree ② network ③ stack ④ distributed",
    "options": [
      "그래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조는? ① tree ② network ③ stack ④ distributed",
      "그래프의 특수한 형태로 노드(Nod",
      "와 선분(Branch)으로 되어 정점 사이에 사이클(Cycl",
      "이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조는?"
    ]
  },
  {
    "question": "33. 테스트와 디버그의 목적으로 옳은 것은? ① 테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 업이다. ② 둘 다 소프트웨어 오류의 발견, 수정과 무관하다. ③ 테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 업이다. ④ 둘 다 소프트웨어의 오류를 찾는 작업으로 오류 수정은 않는다.",
    "options": [
      "테스트와 디버그의 목적으로 옳은 것은? ① 테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 업이다. ② 둘 다 소프트웨어 오류의 발견, 수정과 무관하다. ③ 테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 업이다. ④ 둘 다 소프트웨어의 오류를 찾는 작업으로 오류 수정은 않는다.",
      "테스트와 디버그의 목적으로 옳은 것은?",
      "테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 업이다.",
      "둘 다 소프트웨어 오류의 발견, 수정과 무관하다."
    ]
  },
  {
    "question": "34. 인터페이스 구현 검증 도구가 아닌 것은? ① Foxbase ② STAF ③ watir ④ xUnit",
    "options": [
      "인터페이스 구현 검증 도구가 아닌 것은? ① Foxbase ② STAF ③ watir ④ xUnit",
      "인터페이스 구현 검증 도구가 아닌 것은?",
      "Foxbase",
      "STAF"
    ]
  },
  {
    "question": "35. 소프트웨어 패키징에 대한 설명으로 틀린 것은? ① 패키징은 개발자 중심으로 진행한다. ② 신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품 으로 패키징 한다. ③ 고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 ④ 범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 징이 진행된다.",
    "options": [
      "소프트웨어 패키징에 대한 설명으로 틀린 것은? ① 패키징은 개발자 중심으로 진행한다. ② 신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품 으로 패키징 한다. ③ 고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 ④ 범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 징이 진행된다.",
      "소프트웨어 패키징에 대한 설명으로 틀린 것은?",
      "패키징은 개발자 중심으로 진행한다.",
      "신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품 으로 패키징 한다."
    ]
  },
  {
    "question": "36. 소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은? ① Correctness ② Portability ③ Efficiency ④ Usability",
    "options": [
      "소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은? ① Correctness ② Portability ③ Efficiency ④ Usability",
      "소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?",
      "Correctness",
      "Portability"
    ]
  },
  {
    "question": "37. 개별 모듈을 시험하는 것으로, 모듈이 정확하게 구현되었는지, 예정한 기능이 제대로 수행되는지를 점검하는 것이 주목적인 테스트 는? ① 통합 테스트(Integration Test) ② 단위 테스트(Unit Test) ③ 시스템 테스트(System Test) ④ 인수 테스트(Acceptance Test)",
    "options": [
      "개별 모듈을 시험하는 것으로, 모듈이 정확하게 구현되었는지, 예정한 기능이 제대로 수행되는지를 점검하는 것이 주목적인 테스트 는? ① 통합 테스트(Integration Test) ② 단위 테스트(Unit Test) ③ 시스템 테스트(System Test) ④ 인수 테스트(Acceptance Test)",
      "개별 모듈을 시험하는 것으로, 모듈이 정확하게 구현되었는지, 예정한 기능이 제대로 수행되는지를 점검하는 것이 주목적인 테스트 는?",
      "통합 테스트(Integration Test)",
      "단위 테스트(Unit Test)"
    ]
  },
  {
    "question": "38. 소프트웨어 테스트에서 검증(Verification)과 확인(Validation)에 한 설명으로 틀린 것은? ① 소프트웨어 테스트에서 검증과 확인을 구별하면 찾고자 결함 유형을 명확하게 하는 데 도움이 된다. ② 검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트하는 것이다. --- 페이지 4 왼쪽 --1회",
    "options": [
      "소프트웨어 테스트에서 검증(Verification)과 확인(Validation)에 한 설명으로 틀린 것은? ① 소프트웨어 테스트에서 검증과 확인을 구별하면 찾고자 결함 유형을 명확하게 하는 데 도움이 된다. ② 검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트하는 것이다. --- 페이지 4 왼쪽 --1회",
      "소프트웨어 테스트에서 검증(Verification)과 확인(Validation)에 한 설명으로 틀린 것은?",
      "소프트웨어 테스트에서 검증과 확인을 구별하면 찾고자 결함 유형을 명확하게 하는 데 도움이 된다.",
      "검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트하는 것이다. --- 페이지 4 왼쪽 --1회"
    ]
  },
  {
    "question": "39. 테스트를 목적에 따라 분류했을 때, 강도(Stress) 테스트에 대한 to 설명으로 옳은 것은? ① 시스템에 고의로 실패를 유도하고 시스템이 정상적으로 복귀 하는지 테스트한다. ② 시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정 상적으로 작동되는지를 테스트한다. ③ 사용자의 이벤트에 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 표기 테스트한다. ④ 부당하고 불법적인 침입을 시도하여 보안시스템이 불법적인 있고, 침투를 잘 막아내는지 테스트한다.",
    "options": [
      "테스트를 목적에 따라 분류했을 때, 강도(Stress) 테스트에 대한 to 설명으로 옳은 것은? ① 시스템에 고의로 실패를 유도하고 시스템이 정상적으로 복귀 하는지 테스트한다. ② 시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정 상적으로 작동되는지를 테스트한다. ③ 사용자의 이벤트에 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 표기 테스트한다. ④ 부당하고 불법적인 침입을 시도하여 보안시스템이 불법적인 있고, 침투를 잘 막아내는지 테스트한다.",
      "테스트를 목적에 따라 분류했을 때, 강도(Stress) 테스트에 대한 to 설명으로 옳은 것은?",
      "시스템에 고의로 실패를 유도하고 시스템이 정상적으로 복귀 하는지 테스트한다.",
      "시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정 상적으로 작동되는지를 테스트한다."
    ]
  },
  {
    "question": "40. 프로그램 설계도의 하나인 NS Chart에 대한 설명으로 가장 거리가 먼 것은? ① 논리의 기술에 중점을 두고 도형을 이용한 표현 방법이다. ② 이해하기 쉽고 코드 변환이 용이하다. ③ 화살표나 GOTO를 사용하여 이해하기 쉽다. 작 ④ 연속, 선택, 반복 등의 제어 논리 구조를 표현한다. 작 제3과목 데이터베이스 구축 하지",
    "options": [
      "프로그램 설계도의 하나인 NS Chart에 대한 설명으로 가장 거리가 먼 것은? ① 논리의 기술에 중점을 두고 도형을 이용한 표현 방법이다. ② 이해하기 쉽고 코드 변환이 용이하다. ③ 화살표나 GOTO를 사용하여 이해하기 쉽다. 작 ④ 연속, 선택, 반복 등의 제어 논리 구조를 표현한다. 작 제3과목 데이터베이스 구축 하지",
      "프로그램 설계도의 하나인 NS Chart에 대한 설명으로 가장 거리가 먼 것은?",
      "논리의 기술에 중점을 두고 도형을 이용한 표현 방법이다.",
      "이해하기 쉽고 코드 변환이 용이하다."
    ]
  },
  {
    "question": "41. 데이터 제어 언어(DCL)의 기능으로 옳지 않은 것은? ① 데이터 보안 ② 논리적, 물리적 데이터 구조 정의 ③ 무결성 유지 ④ 병행수행 제어",
    "options": [
      "데이터 제어 언어(DCL)의 기능으로 옳지 않은 것은? ① 데이터 보안 ② 논리적, 물리적 데이터 구조 정의 ③ 무결성 유지 ④ 병행수행 제어",
      "데이터 제어 언어(DCL)의 기능으로 옳지 않은 것은?",
      "데이터 보안",
      "논리적, 물리적 데이터 구조 정의"
    ]
  },
  {
    "question": "42. 병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은? ① 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다. ② 로킹 단위가 작아지면 로킹 오버헤드가 감소한다. ③ 로킹 단위가 작아지면 데이터베이스 공유도가 증가한다. 한다. ④ 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 한다. 패키",
    "options": [
      "병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은? ① 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다. ② 로킹 단위가 작아지면 로킹 오버헤드가 감소한다. ③ 로킹 단위가 작아지면 데이터베이스 공유도가 증가한다. 한다. ④ 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 한다. 패키",
      "병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?",
      "데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",
      "로킹 단위가 작아지면 로킹 오버헤드가 감소한다."
    ]
  },
  {
    "question": "43. 이행적 함수 종속 관계를 의미하는 것은? ① A → B이고 B → C일 때, A → C를 만족하는 관계 ② A → B이고 B → C일 때, C → A를 만족하는 관계 ③ A → B이고 B → C일 때, B → A를 만족하는 관계 ④ A → B이고 B → C일 때, C → B를 만족하는 관계",
    "options": [
      "이행적 함수 종속 관계를 의미하는 것은? ① A → B이고 B → C일 때, A → C를 만족하는 관계 ② A → B이고 B → C일 때, C → A를 만족하는 관계 ③ A → B이고 B → C일 때, B → A를 만족하는 관계 ④ A → B이고 B → C일 때, C → B를 만족하는 관계",
      "이행적 함수 종속 관계를 의미하는 것은?",
      "A → B이고 B → C일 때, A → C를 만족하는 관계",
      "A → B이고 B → C일 때, C → A를 만족하는 관계"
    ]
  },
  {
    "question": "44. SQL의 분류 중 DDL에 해당하지 않는 것은? ① UPDATE ② ALTER ③ DROP ④ CREATE",
    "options": [
      "SQL의 분류 중 DDL에 해당하지 않는 것은? ① UPDATE ② ALTER ③ DROP ④ CREATE",
      "SQL의 분류 중 DDL에 해당하지 않는 것은?",
      "UPDATE",
      "ALTER"
    ]
  },
  {
    "question": "45. 데이터베이스 로그(log)를 필요로 하는 회복 기법은? ① 즉각 갱신 기법 ② 대수적 코딩 방법 ③ 타임 스탬프 기법 ④ 폴딩 기법",
    "options": [
      "데이터베이스 로그(log)를 필요로 하는 회복 기법은? ① 즉각 갱신 기법 ② 대수적 코딩 방법 ③ 타임 스탬프 기법 ④ 폴딩 기법",
      "데이터베이스 로그(log)를 필요로 하는 회복 기법은?",
      "즉각 갱신 기법",
      "대수적 코딩 방법"
    ]
  },
  {
    "question": "46. Commit과 Rollback 명령어에 의해 보장 받는 트랜잭션의 특성은? 대 ① 병행성 ② 보안성 ③ 원자성 ④ 로그 하는 - 3 --- 페이지 4 오른쪽 --",
    "options": [
      "Commit과 Rollback 명령어에 의해 보장 받는 트랜잭션의 특성은? 대 ① 병행성 ② 보안성 ③ 원자성 ④ 로그 하는 - 3 --- 페이지 4 오른쪽 --",
      "Commit과 Rollback 명령어에 의해 보장 받는 트랜잭션의 특성은? 대",
      "병행성",
      "보안성"
    ]
  },
  {
    "question": "47. 한 릴레이션 스키마가 4개 속성, 2개 후보키 그리고 그 스키마의 대응 릴레이션 인스턴스가 7개 튜플을 갖는다면 그 릴레이션의 차수(Degree)는? ① 1 ② 2 ③ 4 ④ 7",
    "options": [
      "한 릴레이션 스키마가 4개 속성, 2개 후보키 그리고 그 스키마의 대응 릴레이션 인스턴스가 7개 튜플을 갖는다면 그 릴레이션의 차수(Degree)는? ① 1 ② 2 ③ 4 ④ 7",
      "한 릴레이션 스키마가 4개 속성, 2개 후보키 그리고 그 스키마의 대응 릴레이션 인스턴스가 7개 튜플을 갖는다면 그 릴레이션의 차수(Degre",
      "는?"
    ]
  },
  {
    "question": "48. 사용자 X1에게 department 테이블에 대한 검색 연산을 회수하는 명령은? ① delete select on department to X1; ② remove select on department from X1; ③ revoke select on department from X1; ④ grant select on department from X1;",
    "options": [
      "사용자 X1에게 department 테이블에 대한 검색 연산을 회수하는 명령은? ① delete select on department to X1; ② remove select on department from X1; ③ revoke select on department from X1; ④ grant select on department from X1;",
      "사용자 X1에게 department 테이블에 대한 검색 연산을 회수하는 명령은?",
      "delete select on department to X1;",
      "remove select on department from X1;"
    ]
  },
  {
    "question": "49. 개체-관계 모델의 E-R 다이어그램에서 사용되는 기호와 그 의미의 연결이 틀린 것은? ① 마름모 - 관계 타입 ② 선 – 개체 타입과 속성을 연결 ③ 사각형 - 개체 타입 ④ 삼각형 - 속성",
    "options": [
      "개체-관계 모델의 E-R 다이어그램에서 사용되는 기호와 그 의미의 연결이 틀린 것은? ① 마름모 - 관계 타입 ② 선 – 개체 타입과 속성을 연결 ③ 사각형 - 개체 타입 ④ 삼각형 - 속성",
      "개체-관계 모델의 E-R 다이어그램에서 사용되는 기호와 그 의미의 연결이 틀린 것은?",
      "마름모 - 관계 타입",
      "선 – 개체 타입과 속성을 연결"
    ]
  },
  {
    "question": "50. 3NF에서 BCNF가 되기 위한 조건은? ① 이행적 함수 종속 제거 ② 부분적 함수 종속 제거 ③ 다치 종속 제거 ④ 결정자이면서 후보키가 아닌 것 제거",
    "options": [
      "3NF에서 BCNF가 되기 위한 조건은? ① 이행적 함수 종속 제거 ② 부분적 함수 종속 제거 ③ 다치 종속 제거 ④ 결정자이면서 후보키가 아닌 것 제거",
      "3NF에서 BCNF가 되기 위한 조건은?",
      "이행적 함수 종속 제거",
      "부분적 함수 종속 제거"
    ]
  },
  {
    "question": "51. 뷰(VIEW)에 대한 설명으로 옳지 않은 것은? ① DBA는 보안 측면에서 뷰를 활용할 수 있다. ② 뷰 위에 또 다른 뷰를 정의할 수 있다. ③ 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다. ④ 독립적인 인덱스를 가질 수 없다.",
    "options": [
      "뷰(VIEW)에 대한 설명으로 옳지 않은 것은? ① DBA는 보안 측면에서 뷰를 활용할 수 있다. ② 뷰 위에 또 다른 뷰를 정의할 수 있다. ③ 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약사항이 따르지 않는다. ④ 독립적인 인덱스를 가질 수 없다.",
      "뷰(VIEW)에 대한 설명으로 옳지 않은 것은?",
      "DBA는 보안 측면에서 뷰를 활용할 수 있다.",
      "뷰 위에 또 다른 뷰를 정의할 수 있다."
    ]
  },
  {
    "question": "52. 다음 릴레이션의 카디널리티와 차수가 옳게 나타낸 것은? 아이디 성명 나이 등급 적립금 가입년도 yuyu01 원유철 36 3 2000 2008 sykim10 김성일 29 2 3300 2014 kshan4 한경선 45 3 2800 2009 namsu52 이남수 33 5 1000 2016 ① 카디널리티 : 4, 차수 : 4 ② 카디널리티 : 4, 차수 : 6 ③ 카디널리티 : 6, 차수 : 4 ④ 카디널리티 : 6, 차수 : 6",
    "options": [
      "다음 릴레이션의 카디널리티와 차수가 옳게 나타낸 것은? 아이디 성명 나이 등급 적립금 가입년도 yuyu01 원유철 36 3 2000 2008 sykim10 김성일 29 2 3300 2014 kshan4 한경선 45 3 2800 2009 namsu52 이남수 33 5 1000 2016 ① 카디널리티 : 4, 차수 : 4 ② 카디널리티 : 4, 차수 : 6 ③ 카디널리티 : 6, 차수 : 4 ④ 카디널리티 : 6, 차수 : 6",
      "다음 릴레이션의 카디널리티와 차수가 옳게 나타낸 것은? 아이디 성명 나이 등급 적립금 가입년도 yuyu01 원유철 36 3 2000 2008 sykim10 김성일 29 2 3300 2014 kshan4 한경선 45 3 2800 2009 namsu52 이남수 33 5 1000 2016",
      "카디널리티 : 4, 차수 : 4",
      "카디널리티 : 4, 차수 : 6"
    ]
  },
  {
    "question": "53. 다음 SQL 문에서 ( ) 안에 들어갈 내용으로 옳은 것은? UPDATE 인사급여 ( ) 호봉 = 15 WHERE 성명 = ‘홍길동’; ① SET ② FROM ③ INTO ④ IN",
    "options": [
      "다음 SQL 문에서 ( ) 안에 들어갈 내용으로 옳은 것은? UPDATE 인사급여 ( ) 호봉 = 15 WHERE 성명 = ‘홍길동’; ① SET ② FROM ③ INTO ④ IN",
      "다음 SQL 문에서 ( ) 안에 들어갈 내용으로 옳은 것은? UPDATE 인사급여 ( ) 호봉 = 15 WHERE 성명 = ‘홍길동’;",
      "SET",
      "FROM"
    ]
  },
  {
    "question": "54. 병행제어 기법의 종류가 아닌 것은? ① 로킹 기법 ② 시분할 기법 ③ 타임 스탬프 기법 ④ 다중 버전 기법",
    "options": [
      "병행제어 기법의 종류가 아닌 것은? ① 로킹 기법 ② 시분할 기법 ③ 타임 스탬프 기법 ④ 다중 버전 기법",
      "병행제어 기법의 종류가 아닌 것은?",
      "로킹 기법",
      "시분할 기법"
    ]
  },
  {
    "question": "55. SQL의 논리 연산자가 아닌 것은? ① AND ② OTHER ③ OR ④ NOT --- 페이지 5 왼쪽 --1회",
    "options": [
      "SQL의 논리 연산자가 아닌 것은? ① AND ② OTHER ③ OR ④ NOT --- 페이지 5 왼쪽 --1회",
      "SQL의 논리 연산자가 아닌 것은?",
      "AND",
      "OTHER"
    ]
  },
  {
    "question": "56. 관계대수에 대한 설명으로 틀린 것은? ① 원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어 이다. ② 릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모 두 릴레이션이다. ③ 일반 집합 연산과 순수 관계 연산으로 구분된다. ④ 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시 한다.",
    "options": [
      "관계대수에 대한 설명으로 틀린 것은? ① 원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어 이다. ② 릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모 두 릴레이션이다. ③ 일반 집합 연산과 순수 관계 연산으로 구분된다. ④ 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시 한다.",
      "관계대수에 대한 설명으로 틀린 것은?",
      "원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어 이다.",
      "릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모 두 릴레이션이다."
    ]
  },
  {
    "question": "57. SQL문에서 HAVING을 사용할 수 있는 절은? ① LIKE 절 ② WHERE 절 ③ GROUP BY 절 ④ ORDER BY 절",
    "options": [
      "SQL문에서 HAVING을 사용할 수 있는 절은? ① LIKE 절 ② WHERE 절 ③ GROUP BY 절 ④ ORDER BY 절",
      "SQL문에서 HAVING을 사용할 수 있는 절은?",
      "LIKE 절",
      "WHERE 절"
    ]
  },
  {
    "question": "58. 데이터베이스의 무결성 규정(Integrity Rule)과 관련한 설명으로 틀린 것은? ① 무결성 규정에는 데이터가 만족해야 될 제약 조건, 규정을 참조 할 때 사용하는 식별자 등의 요소가 포함될 수 있다. ② 무결성 규정의 대상으로는 도메인, 키, 종속성 등이 있다. ③ 정식으로 허가받은 사용자가 아닌 불법적인 사용자에 의한 갱 신으로부터 데이터베이스를 보호하기 위한 규정이다. ④ 릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션 을 조작하는 과정에서의 의미적 관계(Semantic Relationship) 를 명세한 것이다.",
    "options": [
      "데이터베이스의 무결성 규정(Integrity Rule)과 관련한 설명으로 틀린 것은? ① 무결성 규정에는 데이터가 만족해야 될 제약 조건, 규정을 참조 할 때 사용하는 식별자 등의 요소가 포함될 수 있다. ② 무결성 규정의 대상으로는 도메인, 키, 종속성 등이 있다. ③ 정식으로 허가받은 사용자가 아닌 불법적인 사용자에 의한 갱 신으로부터 데이터베이스를 보호하기 위한 규정이다. ④ 릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션 을 조작하는 과정에서의 의미적 관계(Semantic Relationship) 를 명세한 것이다.",
      "데이터베이스의 무결성 규정(Integrity Rul",
      "과 관련한 설명으로 틀린 것은?",
      "무결성 규정에는 데이터가 만족해야 될 제약 조건, 규정을 참조 할 때 사용하는 식별자 등의 요소가 포함될 수 있다."
    ]
  },
  {
    "question": "59. 분산 데이터베이스 시스템(Distributed Database System)에 대한 설명으로 틀린 것은? ① 분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있다. ② 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다. ③ 데이터베이스의 설계가 비교적 어렵고, 개발 비용과 처리 비용 이 증가한다는 단점이 있다. ④ 분산 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, P2P 시스템, 단일 데이터베이스 등이 있다.",
    "options": [
      "분산 데이터베이스 시스템(Distributed Database System)에 대한 설명으로 틀린 것은? ① 분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있다. ② 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다. ③ 데이터베이스의 설계가 비교적 어렵고, 개발 비용과 처리 비용 이 증가한다는 단점이 있다. ④ 분산 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, P2P 시스템, 단일 데이터베이스 등이 있다.",
      "분산 데이터베이스 시스템(Distributed Database System)에 대한 설명으로 틀린 것은?",
      "분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있다.",
      "위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다."
    ]
  },
  {
    "question": "60. CREATE TABLE문에 포함되지 않는 기능은? ① 속성 타입 변경 ② 속성의 NOT NULL 여부 지정 ③ 기본키를 구성하는 속성 지정 ④ CHECK 제약조건의 정의 제4과목 프로그래밍 언어 활용",
    "options": [
      "CREATE TABLE문에 포함되지 않는 기능은? ① 속성 타입 변경 ② 속성의 NOT NULL 여부 지정 ③ 기본키를 구성하는 속성 지정 ④ CHECK 제약조건의 정의 제4과목 프로그래밍 언어 활용",
      "CREATE TABLE문에 포함되지 않는 기능은?",
      "속성 타입 변경",
      "속성의 NOT NULL 여부 지정"
    ]
  },
  {
    "question": "61. IP 주소체계와 관련한 설명으로 틀린 것은? ① IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다. ② IPv6는 주소 자동설정(Auto Configuration) 기능을 통해 손쉽 게 이용자의 단말을 네트워크에 접속시킬 수 있다. ③ IPv4는 호스트 주소를 자동으로 설정하며 유니캐스트 (Unicast)를 지원한다. ④ IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다르다.",
    "options": [
      "IP 주소체계와 관련한 설명으로 틀린 것은? ① IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다. ② IPv6는 주소 자동설정(Auto Configuration) 기능을 통해 손쉽 게 이용자의 단말을 네트워크에 접속시킬 수 있다. ③ IPv4는 호스트 주소를 자동으로 설정하며 유니캐스트 (Unicast)를 지원한다. ④ IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다르다.",
      "IP 주소체계와 관련한 설명으로 틀린 것은?",
      "IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다.",
      "IPv6는 주소 자동설정(Auto Configuration) 기능을 통해 손쉽 게 이용자의 단말을 네트워크에 접속시킬 수 있다."
    ]
  },
  {
    "question": "62. 효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것은? ① 모듈 간의 결합도를 강하게 하면 모듈 독립성이 향상된다. ② 복잡도와 중복성을 줄이고 일관성을 유지시킨다. ③ 모듈의 기능은 예측이 가능해야 한다. ④ 유지보수가 용이해야 한다. - 4 --- 페이지 5 오른쪽 --",
    "options": [
      "효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것은? ① 모듈 간의 결합도를 강하게 하면 모듈 독립성이 향상된다. ② 복잡도와 중복성을 줄이고 일관성을 유지시킨다. ③ 모듈의 기능은 예측이 가능해야 한다. ④ 유지보수가 용이해야 한다. - 4 --- 페이지 5 오른쪽 --",
      "효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것은?",
      "모듈 간의 결합도를 강하게 하면 모듈 독립성이 향상된다.",
      "복잡도와 중복성을 줄이고 일관성을 유지시킨다."
    ]
  },
  {
    "question": "63. 다음 C 언어 프로그램이 실행되었을 때, 실행 결과는? #include <stdio.h> struct st { int a; int c[10]; }; int main(int argc, char* argv[]) { int i = 0; struct st ob1; struct st ob2; ob1.a = 0; ob2.a = 0; for (i = 0; i < 10; i++) { ob1.c[i] = i; ob2.c[i] = ob1.c[i] + i; } for (i = 0; i < 10; i = i +",
    "options": [
      "다음 C 언어 프로그램이 실행되었을 때, 실행 결과는? #include <stdio.h> struct st { int a; int c[10]; }; int main(int argc, char* argv[]) { int i = 0; struct st ob1; struct st ob2; ob1.a = 0; ob2.a = 0; for (i = 0; i < 10; i++) { ob1.c[i] = i; ob2.c[i] = ob1.c[i] + i; } for (i = 0; i < 10; i = i +",
      "다음 C 언어 프로그램이 실행되었을 때, 실행 결과는? #include <stdio.h> struct st { int a; int c[10]; }; int main(int argc, char* argv[]) { int i = 0; struct st ob1; struct st ob2; ob",
      "a = 0; ob",
      "a = 0; for (i = 0; i < 10; i++) { ob"
    ]
  },
  {
    "question": "64. 다음 중 C 언어에서 우선 순위가 가장 높은 것은? ① 비트 연산자 ② 시프트 연산자 ③ 관계 연산자 ④ 산술 연산자",
    "options": [
      "다음 중 C 언어에서 우선 순위가 가장 높은 것은? ① 비트 연산자 ② 시프트 연산자 ③ 관계 연산자 ④ 산술 연산자",
      "다음 중 C 언어에서 우선 순위가 가장 높은 것은?",
      "비트 연산자",
      "시프트 연산자"
    ]
  },
  {
    "question": "65. 다음 파이썬 코드에서 ‘53t44’를 입력했을 때 출력 a, b = map(int, input().split(\"t\")); print(a, b) ① 53 t 44 ② 53t44 ③ 53 44 ④ 53, 44",
    "options": [
      "다음 파이썬 코드에서 ‘53t44’를 입력했을 때 출력 a, b = map(int, input().split(\"t\")); print(a, b) ① 53 t 44 ② 53t44 ③ 53 44 ④ 53, 44",
      "다음 파이썬 코드에서 ‘53t44’를 입력했을 때 출력 a, b = map(int, input().split(\"t\")); print(a,",
      "53 t 44",
      "53t44"
    ]
  },
  {
    "question": "66. 흐름 제어(Flow Control)에 대한 설명으로 옳지 않은 ① 정지-대기는 수신 측의 확인 신호(ACK)를 받은 킷을 전송하는 방식이다. ② 확인 신호를 이용하여 송신 데이터의 양을 조절하는 슬라이딩 윈도우이다. ③ 확인 신호 없이 보낼 수 있는 패킷의 최대치가 윈도우 ④ 이전에 송신한 패킷에 대한 부정 수신 응답(NAK)이 경우 윈도우 크기가 증가한다.",
    "options": [
      "흐름 제어(Flow Control)에 대한 설명으로 옳지 않은 ① 정지-대기는 수신 측의 확인 신호(ACK)를 받은 킷을 전송하는 방식이다. ② 확인 신호를 이용하여 송신 데이터의 양을 조절하는 슬라이딩 윈도우이다. ③ 확인 신호 없이 보낼 수 있는 패킷의 최대치가 윈도우 ④ 이전에 송신한 패킷에 대한 부정 수신 응답(NAK)이 경우 윈도우 크기가 증가한다.",
      "흐름 제어(Flow Control)에 대한 설명으로 옳지 않은",
      "정지-대기는 수신 측의 확인 신호(ACK)를 받은 킷을 전송하는 방식이다.",
      "확인 신호를 이용하여 송신 데이터의 양을 조절하는 슬라이딩 윈도우이다."
    ]
  },
  {
    "question": "67. 다음 C 언어 프로그램이 실행되었을 때의 결과는? #include <stdio.h> int main(void) { int n = 4; int* pt = NULL; pt = &n; printf(\"%d\", &n + *pt - *&pt + n); return 0; } ① 0 ② 4 ③ 8 ④ 12",
    "options": [
      "다음 C 언어 프로그램이 실행되었을 때의 결과는? #include <stdio.h> int main(void) { int n = 4; int* pt = NULL; pt = &n; printf(\"%d\", &n + *pt - *&pt + n); return 0; } ① 0 ② 4 ③ 8 ④ 12",
      "다음 C 언어 프로그램이 실행되었을 때의 결과는? #include <stdio.h> int main(voi",
      "{ int n = 4; int* pt = NULL; pt = &n; printf(\"%d\", &n + *pt - *&pt + n); return 0; }",
      "12"
    ]
  },
  {
    "question": "68. 커널의 버전을 확인할 때 사용하는 리눅스 명령어는? ① ls ② chmod ③ rm ④ uname --- 페이지 6 왼쪽 --1회",
    "options": [
      "커널의 버전을 확인할 때 사용하는 리눅스 명령어는? ① ls ② chmod ③ rm ④ uname --- 페이지 6 왼쪽 --1회",
      "커널의 버전을 확인할 때 사용하는 리눅스 명령어는?",
      "ls",
      "chmod"
    ]
  },
  {
    "question": "69. 시간 구역성(Temporal Locality)과 거리가 먼 것은? ① 루프 ② 서브루틴 ③ 배열 순회 ④ 스택",
    "options": [
      "시간 구역성(Temporal Locality)과 거리가 먼 것은? ① 루프 ② 서브루틴 ③ 배열 순회 ④ 스택",
      "시간 구역성(Temporal Locality)과 거리가 먼 것은?",
      "루프",
      "서브루틴"
    ]
  },
  {
    "question": "70. 다음 C언어 프로그램이 실행되었을 때의 결과는? #include <stdio.h> main() { char* s = \"Sinagong\"; for (int i = 5; i > 0; i--) printf(\"%c\", *(s + i)); } ① inago ② ogani ③ sinagong ④ gnoganis",
    "options": [
      "다음 C언어 프로그램이 실행되었을 때의 결과는? #include <stdio.h> main() { char* s = \"Sinagong\"; for (int i = 5; i > 0; i--) printf(\"%c\", *(s + i)); } ① inago ② ogani ③ sinagong ④ gnoganis",
      "다음 C언어 프로그램이 실행되었을 때의 결과는? #include <stdio.h> main() { char* s = \"Sinagong\"; for (int i = 5; i > 0; i--) printf(\"%c\", *(s + i)); }",
      "inago",
      "ogani"
    ]
  },
  {
    "question": "71. OSI 7계층 모델에서 전송에 필요한 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성을 정의한 계층은? ① 물리 계층 ② 데이터 링크 계층 ③ 네트워크 계층 ④ 전송 계층",
    "options": [
      "OSI 7계층 모델에서 전송에 필요한 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성을 정의한 계층은? ① 물리 계층 ② 데이터 링크 계층 ③ 네트워크 계층 ④ 전송 계층",
      "OSI 7계층 모델에서 전송에 필요한 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성을 정의한 계층은?",
      "물리 계층",
      "데이터 링크 계층"
    ]
  },
  {
    "question": "72. 다음 자바 코드를 실행한 결과는? int x＝1, y＝6; while (y--) { x＋＋; } System.out.println(“x＝” x＋“y＝” y); ① x＝7 y＝0 ② x＝6 y＝-1 결과는? ③ x＝7 y＝-1 ④ Unresolved compilation problem 오류 발생",
    "options": [
      "다음 자바 코드를 실행한 결과는? int x＝1, y＝6; while (y--) { x＋＋; } System.out.println(“x＝” x＋“y＝” y); ① x＝7 y＝0 ② x＝6 y＝-1 결과는? ③ x＝7 y＝-1 ④ Unresolved compilation problem 오류 발생",
      "다음 자바 코드를 실행한 결과는? int x＝1, y＝6; while (y--) { x＋＋; } System.out.println(“x＝” x＋“y＝” y);",
      "x＝7 y＝0",
      "x＝6 y＝-1 결과는?"
    ]
  },
  {
    "question": "73. UNIX에서 새로운 프로세스를 생성하는 명령어는? ① ls ② cat ③ fork ④ chmod",
    "options": [
      "UNIX에서 새로운 프로세스를 생성하는 명령어는? ① ls ② cat ③ fork ④ chmod",
      "UNIX에서 새로운 프로세스를 생성하는 명령어는?",
      "ls",
      "cat"
    ]
  },
  {
    "question": "74. 128.107.176.0/22 네트워크에서 호스트에 의해 사용될 수 있는 것은? 서브넷 마스크는? 후에 다음 패 ① 255.0.0.0 ② 255.248.0.0 ③ 255.255.252.0 ④ 255.255.255.255 방식은",
    "options": [
      "128.107.176.0/22 네트워크에서 호스트에 의해 사용될 수 있는 것은? 서브넷 마스크는? 후에 다음 패 ① 255.0.0.0 ② 255.248.0.0 ③ 255.255.252.0 ④ 255.255.255.255 방식은",
      "0/22 네트워크에서 호스트에 의해 사용될 수 있는 것은? 서브넷 마스크는? 후에 다음 패",
      "255 방식은"
    ]
  },
  {
    "question": "75. 다음 C 언어 프로그램이 실행되었을 때, 실행 결과는? 크기이다. 전달된 #include <stdio.h> #include <stdlib.h> int main(int argc, char* argv[]) { char str1[20] = \"KOREA\"; char str2[20] = \"LOVE\"; char* p1 = NULL; char* p2 = NULL; p1 = str1; p2 = str2; str1[1] = p2[2]; str2[3] = p1[4]; strcat(str1, str2); printf(\"%c\", *(p1 + 2)); return 0; } ① E ② V ③ R ④ O - 5 --- 페이지 6 오른쪽 --④ 소프트웨어 비용 결정 요소에는 프로젝트 요소, 자원 요소, 생 산성 요소가 있다.",
    "options": [
      "다음 C 언어 프로그램이 실행되었을 때, 실행 결과는? 크기이다. 전달된 #include <stdio.h> #include <stdlib.h> int main(int argc, char* argv[]) { char str1[20] = \"KOREA\"; char str2[20] = \"LOVE\"; char* p1 = NULL; char* p2 = NULL; p1 = str1; p2 = str2; str1[1] = p2[2]; str2[3] = p1[4]; strcat(str1, str2); printf(\"%c\", *(p1 + 2)); return 0; } ① E ② V ③ R ④ O - 5 --- 페이지 6 오른쪽 --④ 소프트웨어 비용 결정 요소에는 프로젝트 요소, 자원 요소, 생 산성 요소가 있다.",
      "다음 C 언어 프로그램이 실행되었을 때, 실행 결과는? 크기이다. 전달된 #include <stdio.h> #include <stdlib.h> int main(int argc, char* argv[]) { char str1[20] = \"KOREA\"; char str2[20] = \"LOVE\"; char* p1 = NULL; char* p2 = NULL; p1 = str1; p2 = str2; str1[1] = p2[2]; str2[3] = p1[4]; strcat(str1, str",
      "; printf(\"%c\", *(p1 +",
      "); return 0; }"
    ]
  },
  {
    "question": "76. 다음과 같은 세그먼트 테이블을 가지는 시스템에서 논리 주소(2, 176)에 대한 물리 주소는? 세그먼트번호 시작주소 길이(바이트) 0 670 248 1 1752 422 2 222 198 3 996 604 ① 398 ② 400 ③ 1928 ④ 1930",
    "options": [
      "다음과 같은 세그먼트 테이블을 가지는 시스템에서 논리 주소(2, 176)에 대한 물리 주소는? 세그먼트번호 시작주소 길이(바이트) 0 670 248 1 1752 422 2 222 198 3 996 604 ① 398 ② 400 ③ 1928 ④ 1930",
      "다음과 같은 세그먼트 테이블을 가지는 시스템에서 논리 주소(2, 1",
      "에 대한 물리 주소는? 세그먼트번호 시작주소 길이(바이",
      "0 670 248 1 1752 422 2 222 198 3 996 604"
    ]
  },
  {
    "question": "77. 스크립트(Script) 언어가 아닌 것은? ① PHP ② Fortran ③ Basic ④ Python",
    "options": [
      "스크립트(Script) 언어가 아닌 것은? ① PHP ② Fortran ③ Basic ④ Python",
      "스크립트(Script) 언어가 아닌 것은?",
      "PHP",
      "Fortran"
    ]
  },
  {
    "question": "78. 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도는? ① 내용 결합도(Content Coupling) ② 제어 결합도(Control Coupling) ③ 공통 결합도(Common Coupling) ④ 스탬프 결합도(Stamp Coupling)",
    "options": [
      "한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도는? ① 내용 결합도(Content Coupling) ② 제어 결합도(Control Coupling) ③ 공통 결합도(Common Coupling) ④ 스탬프 결합도(Stamp Coupling)",
      "한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도는?",
      "내용 결합도(Content Coupling)",
      "제어 결합도(Control Coupling)"
    ]
  },
  {
    "question": "79. 파일 디스크립터(File Descriptor)에 대한 설명으로 틀린 것은? ① 파일 관리를 위해 시스템이 필요로 하는 정보를 가지고 ② 파일 제어 블록(File Control Block)이라고도 한다. ③ 사용자가 파일 디스크립터를 직접 참조할 수 없다. ④ 주기억장치에 저장되어 있다가 파일이 개방(open)되면 보조기 억장치로 이동된다.",
    "options": [
      "파일 디스크립터(File Descriptor)에 대한 설명으로 틀린 것은? ① 파일 관리를 위해 시스템이 필요로 하는 정보를 가지고 ② 파일 제어 블록(File Control Block)이라고도 한다. ③ 사용자가 파일 디스크립터를 직접 참조할 수 없다. ④ 주기억장치에 저장되어 있다가 파일이 개방(open)되면 보조기 억장치로 이동된다.",
      "파일 디스크립터(File Descriptor)에 대한 설명으로 틀린 것은?",
      "파일 관리를 위해 시스템이 필요로 하는 정보를 가지고",
      "파일 제어 블록(File Control Block)이라고도 한다."
    ]
  },
  {
    "question": "80. C 언어 라이브러리 중 stdlib.h에 대한 설명으로 옳은 것은? ① 문자열을 수치 데이터로 바꾸는 문자 변환 함수와 수치를 열로 바꿔주는 변환 함수 등이 있다. ② 문자열 처리 함수로 strlen()이 포함되어 있다. ③ 표준 입출력 라이브러리이다. ④ 삼각 함수, 제곱근, 지수 등 수학적인 함수를 내장하고 제5과목 : 정보시스템 구축 관리",
    "options": [
      "C 언어 라이브러리 중 stdlib.h에 대한 설명으로 옳은 것은? ① 문자열을 수치 데이터로 바꾸는 문자 변환 함수와 수치를 열로 바꿔주는 변환 함수 등이 있다. ② 문자열 처리 함수로 strlen()이 포함되어 있다. ③ 표준 입출력 라이브러리이다. ④ 삼각 함수, 제곱근, 지수 등 수학적인 함수를 내장하고 제5과목 : 정보시스템 구축 관리",
      "C 언어 라이브러리 중 stdlib.h에 대한 설명으로 옳은 것은?",
      "문자열을 수치 데이터로 바꾸는 문자 변환 함수와 수치를 열로 바꿔주는 변환 함수 등이 있다.",
      "문자열 처리 함수로 strlen()이 포함되어 있다."
    ]
  },
  {
    "question": "81. 데이터의 송·수신 사실을 증명할 수 있도록 송·수신 증거를 제공해야 한다는 보안 요소는? ① 기밀성 ② 무결성 ③ 가용성 ④ 부인 방지",
    "options": [
      "데이터의 송·수신 사실을 증명할 수 있도록 송·수신 증거를 제공해야 한다는 보안 요소는? ① 기밀성 ② 무결성 ③ 가용성 ④ 부인 방지",
      "데이터의 송·수신 사실을 증명할 수 있도록 송·수신 증거를 제공해야 한다는 보안 요소는?",
      "기밀성",
      "무결성"
    ]
  },
  {
    "question": "82. 악성코드의 유형 중 다른 컴퓨터의 취약점을 이용하여 스스로 전파하 거나 메일로 전파되며 스스로를 증식하는 것은? ① Worm ② Rogue Ware ③ Adware ④ Reflection Attack",
    "options": [
      "악성코드의 유형 중 다른 컴퓨터의 취약점을 이용하여 스스로 전파하 거나 메일로 전파되며 스스로를 증식하는 것은? ① Worm ② Rogue Ware ③ Adware ④ Reflection Attack",
      "악성코드의 유형 중 다른 컴퓨터의 취약점을 이용하여 스스로 전파하 거나 메일로 전파되며 스스로를 증식하는 것은?",
      "Worm",
      "Rogue Ware"
    ]
  },
  {
    "question": "83. 다음 중 소프트웨어 비용 산정에 대한 설명으로 옳지 않은 ① 소프트웨어의 규모, 인력 등의 요소를 기반으로 개발에 필요한 비용을 예측하는 것이다. ② 소프트웨어 비용 산정 기법에는 상향식, 하향식, 혼합식 기법이 있다. ③ 소프트웨어 비용을 높게 산정할 경우 예산 낭비와 일의 효율성 저하를 초래할 수 있다. --- 페이지 7 왼쪽 --1회",
    "options": [
      "다음 중 소프트웨어 비용 산정에 대한 설명으로 옳지 않은 ① 소프트웨어의 규모, 인력 등의 요소를 기반으로 개발에 필요한 비용을 예측하는 것이다. ② 소프트웨어 비용 산정 기법에는 상향식, 하향식, 혼합식 기법이 있다. ③ 소프트웨어 비용을 높게 산정할 경우 예산 낭비와 일의 효율성 저하를 초래할 수 있다. --- 페이지 7 왼쪽 --1회",
      "다음 중 소프트웨어 비용 산정에 대한 설명으로 옳지 않은",
      "소프트웨어의 규모, 인력 등의 요소를 기반으로 개발에 필요한 비용을 예측하는 것이다.",
      "소프트웨어 비용 산정 기법에는 상향식, 하향식, 혼합식 기법이 있다."
    ]
  },
  {
    "question": "84. 프로젝트에 내재된 위험 요소를 인식하고 그 영향을 분석하여 이를 관리하는 활동으로서, 프로젝트를 성공시키기 위하여 위험 요소를 사전에 예측, 대비하는 모든 기술과 활동을 포함하는 것은? ① Critical Path Method ② Risk Analysis ③ Work Breakdown Structure ④ Waterfall Model",
    "options": [
      "프로젝트에 내재된 위험 요소를 인식하고 그 영향을 분석하여 이를 관리하는 활동으로서, 프로젝트를 성공시키기 위하여 위험 요소를 사전에 예측, 대비하는 모든 기술과 활동을 포함하는 것은? ① Critical Path Method ② Risk Analysis ③ Work Breakdown Structure ④ Waterfall Model",
      "프로젝트에 내재된 위험 요소를 인식하고 그 영향을 분석하여 이를 관리하는 활동으로서, 프로젝트를 성공시키기 위하여 위험 요소를 사전에 예측, 대비하는 모든 기술과 활동을 포함하는 것은?",
      "Critical Path Method",
      "Risk Analysis"
    ]
  },
  {
    "question": "85. 국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영 환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은? ① N2OS ② PaaS-TA ③ KAWS ④ Metaverse",
    "options": [
      "국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영 환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은? ① N2OS ② PaaS-TA ③ KAWS ④ Metaverse",
      "국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영 환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은?",
      "N2OS",
      "PaaS-TA"
    ]
  },
  {
    "question": "86. 다음 암호 알고리즘 중 성격이 다른 하나는? ① MD4 ② MD5 ③ SHA-1 ④ AES",
    "options": [
      "다음 암호 알고리즘 중 성격이 다른 하나는? ① MD4 ② MD5 ③ SHA-1 ④ AES",
      "다음 암호 알고리즘 중 성격이 다른 하나는?",
      "MD4",
      "MD5"
    ]
  },
  {
    "question": "87. 최대 홉수를 15로 제한한 라우팅 프로토콜은? ① RIP ② OSPF ③ Static ④ EIGRP",
    "options": [
      "최대 홉수를 15로 제한한 라우팅 프로토콜은? ① RIP ② OSPF ③ Static ④ EIGRP",
      "최대 홉수를 15로 제한한 라우팅 프로토콜은?",
      "RIP",
      "OSPF"
    ]
  },
  {
    "question": "88. COCOMO 모델의 프로젝트 유형으로 거리가 먼 것은? 있다. ① Organic ② Semi-detached ③ Embedded ④ Sequential",
    "options": [
      "COCOMO 모델의 프로젝트 유형으로 거리가 먼 것은? 있다. ① Organic ② Semi-detached ③ Embedded ④ Sequential",
      "COCOMO 모델의 프로젝트 유형으로 거리가 먼 것은? 있다.",
      "Organic",
      "Semi-detached"
    ]
  },
  {
    "question": "89. 개인키 암호화 기법으로 옳지 않은 것은? ① DES ② ARIA 문자 ③ SEED ④ RSA",
    "options": [
      "개인키 암호화 기법으로 옳지 않은 것은? ① DES ② ARIA 문자 ③ SEED ④ RSA",
      "개인키 암호화 기법으로 옳지 않은 것은?",
      "DES",
      "ARIA 문자"
    ]
  },
  {
    "question": "90. 다음 중 소프트웨어 개발 보안 생명주기 방법론이 아닌 것은? ① CLASP ② SDL 있다. ③ PIMS ④ Seven Touchpoints",
    "options": [
      "다음 중 소프트웨어 개발 보안 생명주기 방법론이 아닌 것은? ① CLASP ② SDL 있다. ③ PIMS ④ Seven Touchpoints",
      "다음 중 소프트웨어 개발 보안 생명주기 방법론이 아닌 것은?",
      "CLASP",
      "SDL 있다."
    ]
  },
  {
    "question": "91. 간트 차트(Gantt Chart)에 대한 설명으로 틀린 것은? ① 프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와준다. ② 자원 배치 계획에 유용하게 사용된다. ③ CPM 네트워크로부터 만드는 것이 가능하다. ④ 수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타낸다.",
    "options": [
      "간트 차트(Gantt Chart)에 대한 설명으로 틀린 것은? ① 프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와준다. ② 자원 배치 계획에 유용하게 사용된다. ③ CPM 네트워크로부터 만드는 것이 가능하다. ④ 수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타낸다.",
      "간트 차트(Gantt Chart)에 대한 설명으로 틀린 것은?",
      "프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와준다.",
      "자원 배치 계획에 유용하게 사용된다."
    ]
  },
  {
    "question": "92. 다음에서 설명하는 소프트웨어 정의 기술(SDx)는? ㆍ가상화를 적용하여 필요한 공간만큼 나눠 사용할 수 있 도록 하며 서버 가상화와 유사함 ㆍ컴퓨팅 소프트웨어로 규정하는 데이터 스토리지 체계이 며, 일정 조직 내 여러 스토리지를 하나처럼 관리하고 운용하는 컴퓨터 이용 환경 ㆍ스토리지 자원을 효율적으로 나누어 쓰는 방법으로 이해 할 수 있음 것은? ① Software Defined Storage ② Distribution Oriented Storage ③ Network Architected Storage ④ Systematic Network Storage - 6 --- 페이지 7 오른쪽 --암호 알고리즘에 대한 설명으로 틀린 스를 이용하지 못하게 하는 것이다. ④ Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다. 실행 속도가 빠르기 때문에 다양 수 있다. 전달을 위한 키 교환이 필요하지 속도가 빠르다. 보관하는 비밀키를 이용하 적용이 가능하다. AES, IDEA 등이 있다. 태스크에 해당되지 않는 것은? ② 위험 분석 ④ 평가 중 기존 소프트웨어를 다른 운영체제 수 있도록 변환하는 것은? ② 분석 ④ 이식 중 서로 이해 충돌 관계에 있는 모델은? Model) Wall Model) Model) Integrity Model) 관련한 설명으로 변화를 배제하고 신속히 진행하여 방법론을 적용하기 위해 절차, 산출 활동이다. 최단 기간에 안정적인 프로젝 식별하고 제거하는 것이다. 하나는 프로젝트에 최적화된 기술 특성에 맞는 최적의 기법과 도구를 반환될 경우 발생하는 문제점으 외부에서 접근할 수 있게 된다. 틀린 것은? 받아 고정된 길이의 해쉬값으로 키 생성을 위해 사용한다. HAVAL, SHA-1 등이 있다. function)이다. 관련한 내용으로 틀린 것은? 크기보다 큰 ICMP 패킷을 작은 공격 대상이 조각화 된 패킷을 활용하여 공격 대상이 패킷을 보내게 만드는 공격이다. 않는 클라이언트가 서버별로 한정 것처럼 속여 다른 사용자가 서비 - 7 -",
    "options": [
      "다음에서 설명하는 소프트웨어 정의 기술(SDx)는? ㆍ가상화를 적용하여 필요한 공간만큼 나눠 사용할 수 있 도록 하며 서버 가상화와 유사함 ㆍ컴퓨팅 소프트웨어로 규정하는 데이터 스토리지 체계이 며, 일정 조직 내 여러 스토리지를 하나처럼 관리하고 운용하는 컴퓨터 이용 환경 ㆍ스토리지 자원을 효율적으로 나누어 쓰는 방법으로 이해 할 수 있음 것은? ① Software Defined Storage ② Distribution Oriented Storage ③ Network Architected Storage ④ Systematic Network Storage - 6 --- 페이지 7 오른쪽 --암호 알고리즘에 대한 설명으로 틀린 스를 이용하지 못하게 하는 것이다. ④ Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다. 실행 속도가 빠르기 때문에 다양 수 있다. 전달을 위한 키 교환이 필요하지 속도가 빠르다. 보관하는 비밀키를 이용하 적용이 가능하다. AES, IDEA 등이 있다. 태스크에 해당되지 않는 것은? ② 위험 분석 ④ 평가 중 기존 소프트웨어를 다른 운영체제 수 있도록 변환하는 것은? ② 분석 ④ 이식 중 서로 이해 충돌 관계에 있는 모델은? Model) Wall Model) Model) Integrity Model) 관련한 설명으로 변화를 배제하고 신속히 진행하여 방법론을 적용하기 위해 절차, 산출 활동이다. 최단 기간에 안정적인 프로젝 식별하고 제거하는 것이다. 하나는 프로젝트에 최적화된 기술 특성에 맞는 최적의 기법과 도구를 반환될 경우 발생하는 문제점으 외부에서 접근할 수 있게 된다. 틀린 것은? 받아 고정된 길이의 해쉬값으로 키 생성을 위해 사용한다. HAVAL, SHA-1 등이 있다. function)이다. 관련한 내용으로 틀린 것은? 크기보다 큰 ICMP 패킷을 작은 공격 대상이 조각화 된 패킷을 활용하여 공격 대상이 패킷을 보내게 만드는 공격이다. 않는 클라이언트가 서버별로 한정 것처럼 속여 다른 사용자가 서비 - 7 -",
      "다음에서 설명하는 소프트웨어 정의 기술(SDx)는? ㆍ가상화를 적용하여 필요한 공간만큼 나눠 사용할 수 있 도록 하며 서버 가상화와 유사함 ㆍ컴퓨팅 소프트웨어로 규정하는 데이터 스토리지 체계이 며, 일정 조직 내 여러 스토리지를 하나처럼 관리하고 운용하는 컴퓨터 이용 환경 ㆍ스토리지 자원을 효율적으로 나누어 쓰는 방법으로 이해 할 수 있음 것은?",
      "Software Defined Storage",
      "Distribution Oriented Storage"
    ]
  },
  {
    "question": "93. 대칭 암호 알고리즘과 비대칭 것은? ① 대칭 암호 알고리즘은 비교적 한 암호의 핵심 함수로 사용될 ② 대칭 암호 알고리즘은 비밀키 않아 암호화 및 복호화의 ③ 비대칭 암호 알고리즘은 자신만이 여 인증, 전자서명 등에 ④ 대표적인 대칭키 암호 알고리즘으로는",
    "options": [
      "대칭 암호 알고리즘과 비대칭 것은? ① 대칭 암호 알고리즘은 비교적 한 암호의 핵심 함수로 사용될 ② 대칭 암호 알고리즘은 비밀키 않아 암호화 및 복호화의 ③ 비대칭 암호 알고리즘은 자신만이 여 인증, 전자서명 등에 ④ 대표적인 대칭키 암호 알고리즘으로는",
      "대칭 암호 알고리즘과 비대칭 것은?",
      "대칭 암호 알고리즘은 비교적 한 암호의 핵심 함수로 사용될",
      "대칭 암호 알고리즘은 비밀키 않아 암호화 및 복호화의"
    ]
  },
  {
    "question": "96. 강제 접근통제(MAC)의 보안 모델 객체 간의 정보 접근을 통제하는 ① 벨 라파듈라 모델(Bell-LaPadula ② 만리장성 모델(Chinese ③ 비바 무결성 모델(Biba Integrity ④ 클락-윌슨 무결성 모델(Clark-Wilson",
    "options": [
      "강제 접근통제(MAC)의 보안 모델 객체 간의 정보 접근을 통제하는 ① 벨 라파듈라 모델(Bell-LaPadula ② 만리장성 모델(Chinese ③ 비바 무결성 모델(Biba Integrity ④ 클락-윌슨 무결성 모델(Clark-Wilson",
      "강제 접근통제(MA",
      "의 보안 모델 객체 간의 정보 접근을 통제하는",
      "벨 라파듈라 모델(Bell-LaPadula"
    ]
  },
  {
    "question": "97. 소프트웨어 개발 방법론의 테일러링(Tailoring)과 틀린 것은? ① 프로젝트 수행 시 예상되는 야 한다. ② 프로젝트에 최적화된 개발 물 등을 적절히 변경하는 ③ 관리 측면에서의 목적 중 하나는 트 진행을 위한 사전 위험을 ④ 기술적 측면에서의 목적 중 요소를 도입하여 프로젝트 사용하는 것이다.",
    "options": [
      "소프트웨어 개발 방법론의 테일러링(Tailoring)과 틀린 것은? ① 프로젝트 수행 시 예상되는 야 한다. ② 프로젝트에 최적화된 개발 물 등을 적절히 변경하는 ③ 관리 측면에서의 목적 중 하나는 트 진행을 위한 사전 위험을 ④ 기술적 측면에서의 목적 중 요소를 도입하여 프로젝트 사용하는 것이다.",
      "소프트웨어 개발 방법론의 테일러링(Tailoring)과 틀린 것은?",
      "프로젝트 수행 시 예상되는 야 한다.",
      "프로젝트에 최적화된 개발 물 등을 적절히 변경하는"
    ]
  },
  {
    "question": "98. Public 메소드로부터 Private 배열이 로 가장 옳은 것은? ① 메소드로의 접근이 불가능해진다. ② 배열의 주소가 외부로 공개되어 ③ 시스템의 내부 정보가 노출된다. ④ 동기화 오류가 발생한다.",
    "options": [
      "Public 메소드로부터 Private 배열이 로 가장 옳은 것은? ① 메소드로의 접근이 불가능해진다. ② 배열의 주소가 외부로 공개되어 ③ 시스템의 내부 정보가 노출된다. ④ 동기화 오류가 발생한다.",
      "Public 메소드로부터 Private 배열이 로 가장 옳은 것은?",
      "메소드로의 접근이 불가능해진다.",
      "배열의 주소가 외부로 공개되어"
    ]
  },
  {
    "question": "99. 해쉬(Hash) 기법에 대한 설명으로 ① 임의의 길이의 입력 데이터를 변환한다. ② 주로 공개키 암호화 방식에서 ③ 대표적인 해쉬 알고리즘으로 ④ 해쉬 함수는 일방향 함수(One-way",
    "options": [
      "해쉬(Hash) 기법에 대한 설명으로 ① 임의의 길이의 입력 데이터를 변환한다. ② 주로 공개키 암호화 방식에서 ③ 대표적인 해쉬 알고리즘으로 ④ 해쉬 함수는 일방향 함수(One-way",
      "해쉬(Hash) 기법에 대한 설명으로",
      "임의의 길이의 입력 데이터를 변환한다.",
      "주로 공개키 암호화 방식에서"
    ]
  },
  {
    "question": "100. DoS(Denial of Service) 공격과 ① Ping of Death 공격은 정상 조각(Fragment)으로 쪼개어 처리하게 만드는 공격 방법이다. ② Smurf 공격은 멀티캐스트(Multicast)를 네트워크의 임의의 시스템에 ③ SYN Flooding은 존재하지 된 접속 가능 공간에 접속한",
    "options": [
      "DoS(Denial of Servic",
      "공격과",
      "Ping of Death 공격은 정상 조각(Fragment)으로 쪼개어 처리하게 만드는 공격 방법이다.",
      "Smurf 공격은 멀티캐스트(Multicast)를 네트워크의 임의의 시스템에"
    ]
  }
]