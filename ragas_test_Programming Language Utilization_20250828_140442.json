{
  "test_info": {
    "subject_area": "Programming Language Utilization",
    "timestamp": "20250828_140442",
    "total_questions": 3
  },
  "context": "문서 1: 순서대로 일련의 명령어를 나열하여 프로그래밍한다. \nFunction 기반의 프로그래밍이며, 프로시저로써 Function 외에도 Subroutine이 \n문법적으로 구현되어 있다. \n절차형 언어의 경우 규모가 커지면 커질수록 함수가 기하급수적으로 늘어난다. \n함수가 타 프로그램과 문제를 일으킬 수 있는 문제점을 가지고 있다. \n프로그램과 별개로 데이터 취급이 되므로 완전하지 않고 현실 세계 문제를 프로그램으로 \n표현하는데 제약이 있다. \n객체지향 프로그래밍(Object Oriented Programming) \n \n컴퓨터 소프트웨어를 구조적인 코드 단위로 보는 것이 아니라 Object 단위로 구분하고 \nObject 간의 모음으로 설계하는 것이다.\n\n문서 2: 언어 번역 프로그램(Language Translator Program) \n프로그래머가 작성한 원시 프로그램을 컴퓨터가 이해할 수 있는 형식으로 번역한다. \n종류 : 컴파일러, 어셈블러, 인터프리터 등 \n서비스 프로그램(Service Program) \n사용자의 편의를 위해 사용 빈도가 높은 프로그램을 시스템 제공자가 미리 작성하여 \n사용자에게 제공해 주는 프로그램이다. \n종류 : 연계 편집, 유틸리티, 정렬, 병합 등 \n문제 프로그램(Problem Program) \n특정 업무를 처리하기 위해 사용자가 작성한 프로그램이다. \n56. 프로세스 관리 \n프로세스 \n프로세스(Process)의 정의 \n \n실행 중인 프로그램이다. \n실행 가능한 PCB를 가진 프로그램이다. \n프로세서가 할당되는 실체이다. \n프로시저가 활동 중인 것이다. \n비동기적 행위를 일으키는 주체이다. \n프로세스 제어 블록(PCB: Process Control Block) \n \n운영체제가 프로세스를 관리하기 위해 프로세스에 대한 중요한 정보를 저장해 놓은 곳이다. \n프로세스가 생성될 때마다 고유의 PCB가 생성되며, 프로세스가 소멸되면 PCB도 소멸된다. \nPCB에 저장되어 있는 정보 : 프로세스의 현재 상태, 프로세스의 우선순위, 프로세스에 \n할당된 자원에 대한 정보, CPU 레지스터 정보 \n프로세스 상태 전이 \n \n생성(New) -> 준비(Ready) -(디스패치-Dispatch)-> 실행(Run) -> 종료(Exit) \n                ↑        <-(Timer Runout)-    ↙ \n             Wake Up            Block ←------- \n                |           ↙ \n           대기(Blocked) ←-- \n준비 상태(Ready State) \n프로세스가 CPU를 할당받기 위해 준비하고 있는 상태이다. \n실행 상태(Running State) \n준비 상태의 프로세스가 CPU를 할당받아 실행 중인 상태이다.\n\n문서 3: 회2\n- 8 -\n요구공학은 요구사항 개발보다 더 큰 범주에 해당하므로 요구\n사항 개발이 요구공학의 한 요소가 됩니다.\n는 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 XP\n대한 책임을 공동으로 나눠 갖는 환경을 조성합니다.\nㆍ클래스 다이어그램은 클래스와 클래스가 가지는 속성 클래, \n스 사이의 관계를 표현하는 다이어그램입니다.\nㆍ 번은 커뮤니케이션 다이어그램에 대한 설명입니다.①\n문제의 지문은 차트에 대한 설명입니다HIPO .\n여러 프로세스가 동시에 참조할 수는 없지만 어디서든 참조할 \n수 있는 객체를 생성하는 디자인 패턴은 싱글톤 입(Singleton)\n니다.\nㆍ옵서버 패턴(Observer) 한 객체의 상태가 변화하면 객체 : \n에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 \n패턴\nㆍ프로토타입 패턴(Prototype) 원본 객체를 복제하는 방법 : \n으로 객체를 생성하는 패턴\nㆍ상태 패턴(State) 객체의 상태에 따라 동일한 동작을 다르 : \n게 처리해야 할 때 사용하는 패턴\n객체지향 기법에서 객체가 메시지를 받아 실행해야 할 객체의 \n구체적인 연산을 정의한 것을 메소드 라고 합니다(Method) .\nㆍ개체(Entity)사람 자동차 컴퓨터 고양이 등과 같이 우리  : , , , \n주위에서 사용되는 물질적이거나 개념적인 것을 의미함\nㆍ인스턴스(Instance)클래스에 속한 각각의 객체를 인스턴 : \n스 라 하며 클래스로부터 새로운 객체를 생성하(Instance) , \n는 것을 인스턴스화 라고 함(Instantiation)\nㆍ클래스(Class)공통된 속성과 연산 행위 을 갖는 객체의  : ( )\n집합으로 객체의 일반적인 타입 을 의미함, (Type)\n모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 \n크기로 분해해야 합니다.\nㆍ인터페이스 분리 원칙 은 자신이 사용하지 않는 인터페(ISP)\n이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙\n입니다. \nㆍ 번은 단일 책임 원칙 에 대한 설명입니다(SRP) .④\n\n문서 4: 회2\n- 5 -\n제 과목 프로그래밍 언어 활용4개발에 필요한 환경 구축과 관련하여 하드웨어 환경과 관련이 없는 61. 것은?Eclipse① Oracle DB② WAS③ 웹 서버④ 에 대한 설명으로 옳지 않은 것은62. UNIX ?상당 부분 언어를 사용하여 작성되었으며 이식성이 우수하C , ① 다.사용자는 하나 이상의 작업을 백그라운드에서 수행할 수 있어 ② 여러 개의 작업을 병행 처리할 수 있다.쉘 은 프로세스 관리 기억장치 관리 입출력 관리 등의 (Shell) , , ③ 기능을 수행한다.두 사람 이상의 사용자가 동시에 시스템을 사용할 수 있어 정보④ 와 유틸리티들을 공유하는 편리한 작업 환경을 제공한다.또는 의 명령어에서 키보드의 키와 같이 커서를 63. C Java printf [Tab] 일정 간격 띄어주는데 사용하는 제어문자는?r① ＼  t② ＼b③ ＼ n④ ＼다음 내용이 설명하는 결합도는64. ?\n한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이\n를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계\n된 경우에 발생하며 권리 전도 현상이 발생할 수 있다, .\n\n문서 5: •\t시스템\t소프트웨어를\t개발하기\t편리하여\t시스템\t\n프로그래밍\t언어로\t널리\t사용됨\n•자료의\t주소를\t조작할\t수\t있는\t포인터를\t제공함\t\n•\t고급\t프로그래밍\t언어이면서\t저급\t프로그램\t언어\n의\t특징을\t모두\t갖춤\n•UNIX의\t일부가\tC\t언어로\t구현됨\n•컴파일러\t방식의\t언어\n•\t이식성이\t좋아\t컴퓨터\t기종에\t관계없이\t프로그램\n을\t작성할\t수\t있음\nALGOL\n•\t수치\t계산이나\t논리\t연산을\t위한\t과학\t기술\t계산용\t\n언어\n•PASCAL과\tC\t언어의\t모체가\t됨\nCOBOL\n•사무\t처리용\t언어\n•\t영어\t문장\t형식으로\t구성되어\t있어\t이해와\t사용이\t\n쉬움\n•4개의\tDIVISION으로\t구성되어\t있음\nFORTRAN\n•과학\t기술\t계산용\t언어임\n•\t수학과\t공학\t분야의\t공식이나\t수식과\t같은\t형태로\t\n프로그래밍\t할\t수\t있음\nC언어의 사용자 정의 함수와 같이 클래스 없이 메소드만 \n단독으로 사용할 수 있다.\n예제   다음 프로그램의 실행 결과를 확인하시오.\ndef\tcalc(x,\ty):\t\t❸  메소드\tcalc의\t시작점이다.\t❷번에서\tcalc(a,\tb)\n라고\t했으므로\tx는\ta의\t값\t3을\t받고,\ty는\tb의\t\n값\t12를\t받는다.\n\t\t\t\tx\t*=\t3\t\t❹\t x\t=\tx\t*\t3이므로\tx는\t9가\t된다.\n\t\t\t\ty\t/=\t3\t\t❺\t y\t=\ty\t/\t3이므로\ty는\t4가\t된다.\n\t\t\t\tprint(x,\ty)\t\t❻\t 결과 9 4.0\n\t\t\t\treturn\tx\t\t❼\t \tx의\t값을\t반환한다.\tx의\t값\t9를\t❷번의\ta에\t저\n장한\t후\t제어를\t❽번으로\t옮긴다.\na,\tb\t=\t3,\t12\t\t❶\t 변수\ta와\tb에\t3과\t12를\t저장한다.\na\t=\tcalc(a,\tb)\t\t❷\t\ta,\tb\t즉\t3과\t12를\t인수로\t하여\tcalc\t메소드를\t\n호출한\t결과를\ta에\t저장한다.\t❸번으로\t이동\t\n한다.\nprint(a,\tb)\t\t❽\t 결과\n9 4.0\n9 12\n\t\n절차적 프로그래밍 언어의  \n종류\n401403\n275핵심\n2024 메일링핵심 정보처리기사 필기(001~116)_ej2.indd   87 2024. 5. 8.   오후 3:50",
  "questions": [
    {
      "question": "What is the characteristic of procedural programming?",
      "options": [
        "Function-based programming",
        "Object-oriented programming",
        "Procedure-based programming",
        "Event-driven programming"
      ],
      "answer": "1",
      "explanation": "Procedural programming is characterized by its focus on procedures and functions, which are used to perform specific tasks.",
      "subject": "Programming Language Utilization"
    },
    {
      "question": "What is the purpose of a process control block (PCB) in operating system?",
      "options": [
        "To manage memory allocation",
        "To manage file systems",
        "To store information about a process",
        "To manage network connections"
      ],
      "answer": "3",
      "explanation": "A process control block (PCB) is a data structure used by the operating system to store information about a process, including its current state, priority, and allocated resources.",
      "subject": "Programming Language Utilization"
    },
    {
      "question": "What is the design pattern that allows only one instance of an object to be created?",
      "options": [
        "Prototype pattern",
        "Observer pattern",
        "Singleton pattern",
        "State pattern"
      ],
      "answer": "3",
      "explanation": "The Singleton pattern is a design pattern that ensures only one instance of a class is created, and provides a global point of access to that instance.",
      "subject": "Programming Language Utilization"
    }
  ],
  "ragas_results": {
    "faithfulness": [
      NaN,
      NaN,
      NaN
    ],
    "answer_relevancy": [
      NaN,
      NaN,
      NaN
    ],
    "context_precision": [
      NaN,
      NaN,
      NaN
    ],
    "context_recall": [
      NaN,
      NaN,
      NaN
    ]
  }
}