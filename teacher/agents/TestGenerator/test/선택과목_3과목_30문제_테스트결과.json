{
  "exam_title": "정보처리기사 선택과목 모의고사 (3과목)",
  "total_questions": 30,
  "difficulty": "중급",
  "selected_subjects": [
    "소프트웨어설계",
    "데이터베이스구축",
    "프로그래밍언어활용"
  ],
  "questions_per_subject": 10,
  "subjects": {
    "소프트웨어설계": {
      "requested_count": 10,
      "actual_count": 10,
      "questions": [
        {
          "question": "소프트웨어 아키텍처의 정의로 가장 적절한 것은?",
          "options": [
            "  1. 소프트웨어의 내부 구조 및 동적 행위들을 정의하는 것",
            "  2. 소프트웨어의 외부 인터페이스를 정의하는 것",
            "  3. 소프트웨어의 성능을 최적화하는 것",
            "  4. 소프트웨어의 테스트 케이스를 작성하는 것"
          ],
          "answer": "1",
          "explanation": "소프트웨어 아키텍처는 소프트웨어의 내부 구조 및 동적 행위들을 정의하는 것이다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 설계에서 행위 모델링의 목적은?",
          "options": [
            "  1. 시스템의 기능적인 특성을 모델링하는 것",
            "  2. 시스템의 비기능적인 특성을 모델링하는 것",
            "  3. 시스템의 구조를 모델링하는 것",
            "  4. 시스템의 테스트 케이스를 작성하는 것"
          ],
          "answer": "1",
          "explanation": "행위 모델링은 시스템의 기능적인 특성을 모델링하는 것이다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 생명주기 모형 중 폭포수 모형의 특징은?",
          "options": [
            "  1. 각 단계가 끝난 후 결과물이 명확히 나와야 함",
            "  2. 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 쉬움",
            "  3. 사용자들이 모든 요구사항들을 명확하게 제시해야 함",
            "  4. 단계별 정의가 불분명하고, 전체 공조의 이해가 어려움"
          ],
          "answer": "1",
          "explanation": "폭포수 모형은 각 단계가 끝난 후 결과물이 명확히 나와야 한다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 설계에서 모듈 간의 계층적 구성을 나타낸 것은?",
          "options": [
            "  1. 구조도",
            "  2. 흐름도",
            "  3. 상태도",
            "  4. 계층도"
          ],
          "answer": "4",
          "explanation": "계층도는 모듈 간의 계층적 구성을 나타낸 것이다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 아키텍처의 장점 중 하나는?",
          "options": [
            "  1. 정보은닉의 원칙 적용",
            "  2. 높은 이식성을 가진다",
            "  3. 추가적인 실행 시 오버헤드가 발생한다",
            "  4. 시스템의 복잡성이 증가한다"
          ],
          "answer": "2",
          "explanation": "소프트웨어 아키텍처의 장점 중 하나는 높은 이식성을 가진다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 생명주기 단계 중에서 시간과 비용이 가장 많이 요구되는 단계는?",
          "options": [
            "  1. 정의 단계",
            "  2. 개발 단계",
            "  3. 유지보수 단계",
            "  4. 테스트 단계"
          ],
          "answer": "3",
          "explanation": "유지보수 단계는 소프트웨어 생명주기 단계 중에서 시간과 비용이 가장 많이 요구되는 단계이다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "구조적 분석 방법론의 구성 단계는?",
          "options": [
            "  1. 요구사항 분석, 구조적 분석, 구조적 설계, 구조적 프로그래밍",
            "  2. 요구사항 분석, 구조적 설계, 구조적 프로그래밍",
            "  3. 구조적 분석, 구조적 설계, 구조적 프로그래밍",
            "  4. 요구사항 분석, 구조적 분석"
          ],
          "answer": "1",
          "explanation": "구조적 분석 방법론의 구성 단계는 요구사항 분석, 구조적 분석, 구조적 설계, 구조적 프로그래밍이다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 설계에서 보안 요구사항을 명세하고 이에 따라 소프트웨어에 대한 보안을 설계하는 단계는?",
          "options": [
            "  1. 설계 단계",
            "  2. 구현 단계",
            "  3. 테스트 단계",
            "  4. 유지보수 단계"
          ],
          "answer": "1",
          "explanation": "소프트웨어 설계에서 보안 요구사항을 명세하고 이에 따라 소프트웨어에 대한 보안을 설계하는 단계는 설계 단계이다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 아키텍처의 종류 중 계층적으로 조직화할 수 있는 서비스로 구성된 애플리케이션에 적합한 것은?",
          "options": [
            "  1. 모듈화",
            "  2. 계층화",
            "  3. 객체지향",
            "  4. 서비스 지향"
          ],
          "answer": "2",
          "explanation": "계층화는 계층적으로 조직화할 수 있는 서비스로 구성된 애플리케이션에 적합하다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 생명주기 모형 중 폭포수 모형의 단점은?",
          "options": [
            "  1. 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 어려움",
            "  2. 사용자들이 모든 요구사항들을 명확하게 제시해야 함",
            "  3. 단계별 정의가 불분명하고, 전체 공조의 이해가 어려움",
            "  4. 모든 단계를 완료해야만 다음 단계로 넘어갈 수 있음"
          ],
          "answer": "1",
          "explanation": "폭포수 모형의 단점 중 하나는 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 어렵다는 것이다.",
          "subject": "소프트웨어설계"
        }
      ],
      "status": "SUCCESS"
    },
    "데이터베이스구축": {
      "requested_count": 10,
      "actual_count": 10,
      "questions": [
        {
          "question": "데이터베이스의 논리적 구조와 물리적 구조 간의 사상(매핑)을 정의하는 것은?",
          "options": [
            "  1. DDL",
            "  2. DML",
            "  3. DCL",
            "  4. TCL"
          ],
          "answer": "1",
          "explanation": "DDL은 데이터베이스의 논리적 구조와 물리적 구조를 정의하고, 이 둘 간의 사상을 정의하는 데 사용됩니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "데이터베이스의 무결성 제약 조건에 포함되지 않는 것은?",
          "options": [
            "  1. 개체 무결성",
            "  2. 참조 무결성",
            "  3. 도메인 무결성",
            "  4. 사용자 정의 무결성"
          ],
          "answer": "4",
          "explanation": "사용자 정의 무결성은 데이터베이스에서 지원하는 무결성 제약 조건은 아닙니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "DBMS의 주요 기능 중 하나가 아닌 것은?",
          "options": [
            "  1. 데이터 정의",
            "  2. 데이터 조작",
            "  3. 데이터 제어",
            "  4. 데이터 삭제"
          ],
          "answer": "4",
          "explanation": "데이터 삭제는 DML의 기능이지 DBMS의 주요 기능은 아닙니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "ALTER VIEW 문으로 변경이 불가능한 것은?",
          "options": [
            "  1. 뷰의 이름",
            "  2. 뷰의 정의",
            "  3. 뷰의 권한",
            "  4. 뷰의 데이터"
          ],
          "answer": "2",
          "explanation": "ALTER VIEW 문은 뷰의 정의를 변경하는 데 사용할 수 없습니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "관계 대수 연산 중 선택 연산(σ)의 기호로 사용되는 그리스 문자는?",
          "options": [
            "  1. π",
            "  2. σ",
            "  3. ∞",
            "  4. ⋈"
          ],
          "answer": "2",
          "explanation": "선택 연산은 그리스 문자 시그마(σ)를 사용합니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "데이터베이스 설계 단계 중 저장 레코드 양식 설계, 레코드 집중 분석 및 설계 접근 경로 설계와 관계되는 것은?",
          "options": [
            "  1. 요구 조건 분석",
            "  2. 개념적 설계",
            "  3. 논리적 설계",
            "  4. 물리적 설계"
          ],
          "answer": "4",
          "explanation": "물리적 설계 단계에서 저장 레코드 양식 설계, 레코드 집중 분석 및 설계 접근 경로 설계가 이루어집니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "릴레이션의 차수가 4이고 카디널리티가 5이며, 다른 릴레이션의 차수가 6이고 카디널리티가 7일 때 두 릴레이션의 카티션 프로덕트 결과로 생성되는 새로운 릴레이션의 차수와 카디널리티는?",
          "options": [
            "  1. 10, 35",
            "  2. 24, 35",
            "  3. 10, 12",
            "  4. 24, 12"
          ],
          "answer": "1",
          "explanation": "카티션 프로덕트의 결과로 생성되는 릴레이션의 차수는 두 릴레이션의 차수의 합이고, 카디널리티는 두 릴레이션의 카디널리티의 곱입니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "트랜잭션의 실행이 실패하였음을 알리고 트랜잭션이 수행한 결과를 원래 상태로 원상 복귀시키는 연산은?",
          "options": [
            "  1. COMMIT",
            "  2. BACKUP",
            "  3. LOG",
            "  4. ROLLBACK"
          ],
          "answer": "4",
          "explanation": "ROLLBACK 연산은 트랜잭션의 실행이 실패하였음을 알리고 원상 복귀시키는 데 사용됩니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "데이터베이스 전체를 정의한 것으로 데이터 개체 관계, 무결성 제약 조건 등을 포함하는 스키마는?",
          "options": [
            "  1. 개념 스키마",
            "  2. 내부 스키마",
            "  3. 외부 스키마",
            "  4. 내용 스키마"
          ],
          "answer": "1",
          "explanation": "개념 스키마는 데이터베이스 전체를 정의한 것으로 데이터 개체 관계, 무결성 제약 조건 등을 포함합니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "뷰의 정의를 변경하는 데 사용되는 SQL 문은?",
          "options": [
            "  1. CREATE VIEW",
            "  2. ALTER VIEW",
            "  3. DROP VIEW",
            "  4. SELECT VIEW"
          ],
          "answer": "2",
          "explanation": "ALTER VIEW 문을 사용하여 뷰의 정의를 변경할 수 있습니다.",
          "subject": "데이터베이스구축"
        }
      ],
      "status": "SUCCESS"
    },
    "프로그래밍언어활용": {
      "requested_count": 10,
      "actual_count": 10,
      "questions": [
        {
          "question": "Eclipse와 관련하여 하드웨어 환경과 관련이 없는 것은?",
          "options": [
            "  1. Oracle DB",
            "  2. WAS",
            "  3. 웹 서버",
            "  4. 에 대한 설명으로 옳지 않은 것은"
          ],
          "answer": "1",
          "explanation": "Eclipse는 소프트웨어 개발 환경으로, 데이터베이스나 WAS, 웹 서버와 관련이 있지만, Oracle DB와 직접적인 관련이 없다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "UNIX의 특징을 설명할 수 있다. UNIX에 대한 설명으로 옳지 않은 것은?",
          "options": [
            "  1. 사용자는 하나 이상의 작업을 백그라운드에서 수행할 수 있어",
            "  2. 여러 개의 작업을 병행 처리할 수 있다.",
            "  3. 쉘은 프로세스 관리, 기억장치 관리, 입출력 관리 등의 기능을 수행한다.",
            "  4. 두 사람 이상의 사용자가 동시에 시스템을 사용할 수 있어 정보와 유틸리티들을 공유하는 편리한 작업 환경을 제공한다."
          ],
          "answer": "2",
          "explanation": "UNIX는 멀티태스킹을 지원하여 여러 작업을 병행 처리할 수 있지만, 쉘은 프로세스 관리, 기억장치 관리, 입출력 관리 등의 기능을 수행하는 것은 아니다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "C 또는 Java의 printf에서 키보드의 Tab 키와 같이 커서를 일정 간격 띄어주는데 사용하는 제어문자는?",
          "options": [
            "  1. r",
            "  2. t",
            "  3. b",
            "  4. "
          ],
          "answer": "2",
          "explanation": "t는 탭 문자로서 커서를 일정 간격 띄어주는 데 사용된다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "다음 내용이 설명하는 결합도는?",
          "options": [
            "  1. 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이"
          ],
          "answer": "1",
          "explanation": "내용이 누락되었습니다. 적절한 내용을 추가해야 합니다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "객체 지향 소프트웨어 공학에서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것은?",
          "options": [
            "  1. 트랜잭션",
            "  2. 클래스",
            "  3. 시퀀스",
            "  4. 서브루틴"
          ],
          "answer": "2",
          "explanation": "클래스는 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것이다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 한다는 것은?",
          "options": [
            "  1. 유효성",
            "  2. 직관성",
            "  3. 무결성",
            "  4. 유연성"
          ],
          "answer": "2",
          "explanation": "직관성은 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙이다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "대표적으로 DOS, UNIX 등에서 조작을 위해 사용하던 것으로 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스는?",
          "options": [
            "  1. GUI",
            "  2. CLI",
            "  3. CUI",
            "  4. MUI"
          ],
          "answer": "2",
          "explanation": "CLI는 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스이다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "다음 중 애자일 소프트웨어 개발에 대한 설명으로 틀린 것은?",
          "options": [
            "  1. 공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.",
            "  2. 동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.",
            "  3. 계약 협상보다는 고객과의 협력을 가치 있게 여긴다.",
            "  4. 계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다."
          ],
          "answer": "2",
          "explanation": "애자일 소프트웨어 개발은 동작하는 소프트웨어를 더 가치 있게 여긴다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때 구조 패턴이 아닌 것은?",
          "options": [
            "  1. Adapter 패턴",
            "  2. Bridge 패턴",
            "  3. Builder 패턴",
            "  4. Proxy 패턴"
          ],
          "answer": "3",
          "explanation": "Builder 패턴은 생성 패턴에 속한다.",
          "subject": "프로그래밍언어활용"
        },
        {
          "question": "코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?",
          "options": [
            "  1. 연상 코드",
            "  2. 블록 코드",
            "  3. 순차 코드",
            "  4. 표의 숫자 코드"
          ],
          "answer": "3",
          "explanation": "순차 코드는 일정한 일련번호를 부여하는 방식의 코드이다.",
          "subject": "프로그래밍언어활용"
        }
      ],
      "status": "SUCCESS"
    }
  },
  "all_questions": [
    {
      "question": "소프트웨어 아키텍처의 정의로 가장 적절한 것은?",
      "options": [
        "  1. 소프트웨어의 내부 구조 및 동적 행위들을 정의하는 것",
        "  2. 소프트웨어의 외부 인터페이스를 정의하는 것",
        "  3. 소프트웨어의 성능을 최적화하는 것",
        "  4. 소프트웨어의 테스트 케이스를 작성하는 것"
      ],
      "answer": "1",
      "explanation": "소프트웨어 아키텍처는 소프트웨어의 내부 구조 및 동적 행위들을 정의하는 것이다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 설계에서 행위 모델링의 목적은?",
      "options": [
        "  1. 시스템의 기능적인 특성을 모델링하는 것",
        "  2. 시스템의 비기능적인 특성을 모델링하는 것",
        "  3. 시스템의 구조를 모델링하는 것",
        "  4. 시스템의 테스트 케이스를 작성하는 것"
      ],
      "answer": "1",
      "explanation": "행위 모델링은 시스템의 기능적인 특성을 모델링하는 것이다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 생명주기 모형 중 폭포수 모형의 특징은?",
      "options": [
        "  1. 각 단계가 끝난 후 결과물이 명확히 나와야 함",
        "  2. 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 쉬움",
        "  3. 사용자들이 모든 요구사항들을 명확하게 제시해야 함",
        "  4. 단계별 정의가 불분명하고, 전체 공조의 이해가 어려움"
      ],
      "answer": "1",
      "explanation": "폭포수 모형은 각 단계가 끝난 후 결과물이 명확히 나와야 한다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 설계에서 모듈 간의 계층적 구성을 나타낸 것은?",
      "options": [
        "  1. 구조도",
        "  2. 흐름도",
        "  3. 상태도",
        "  4. 계층도"
      ],
      "answer": "4",
      "explanation": "계층도는 모듈 간의 계층적 구성을 나타낸 것이다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 아키텍처의 장점 중 하나는?",
      "options": [
        "  1. 정보은닉의 원칙 적용",
        "  2. 높은 이식성을 가진다",
        "  3. 추가적인 실행 시 오버헤드가 발생한다",
        "  4. 시스템의 복잡성이 증가한다"
      ],
      "answer": "2",
      "explanation": "소프트웨어 아키텍처의 장점 중 하나는 높은 이식성을 가진다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 생명주기 단계 중에서 시간과 비용이 가장 많이 요구되는 단계는?",
      "options": [
        "  1. 정의 단계",
        "  2. 개발 단계",
        "  3. 유지보수 단계",
        "  4. 테스트 단계"
      ],
      "answer": "3",
      "explanation": "유지보수 단계는 소프트웨어 생명주기 단계 중에서 시간과 비용이 가장 많이 요구되는 단계이다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "구조적 분석 방법론의 구성 단계는?",
      "options": [
        "  1. 요구사항 분석, 구조적 분석, 구조적 설계, 구조적 프로그래밍",
        "  2. 요구사항 분석, 구조적 설계, 구조적 프로그래밍",
        "  3. 구조적 분석, 구조적 설계, 구조적 프로그래밍",
        "  4. 요구사항 분석, 구조적 분석"
      ],
      "answer": "1",
      "explanation": "구조적 분석 방법론의 구성 단계는 요구사항 분석, 구조적 분석, 구조적 설계, 구조적 프로그래밍이다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 설계에서 보안 요구사항을 명세하고 이에 따라 소프트웨어에 대한 보안을 설계하는 단계는?",
      "options": [
        "  1. 설계 단계",
        "  2. 구현 단계",
        "  3. 테스트 단계",
        "  4. 유지보수 단계"
      ],
      "answer": "1",
      "explanation": "소프트웨어 설계에서 보안 요구사항을 명세하고 이에 따라 소프트웨어에 대한 보안을 설계하는 단계는 설계 단계이다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 아키텍처의 종류 중 계층적으로 조직화할 수 있는 서비스로 구성된 애플리케이션에 적합한 것은?",
      "options": [
        "  1. 모듈화",
        "  2. 계층화",
        "  3. 객체지향",
        "  4. 서비스 지향"
      ],
      "answer": "2",
      "explanation": "계층화는 계층적으로 조직화할 수 있는 서비스로 구성된 애플리케이션에 적합하다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 생명주기 모형 중 폭포수 모형의 단점은?",
      "options": [
        "  1. 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 어려움",
        "  2. 사용자들이 모든 요구사항들을 명확하게 제시해야 함",
        "  3. 단계별 정의가 불분명하고, 전체 공조의 이해가 어려움",
        "  4. 모든 단계를 완료해야만 다음 단계로 넘어갈 수 있음"
      ],
      "answer": "1",
      "explanation": "폭포수 모형의 단점 중 하나는 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 어렵다는 것이다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "데이터베이스의 논리적 구조와 물리적 구조 간의 사상(매핑)을 정의하는 것은?",
      "options": [
        "  1. DDL",
        "  2. DML",
        "  3. DCL",
        "  4. TCL"
      ],
      "answer": "1",
      "explanation": "DDL은 데이터베이스의 논리적 구조와 물리적 구조를 정의하고, 이 둘 간의 사상을 정의하는 데 사용됩니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "데이터베이스의 무결성 제약 조건에 포함되지 않는 것은?",
      "options": [
        "  1. 개체 무결성",
        "  2. 참조 무결성",
        "  3. 도메인 무결성",
        "  4. 사용자 정의 무결성"
      ],
      "answer": "4",
      "explanation": "사용자 정의 무결성은 데이터베이스에서 지원하는 무결성 제약 조건은 아닙니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "DBMS의 주요 기능 중 하나가 아닌 것은?",
      "options": [
        "  1. 데이터 정의",
        "  2. 데이터 조작",
        "  3. 데이터 제어",
        "  4. 데이터 삭제"
      ],
      "answer": "4",
      "explanation": "데이터 삭제는 DML의 기능이지 DBMS의 주요 기능은 아닙니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "ALTER VIEW 문으로 변경이 불가능한 것은?",
      "options": [
        "  1. 뷰의 이름",
        "  2. 뷰의 정의",
        "  3. 뷰의 권한",
        "  4. 뷰의 데이터"
      ],
      "answer": "2",
      "explanation": "ALTER VIEW 문은 뷰의 정의를 변경하는 데 사용할 수 없습니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "관계 대수 연산 중 선택 연산(σ)의 기호로 사용되는 그리스 문자는?",
      "options": [
        "  1. π",
        "  2. σ",
        "  3. ∞",
        "  4. ⋈"
      ],
      "answer": "2",
      "explanation": "선택 연산은 그리스 문자 시그마(σ)를 사용합니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "데이터베이스 설계 단계 중 저장 레코드 양식 설계, 레코드 집중 분석 및 설계 접근 경로 설계와 관계되는 것은?",
      "options": [
        "  1. 요구 조건 분석",
        "  2. 개념적 설계",
        "  3. 논리적 설계",
        "  4. 물리적 설계"
      ],
      "answer": "4",
      "explanation": "물리적 설계 단계에서 저장 레코드 양식 설계, 레코드 집중 분석 및 설계 접근 경로 설계가 이루어집니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "릴레이션의 차수가 4이고 카디널리티가 5이며, 다른 릴레이션의 차수가 6이고 카디널리티가 7일 때 두 릴레이션의 카티션 프로덕트 결과로 생성되는 새로운 릴레이션의 차수와 카디널리티는?",
      "options": [
        "  1. 10, 35",
        "  2. 24, 35",
        "  3. 10, 12",
        "  4. 24, 12"
      ],
      "answer": "1",
      "explanation": "카티션 프로덕트의 결과로 생성되는 릴레이션의 차수는 두 릴레이션의 차수의 합이고, 카디널리티는 두 릴레이션의 카디널리티의 곱입니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "트랜잭션의 실행이 실패하였음을 알리고 트랜잭션이 수행한 결과를 원래 상태로 원상 복귀시키는 연산은?",
      "options": [
        "  1. COMMIT",
        "  2. BACKUP",
        "  3. LOG",
        "  4. ROLLBACK"
      ],
      "answer": "4",
      "explanation": "ROLLBACK 연산은 트랜잭션의 실행이 실패하였음을 알리고 원상 복귀시키는 데 사용됩니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "데이터베이스 전체를 정의한 것으로 데이터 개체 관계, 무결성 제약 조건 등을 포함하는 스키마는?",
      "options": [
        "  1. 개념 스키마",
        "  2. 내부 스키마",
        "  3. 외부 스키마",
        "  4. 내용 스키마"
      ],
      "answer": "1",
      "explanation": "개념 스키마는 데이터베이스 전체를 정의한 것으로 데이터 개체 관계, 무결성 제약 조건 등을 포함합니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "뷰의 정의를 변경하는 데 사용되는 SQL 문은?",
      "options": [
        "  1. CREATE VIEW",
        "  2. ALTER VIEW",
        "  3. DROP VIEW",
        "  4. SELECT VIEW"
      ],
      "answer": "2",
      "explanation": "ALTER VIEW 문을 사용하여 뷰의 정의를 변경할 수 있습니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "Eclipse와 관련하여 하드웨어 환경과 관련이 없는 것은?",
      "options": [
        "  1. Oracle DB",
        "  2. WAS",
        "  3. 웹 서버",
        "  4. 에 대한 설명으로 옳지 않은 것은"
      ],
      "answer": "1",
      "explanation": "Eclipse는 소프트웨어 개발 환경으로, 데이터베이스나 WAS, 웹 서버와 관련이 있지만, Oracle DB와 직접적인 관련이 없다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "UNIX의 특징을 설명할 수 있다. UNIX에 대한 설명으로 옳지 않은 것은?",
      "options": [
        "  1. 사용자는 하나 이상의 작업을 백그라운드에서 수행할 수 있어",
        "  2. 여러 개의 작업을 병행 처리할 수 있다.",
        "  3. 쉘은 프로세스 관리, 기억장치 관리, 입출력 관리 등의 기능을 수행한다.",
        "  4. 두 사람 이상의 사용자가 동시에 시스템을 사용할 수 있어 정보와 유틸리티들을 공유하는 편리한 작업 환경을 제공한다."
      ],
      "answer": "2",
      "explanation": "UNIX는 멀티태스킹을 지원하여 여러 작업을 병행 처리할 수 있지만, 쉘은 프로세스 관리, 기억장치 관리, 입출력 관리 등의 기능을 수행하는 것은 아니다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "C 또는 Java의 printf에서 키보드의 Tab 키와 같이 커서를 일정 간격 띄어주는데 사용하는 제어문자는?",
      "options": [
        "  1. r",
        "  2. t",
        "  3. b",
        "  4. "
      ],
      "answer": "2",
      "explanation": "t는 탭 문자로서 커서를 일정 간격 띄어주는 데 사용된다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "다음 내용이 설명하는 결합도는?",
      "options": [
        "  1. 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이"
      ],
      "answer": "1",
      "explanation": "내용이 누락되었습니다. 적절한 내용을 추가해야 합니다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "객체 지향 소프트웨어 공학에서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것은?",
      "options": [
        "  1. 트랜잭션",
        "  2. 클래스",
        "  3. 시퀀스",
        "  4. 서브루틴"
      ],
      "answer": "2",
      "explanation": "클래스는 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것이다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 한다는 것은?",
      "options": [
        "  1. 유효성",
        "  2. 직관성",
        "  3. 무결성",
        "  4. 유연성"
      ],
      "answer": "2",
      "explanation": "직관성은 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙이다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "대표적으로 DOS, UNIX 등에서 조작을 위해 사용하던 것으로 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스는?",
      "options": [
        "  1. GUI",
        "  2. CLI",
        "  3. CUI",
        "  4. MUI"
      ],
      "answer": "2",
      "explanation": "CLI는 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스이다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "다음 중 애자일 소프트웨어 개발에 대한 설명으로 틀린 것은?",
      "options": [
        "  1. 공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.",
        "  2. 동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.",
        "  3. 계약 협상보다는 고객과의 협력을 가치 있게 여긴다.",
        "  4. 계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다."
      ],
      "answer": "2",
      "explanation": "애자일 소프트웨어 개발은 동작하는 소프트웨어를 더 가치 있게 여긴다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때 구조 패턴이 아닌 것은?",
      "options": [
        "  1. Adapter 패턴",
        "  2. Bridge 패턴",
        "  3. Builder 패턴",
        "  4. Proxy 패턴"
      ],
      "answer": "3",
      "explanation": "Builder 패턴은 생성 패턴에 속한다.",
      "subject": "프로그래밍언어활용"
    },
    {
      "question": "코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?",
      "options": [
        "  1. 연상 코드",
        "  2. 블록 코드",
        "  3. 순차 코드",
        "  4. 표의 숫자 코드"
      ],
      "answer": "3",
      "explanation": "순차 코드는 일정한 일련번호를 부여하는 방식의 코드이다.",
      "subject": "프로그래밍언어활용"
    }
  ],
  "generation_summary": {
    "target_total": 30,
    "actual_total": 30,
    "success_rate": "100.0%",
    "successful_subjects": 3,
    "failed_subjects": 0,
    "completion_status": "COMPLETE",
    "generation_time": "5.1초"
  },
  "failed_subjects": [],
  "model_info": "Groq llama-4-scout-17b-16e-instruct",
  "parallel_agents": 2
}