id,question,options,gt_answer_idx,gen_answer_idx,gt_sub,gen_subject,gen_explanation,context
1,사용자 인터페이스 (UI) 중 명령과 출력이 텍스트 형태로만 이루어지 는 인터페이스를 무엇이라 하는가?,"[""NUI"", ""GUI"", ""CLI"", ""OUI""]",3,3,소프트웨어 설계,소프트웨어 설계,"이 문제에서는 사용자가 입력한 질문에 대한 답을 찾아야 합니다. 질문은 ""사용자 인터페이스 (UI) 중 명령과 출력이 텍스트 형태로만 이루어지는 인터페이스를 무엇이라 하는가?"" 입니다. 
보기에는 'NUI', 'GUI', 'CLI', 'OUI' 가 있습니다. 
이에 대한 해답을 찾기 위해 개념 요약을 참조하면, 
- CLI(Command Line Interface) : 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
- GUI(Graphical User Interface) : 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
- OUI(Organic User Interface) : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스로, 소프트웨어가 아닌 하드웨어 분야에서 사물 인터넷 등과 함께 대두되고 있음

이라는 정의를 찾을 수 있습니다. 
따라서 정답은 CLI(Command Line Interface) 즉, 보기 번호 3번입니다.

과목: 소프트웨어 설계","['다음 내용이 설명하는 접근 제어 모델은 ? ㆍ군대의 보안 레벨처럼 정보의 기밀성에 따라 상하 관계가 구분된 정보를 보호하기 위해 사용 ㆍ자신의 권한보다 낮은 보안 레벨 권한을 가진 경우에는 높은 보안 레벨의 문서를 읽을 수 없고 자신의 권한보 다 낮은 수준의 문서만 읽을 수 있다. ㆍ자신의 권한보다 높은 보안 레벨의 문서에는 쓰기가 가능하지만 보안 레벨이 낮은 문서의 쓰기 권한은 제한한다.\n\n[보기]\n1) Clark-Wilson Integrity Model\n2) PDCA Model\n3) Bell-Lapadula Model\n4) Chinese Wall Model', 'UNIX 시스템에서 파일의 권한 모드 설정에 관한 명령어는 ?\n\n[보기]\n1) cp\n2) chmod\n3) cat\n4) ls', 'User Interface 설계 시 오류 메시지나 경고에 관한 지침으로 가장 거리가 먼 것은?\n\n[보기]\n1) 메시지는 이해하기 쉬워야 한다.\n2) 오류로부터 회복을 위한 구체적인 설명이 제공되어야 한다.\n3) 오류로 인해 발생될 수 있는 부정적인 내용을 적극적으로 사용자에게 알려야 한다.\n4) 소리나 색의 사용을 줄이고 텍스트로만 전달하도록 한다.', 'User Interface 설계 시 오류 메시지나 경고에 관한 지침으로 가장 거리가 먼 것은?\n\n[보기]\n1) 메시지는 이해하기 쉬워야 한다.\n2) 오류로부터 회복을 위한 구체적인 설명이 제공되어야 한다.\n3) 오류로 인해 발생될 수 있는 부정적인 내용을 적극적으로 사용 자들에게 알려야 한다.\n4) 소리나 색의 사용을 줄이고 텍스트로만 전달하도록 한다.', 'DBA 가 사용자 PARK 에게 테이블 [STUDENT] 의 데이터를 갱신할 수 있는 시스템 권한을 부여하고자 하는 SQL 문을 작성하고자 한다 . 다음에 주어진 SQL 문의 빈칸을 알맞게 채운 것은 ? SQL ＞ GRANT ㉠ ㉡ STUDENT TO PARK;\n\n[보기]\n1) ㉠ INSERT, ㉡ INTO\n2) ㉠ ALTER, ㉡ TO\n3) ㉠ UPDATE, ㉡ ON\n4) ㉠ REPLACE, ㉡ IN', ""대표 화면 레이아웃 및 하위 기능을 정의하고 Tree 구조나 Flowchart 표기법을 \n이용한다. \n공통 적용이 가능한 UI 요소와 상호작용(Interaction)을 일반적인 규칙으로 정의한다. \n상호작용의 흐름 및 순서, 분기, 조건, 루프를 명시한다. \n예외 상황에 관한 사례를 정의하고 UI 시나리오 규칙을 지정한다. \n기능별 상세 기능 시나리오를 정의하되 UI 일반 규칙을 지킨다. \n시나리오 문서의 작성 요건 : 완전성, 일관성, 이해성, 가독성, 수정 용이성, 추적 용이성 \nUI 흐름 설계서 구성 \n \nUI 설계서 표지 : 프로젝트 이름, 시스템 이름을 포함하여 작성한다. \nUI 설계서 개정 이력 : 처음 작성 시 '초안 작성'을 포함한다. 초기 버전은 1.0 으로 \n설정하고 완성 시 버전은 x.0 으로 바꾸어 설정한다. \nUI 요구사항 정의 \n \n시스템 구조 : UI 프로토타입 재확인 후 UI 시스템 구조를 설계한다. \n사이트맵 : UI 시스템 구조를 사이트맵 구조로 설계한다. \n프로세스 정의 : 사용자 관점에서의 요구 프로세스 순서를 정리한다. \n화면 설계 : UI 프로세스/프로토타입을 고려하여 페이지 별로 화면을 구성 및 설계한다. \nUI 설계 도구 \nUI 설계에 도움을 주는 도구들 \n \n와이어 프레임(Wire Frame) : UI 중심의 화면 레이아웃을 선(Wire)을 이용하여 \n대략적으로 작성한다. \n목업(Mockup) : 실물과 흡사한 정적인 모형을 의미한다. \n프로토타입(Prototype) : Interaction(상호작용)이 결합하여 실제 작동하는 모형이다. \n스토리보드(Storyboard) : 정책, 프로세스, 와이어 프레임, 설명이 모두 포함된 설계 \n문서이다. \n와이어 프레임 \n \n기획 단계 초기에 작성하며, 구성할 화면의 대략적인 레이아웃이나 UI 요소 등의 틀을 \n설계하는 단계이다. \n개발 관계자(디자이너, 개발자, 기획자) 사이의 레이아웃 협의, 현재 진행 상황 등을 \n공유할 때 사용한다."", 'UI 표준 \nUI 구현 표준 \n \n전체 시스템 개발 중에 개발자 간 협업을 통하여 각기 개발한 화면 간에 갖추어야 할 \n최소한의 UI 요소 및 배치 규칙 등의 규칙을 의미한다. \nUI 에 공통으로 적용되어야 할 화면 구성, 화면 이동 등이 있다. \nUI 구현 지침 \n \n소프트웨어 개발 시 효율적인 정보 전달이 가능하도록 UI 설계에서 지켜야 할 세부 사항을 \n규정하는 것이다. \nUI 요구사항, 구현 제약 사항 등 UI 개발 과정에서 꼭 지켜야 할 공통 조건을 의미한다. \n한국형 웹 콘텐츠 접근성 지침 2.1 4 가지 원칙 \n \n인식의 용이성 : 대체 텍스트, 멀티미디어 대체 수단, 명료성 \n운용의 용이성 : 입력 장치 접근성, 충분한 시간 제공, 광(光) 과민성 발작 예방, 쉬운 \n내비게이션 \n이해의 용이성 : 가독성, 예측 가능성, 콘텐츠의 논리성, 입력 도움 \n견고성 : 문법 준수, 웹 애플리케이션 접근성 \nUX(User eXperience) \nUX 사용자 경험 \n \n사용자가 제품을 대상으로 직/간접적으로 사용하면서 느끼고 생각하게 되는 지각과 반응, \n행동 등 모든 경험을 의미한다. \nUI 는 사람과 시스템 간의 상호작용을 의미하지만, UX 는 제품과 서비스, 회사와 \n상호작용을 통해서 전체적인 느낌이나 경험을 말한다. \nUX 에 영향을 주는 요소 : 성능, 시간 \n모바일 사용자 UX 설계 시 고려사항(행정안전부 고시) \n \n시스템을 사용하는 대상, 환경, 목적, 빈도 등을 고려한다. \n사용자가 직관적으로 서비스 이용 방법을 파악할 수 있도록 한다. \n입력의 최소화, 자동 완성 기능을 제공한다. \n사용자의 입력 실수를 수정할 수 있도록 되돌림 기능을 제공한다. \n모바일 서비스의 특성에 적합한 디자인을 제공한다. \n10. UI 설계 \nUI 설계 단계 \nUI 설계 단계 \n \n문제 정의 : 시스템의 목적과 해결해야 할 문제를 정의한다. \n사용자 모델 정의 : 사용자 특성을 결정하고, 소프트웨어 작업 지식 정도에 따라 초보자, \n중급자, 숙련자로 구분한다.', '사용자 인터페이스의 구분- CLI(Command Line Interface) : 명령과 출력이 텍스트 형 태로 이뤄지는 인터페이스- GUI(Graphical User Interface) : 아이콘이나 메뉴를 마우 스로 선택하여 작업을 수행하는 그래픽 환경의 인터페 이스- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스- VUI(Voice User Interface) : 사람의 음성으로 기기를 조작 하는 인터페이스- OUI(Organic User Interface) : 모든 사물과 사용자 간의 상 호작용을 위한 인터페이스로, 소프트웨어가 아닌 하드 웨어 분야에서 사물 인터넷(Internet of Things), 가상 현실(Virtual Reality), 증강현실(Augmented Reality), 혼합현실(Mixed Reality) 등과 함께 대두되고 있음 2401', 'Command(명령) \n요청을 요청에 대한 모든 정보가 포함된 독립실행형 객체로 변환하는 행동 디자인 패턴. \n이 변환은 다양한 요청들이 있는 메서드들을 인수화 할 수 있도록 하며, 요청의 실행을 \n지연 또는 대기열에 넣을 수 있도록 하고, 또 실행 취소할 수 있는 작업을 지원할 수 \n있도록 함. \nInterpreter(해석자) \n단순한 언어를 해석할 때 유용한 패턴 \n간단한 언어의 문법을 정의하고 해석하는 패턴 \n언어가 주어지면 해당 표현을 사용하여 언어로 문장을 해석하는 인터프리터를 사용하여 \n문법 표현을 정의하는 방법 \nMemento(기록) \n메멘토 패턴은 객체를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴 \n오리지네이터, 케어테이커, 메멘토 등 3 개의 객체로 구현된다. \n오리지네이터: 내부 상태를 보유하고 있는 일부 객체 \nObserver(감시자) \n여러 객체에 자신이 관찰 중인 객체에 발생하는 모든 이벤트에 대해 알리는 구독 \n매커니즘을 정의할 수 있도록 하는 행동 디자인 패턴(관찰자) \nState(상태) \n객체의 내부 상태가 변경될 때 해당 객체가 그의 행동을 변경할 수 있도록 하는 행동 \n디자인 패턴. \n객체가 행동을 변경할 때 객체가 클래스를 변경한 것처럼 보일 수 있음 \nStrategy(전략) \n패턴은 알고리즘들의 패밀리를 정의하고, 각 패밀리를 별도의 클래스에 넣은 후 그들의 \n객체들을 상호교환할 수 있도록 하는 행동 디자인 패턴 \nVisitor(방문자) \n알고리즘들을 그들이 작동하는 객체들로부터 분리할 수 있도록 하는 행동 디자인 패턴 \nTemplate Method \n부모 클래스에서 알고리즘의 골격을 정의하지만, 해당 알고리즘의 구조를 변경하지 않고 \n자식 클래스들이 알고리즘의 특정 단계들을 오버라이드(재정의)할 수 있도록 하는 행동 \n디자인 패턴. \nMediator(중재자) \n객체 간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다. \nVirtual-Constructor 패턴이라고도 한다.', 'UI 요소- 체크 박스(Check Box) : 여러 개의 선택 상황에서 1개 이 상의 값을 선택할 수 있는 버튼임- 라디오 버튼(Radio Button) : 여러 항목 중 하나만 선택할 수 있는 버튼임- 텍스트 박스(Text Box) : 사용자가 데이터를 입력하고 수 정할 수 있는 상자임- 콤보 상자(Combo Box) : 이미 지정된 목록 상자에 내용 을 표시하여 선택하거나 새로 입력할 수 있는 상자임- 목록 상자(List Box) : 콤보 상자와 같이 목록을 표시하지 만 새로운 내용을 입력할 수 없는 상자임 2402']"
2,XP(eXtreme Programming) 에 대한 설명으로 옳지 않은 것은 ?,"[""릴리즈 기간을 짧게 반복하여 고객의 요구 변화에 빠르게 대응한다."", ""코 드들은 하나의 작업이 마무리될 때마다 지속적으로 통합한다."", ""테스트가 지속적으로 진행될 수 있도록 테스트 자동화 도구를 사용한다."", ""개발 책임자가 모든 책임을 가지므로 팀원들은 책임 없이 자유로운 개발이 가능하다.""]",4,4,소프트웨어 설계,소프트웨어 설계,"XP(eXtreme Programming)는 고객의 요구사항에 빠르게 대응하기 위해 개발 과정의 반복을 극대화하여 생산성을 향상시키는 방법론입니다. XP의 핵심 가치에는 소통, 단순성, 피드백, 용기, 존중이 있습니다. XP의 주요 실천 방법에는 Pair Programming, Collective Ownership, Test-Driven Development, Continuous Integration, Refactoring, Small Releases 등이 있습니다.

보기 4번 ""개발 책임자가 모든 책임을 가지므로 팀원들은 책임 없이 자유로운 개발이 가능하다.""는 XP의 원칙과 맞지 않습니다. XP는 팀원 간의 공동 책임과 적극적인 참여를 강조합니다. 따라서, 보기 4번이 옳지 않은 설명입니다.

과목: 소프트웨어 설계

XP(eXtreme Programming)는 소프트웨어 설계와 개발에 있어 중요한 방법론 중 하나로, 요구사항의 빠른 변화에 대응하고 고객의 참여를 극대화하여 소프트웨어 품질을 향상시키는 것을 목표로 합니다. 따라서, 이 문제는 소프트웨어 설계 과목과 관련이 있습니다.","['객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?\n\n[보기]\n1) Coad 와 Yourdon 방법\n2) Booch 방법\n3) Jacobson 방법\n4) Wirfs-Brocks 방법', '대표적으로 DOS 및 Unix 등의 운영체제에서 조작을 위해 사용하던 것으로, 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스(User Interface)는?\n\n[보기]\n1) GUI(Graphical User Interface)\n2) CLI(Command Line Interface)\n3) CUI(Cell User Interface)\n4) MUI(Mobile User Interface)', '대표적으로 DOS 및 Unix 등의 운영체제에서 조작을 위해 사용하던 것으로 , 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스 (User Interface) 는 ?\n\n[보기]\n1) GUI(Graphical User Interface)\n2) CLI(Command Line Interface)\n3) CUI(Cell User Interface)\n4) MUI(Mobile User Interface)', 'S/W 각 기능의 원시 코드 라인수의 비관치 , 낙관치 , 기대치를 측정하 여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?\n\n[보기]\n1) Effort Per Task 기법\n2) 전문가 감정 기법\n3) 델파이기법\n4) LOC 기법', '배치 프로그램의 자동 수행 주기 중 사용자가 특정 조건을 설정해 두고 해당 조건이 충족될 때만 수행되도록 하는 것은?\n\n[보기]\n1) 정기 배치\n2) 이벤트성 배치\n3) On-Demand 배치\n4) 사용자 배치', 'FDD(Feature Driven Development, 기능 중심 개발) \nCrystal \nASD(Adaptive Software Development, 적응형 소프트웨어 개발방법론) \nDAD(Disciplined Agile Delivery, 학습 애자일 배포) \nAgile 선언문 \n \n프로세스나 도구보다 개인과의 소통이 더 중요하다. \n완벽한 문서보다 실행되는 소프트웨어가 더 중요하다. \n계약 협상보다 고객과의 협업이 더 중요하다. \n계획을 따르는 것보다 변경에 대한 응답이 더 중요하다. \nXP(eXtreme Programming) \nXP(eXtreme Programming) \n \n1999 년 Kent Beck 이 제안하였으며, 개발 단계 중 요구사항이 시시각각 변동이 심한 \n경우 적합한 방법론이다. \n요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 한다. \n요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 \n적용하는 방식으로 예측성보다는 적응성에 더 높은 가치를 부여한 방법이다. \n고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법이다. \nXP 핵심 가치 \n \n소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향한다. \n단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다. \nFeedback : 소프트웨어 개발에서 변화는 불가피하다. 이러한 변화는 지속적 테스트와 \n통합, 반복적 결함 수정 등 빠르게 피드백한다. \n용기(Courage) : 고객 요구사항 변화에 능동적으로 대응한다. \n존중(Respect) : 개발 팀원 간의 상호 존중을 기본으로 한다. \nXP Process \n \n용어 \n설명 \nUser Story 일종의 요구사항으로 UML 의 유즈케이스와 같은 목적으로 생성되나, 형식이 \n없고 고객에 의해 작성된다는 것이 다르다. \nRelease Planning 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을', 'XP(eXtreme Programming) XP(eXtreme Programming)는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방 법이다.- XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.- 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반 영에 대한 가시성을 높인다.- XP의 5가지 가치 : 의사소통(Communication), 단 순성(Simplicity), 용기(Courage), 존중(Respect), 피드 백(Feedback) 23.5, 22.4, 20.9 2400', '(Practice) 다른 사람과 함께 프로그래밍을 수행함으 Pair Programming 로써 개발에 대한 책임을 공동으로 나눠 (짝 프로그래밍) 갖는 환경을 조성함 Collective Ownership 개발 코드에 대한 권한과 책임을 공동으 (공동 코드 소유) 로 소유함- 개발자가 실제 코드를 작성하기 전에 테 스트 케이스를 먼저 작성하므로 자신이 Test- Driven 무엇을 해야할지를 정확히 파악함 Development- 테스트가 지속적으로 진행될 수 있도록 (테스트 주도 개발) 자동화된 테스팅 도구(구조, 프레임워 크)를 사용함 개발에 참여하는 모든 구성원(고객 포함) Whole Team 들은 각자 자신의 역할이 있고 그 역할에 (전체 팀) 대한 책임을 가져야 함 Continuous 모듈 단위로 나눠서 개발된 코드들은 하 Integration 나의 작업이 마무리될 때마다 지속적으로 (계속적인 통합) 통합됨 Design Improvement 프로그램 기능의 변경 없이, 단순화, 유연 (디자인 개선) 또는 성 강화 등을 통해 시스템을 재구성함 Refactoring(리팩토링) Small Releases 릴리즈 기간을 짧게 반복함으로써 고객의 (소규모 릴리즈) 요구 변화에 신속히 대응할 수 있음 6 2400', 'Small Releases \n짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 \n한다. \nShared Understanding \nCoding Standards 소스 코드 작성 포맷과 규칙들을 \n표준화된 관례에 따라 작성한다. \nCollective Code Ownership \n시스템에 있는 소스 코드는 팀의 모든 프로그래머가 \n누구든지 언제라도 수정할 수 있다. \nSimple Design \n가능한 가장 간결한 디자인 상태를 유지한다. \nSystem Metaphor 최종적으로 개발되어야 할 시스템의 구조를 기술한다. \nProgrammer Welfare \nSustainable Pace 일주일에 40 시간 이상 작업 금지. 2 주 \n연속 오버타임을 금지한다. \n효과적인 프로젝트 관리를 위한 3 대 요소 \n \n사람(People) - 인적 자원 \n문제(Problem) - 문제 인식 \n프로세스(Process) - 작업 계획 \n4. SCRUM \nSCRUM \nSCRUM 개념과 특징 \n \n요구사항 변경에 신속하게 대처할 수 있는 반복적이고 점진적인 소규모 팀원 간 활발한 \n소통과 협동심이 필요한 팀 중심의 소프트웨어 개발 방법론이다. \n신속하게 반복적으로 실제 작동하는 소프트웨어를 제공한다. \n개발자들의 팀 구성과 각 구성원의 역할, 일정 결과물 및 그 외 규칙을 정하는 것을 \n말한다. \n기능 개선점에 우선순위를 부여하고, 개발 주기 동안 실제 동작 가능한 결과를 제공한다. \n개발 주기마다 적용된 기능이나 개선점의 리스트를 제공한다. \n커뮤니케이션을 위하여 팀은 개방된 공간에서 개발하고, 매일 15 분 정도 회의를 한다. \n팀원 스스로 팀을 구성해야 한다.(Self Organizing) \n개발 작업에 관한 모든 것을 팀원 스스로 해결해야 한다.(Cross Functional) \nSCRUM 기본 원리 \n \n기능 협업을 기준으로 배치된 팀은 스프린트 단위로 소프트웨어를 개발한다. \n스프린트는 고정된 30 일의 반복이며, 스프린트를 시행하는 작업은 고정된다.', '편집기, 컴파일러, 디버거 등의 다양한 도구를 하나의 인터페이스로 통합하여 제공한다. \n오류 체크를 시각화하여 확인 및 수정을 쉽도록 지원한다. \n컴파일에 필요한 외부 추가 기능을 연계하여 개발의 편의성을 높였다. \n종류 : 이클립스, 비주얼 스튜디오, XCode, 안드로이드 스튜디오, IDEA, VSC 등 \n빌드 자동화 도구 \n \n소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만든다. \n소프트웨어 개발자가 반복 작업해야 하는 코딩을 잘 짜여진 프로세스를 통해 자동으로 \n실행하여, 신뢰성 있는 결과물을 생산해 낼 수 있는 작업 방식 및 방법이다. \n소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 \n생성하는 프로그램이며, 지속해서 증가하는 라이브러리의 자동 추가 및 관리(전처리, \nPreprocessing)를 지원한다. \n최근에는 오픈소스인 Gradle 이 등장했으며, 구글이 안드로이드의 기본 빌드 시스템으로 \nGradle 을 선택하면서 사용자가 급증하였다. \n기능 : 코드 컴파일, 컴포넌트 패키징, 파일 조작, 개발 테스트 실행, 버전 관리 도구 \n통합, 문서 생성, 배포 기능, 코드 품질 분석 \n프로세스 : 컴파일 => 패키징 => 단위 테스트 => 정적 분석 => 리포팅 => 배포 => 최종 \n빌드 \n종류 : Gradle, Jenkins, Makefile, Ant, Maven 등 \nAnt \n아파치 소프트웨어 재단에서 개발. XML 기반 빌드 스크립트를 사용한다. \n정해진 규칙이 없고, 절차적이다.(명확한 빌드 절차 정의가 필요). \n생명주기를 갖지 않아 각 Target 에 대한 의존관계와 작업을 정의해 주어야 한다. \n유연성이 높으나 프로젝트가 복잡해지는 경우 Build 과정의 이해가 어려워진다. \nXML, Remote Repository 를 가져올 수 없고 스크립트의 재사용이 어렵다. \nMaven \n프로젝트에 필요한 모든 종속성(Dependency)을 리스트의 형태로 Maven 에 알려서']"
3,자료 흐름도 (Data Flow Diagram) 의 구성 요소로 옳은 것은 ?,"[""process, data flow, data store, comment"", ""process, data flow, data store, terminator"", ""data flow, data store, terminator, data dictionary"", ""process, data store, terminator, mini-spec""]",2,2,소프트웨어 설계,소프트웨어 설계,"자료 흐름도(DFD; Data Flow Diagram)는 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법입니다. 자료 흐름도에서는 자료의 흐름과 기능을 프로세스(Process), 자료 흐름(Data Flow), 자료 저장소(Data Store), 단말(Terminator)의 네 가지 기본 기호로 표시합니다. 

- 프로세스(Process): 자료를 변환시키는 시스템의 한 부분(처리 과정)을 나타냅니다. 원이나 둥근 사각형으로 표시하고 그 안에 프로세스 이름을 기입합니다.
- 자료 흐름(Data Flow): 자료의 이동(흐름)이나 연관관계를 나타냅니다. 화살표 위에 자료의 이름을 기입합니다.
- 자료 저장소(Data Store): 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타냅니다. 도형 안에 자료 저장소 이름을 기입합니다.
- 단말(Terminator): 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받습니다(정보의 생산자와 소비자). 도형 안에 이름을 기입합니다.

보기에서 comment와 data dictionary는 자료 흐름도의 구성 요소가 아니며, mini-spec은 세분화된 자료 흐름도에서 최하위 단계 프로세스의 처리 절차를 설명하는 것으로, 자료 흐름도의 기본 구성 요소는 아닙니다.

따라서, 옳은 구성 요소는 'process, data flow, data store, terminator'입니다.

과목: 소프트웨어 설계","['스키마의 종류 중 조직이나 기관의 총괄적 입장에서 본 데이터베이스의 전체적인 논리적 구조로서 , 모든 응용 프로그램이나 사용자들이필요로 하는 데이터를 종합한 조직 전체의 데이터베이스 구조를의미하는 것은?\n\n[보기]\n1) 관계 스키마\n2) 외부 스키마\n3) 내부 스키마\n4) 개념 스키마', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?\n\n[보기]\n1) Object\n2) Dynamic\n3) Function\n4) Static', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?\n\n[보기]\n1) Object\n2) Dynamic\n3) Function\n4) Static', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?\n\n[보기]\n1) Model\n2) Sheet\n3) Component\n4) Cell', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며 , 인터페이스를 통해서만 접근할 수 있는 것은?\n\n[보기]\n1) Model\n2) Sheet\n3) Component\n4) Cell', '자료 흐름도(DFD) 자료 흐름도(DFD; Data Flow Diagram)는 요구사항 분 석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트라고도 한다.- 자료 흐름도에서는 자료의 흐름과 기능을 프로세스 (Process), 자료 흐름(Flow), 자료 저장소(Data Store), 단말(Terminator)의 네 가지 기본 기호로 표시한다. 표기법 기 호 의 미 Yourdon/ Gane/ DeMacro Sarson- 자료를 변환시키는 시스템의 한 부분(처 리 과정)을 나타내며 처리, 기능, 변환, 버 프로세스 물품 확인 물품 확인 블이라고도 함 (Process)- 원이나 둥근 사각 형으로 표시하고 그 안에 프로세스 이름을 기입함- 자료의 이동(흐름) 이나 연관관계를 자료 흐름 물품 코드 나타냄 (Data Flow)- 화살표 위에 자료 의 이름을 기입함- 시스템에서의 자료 저장소(파일, 데이 자료 저장소 물품대장 물품대장 ID 터베이스)를 나타냄 (Data Store)- 도형 안에 자료 저 장소 이름을 기입함- 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지 고 출력 데이터를 단말 공장 (Terminator) 받음(정보의 생산자 와 소비자)- 도형 안에 이름을 기입함 9 2400', '일반적으로 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Overview \nDiagram), 세부적 다이어그램(Detail Diagram)으로 구성된다. \n구조도(가시적 도표, Visual Table of Contents), 개요, 도표(Index Diagram), \n상세 도표(Detail Diagram)로 구성된다. \n가시적 도표는 전체적인 기능과 흐름을 보여주는 구조이다. \n기능과 자료의 의존 관계를 동시에 표현할 수 있다. \n보기 쉽고 이해하기 쉬우며 유지보수가 쉽다. \n하향식 소프트웨어 개발을 위한 문서화 도구이다. \nV-모델 \n \n폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델이다. \n세부적인 프로세스로 구성되어 있어서 신뢰도 높은 시스템 개발에 효과적이다. \n개발 단계의 작업을 확인하기 위해 테스트 작업을 수행한다. \n생명주기 초반부터 테스트 작업을 지원한다. \n코드뿐만 아니라 요구사항과 설계 결과도 테스트할 수 있어야 한다. \n폭포수 모형보다 반복과 재처리 과정이 명확하다. \n테스트 작업을 단계별로 구분하므로 책임이 명확해진다. \n애자일(Agile) 개발 방법론 \n애자일(Agile) 개발방법론 \n \n날렵한, 재빠른 이란 사전적 의미가 있다. \n특정 방법론이 아닌 소프트웨어를 빠르고 낭비 없이 제작하기 위해 고객과의 협업에 초점을 \n두고 소프트웨어 개발 중 설계 변경에 신속히 대응하여 요구사항을 수용할 수 있다. \n절차와 도구보다 개인과 소통을 중요시하고 고객과의 피드백을 중요하게 생각한다. \n소프트웨어가 잘 실행되는데 가치를 두며, 소프트웨어 배포 시차를 최소화할 수 있다. \n특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 \n커뮤니케이션 변화 \n종류 \n익스트림 프로그래밍(XP, eXtreame Programming) \n스크럼(SCRUM) \n린(Lean) \nDSDM(Dynamic System Development Method, 동적 시스템 개발 방법론)', '구성 요소 \n의미 \n표기법 \n프로세스(Process) 자료를 변환시키는 시스템의 한 부분을 나타낸다. 원 안에 프로세스 \n이름 \n자료 흐름(Data Flow) \n자료의 이동(흐름)을 나타낸다. \n자료 이름 아래 ㅡ▶ \n자료 저장소(Data Store) 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타낸다.\n \n가로 수평선 사이 자료 저장소 이름 \n단말(Terminator) - 자료의 발생지와 종착지를 나타낸다. \n- 시스템의 외부에 존재하는 사람이나 조직체이다. \n직사각형 안에 단말 이름 \n소단위 명세서(Mini-Specification) \n \n세분화된 자료 흐름도에서 최하위 단계 프로세스의 처리 절차를 설명한 것이다. \n세분화된 자료 흐름도에서 최하위 단계 버블(프로세스)의 처리 절차를 기술한 것으로 \n프로세스 명세서라고도 한다. \n분석가의 문서이며, 자료 흐름도(DFD)를 지원하기 위하여 작성한다. \n서술 문장, 구조적 언어, 의사 결정 나무, 의사 결정 표(판단표), 그래프 등을 이용하여 \n기술한다. \n구조적 언어, 의사 결정 나무, 의사 결정표 \n \n구조적 언어 : 자연어 일부분으로 한정된 단어와 문형, 제한된 구조를 사용하여 명세서를 \n작성하는데 이용하는 명세 언어이다. \n의사 결정 나무 : 현재 상황과 목표와의 상호 관련성을 나무의 가지를 이용해 표현한 \n것으로 불확실한 상황에서의 의사결정을 위한 분석 방법이다. \n의사 결정표(Decision Table) : 복잡한 의사결정 논리를 기술하는데 사용하며, 주로 \n자료 처리 분야에서 이용된다. \n자료 사전(DD : Data Dictionary) \n \n시스템과 관련된 모든 자료의 명세와 자료 석성을 파악할 수 있도록 조직화한 도구이다. \n표기법 \n기호 \n의미 \n설명 \n= \n자료의 정의 ~로 구성되어 있다.(is compose of). \n+ \n자료의 연결 그리고(and, along with) \n( ) \n자료의 생략 생략 가능한 자료(optional)', '구조적 설계의 특징과 기본 구조 \n \n특징 : 하향식 기법, 신뢰성 향상, 유연성 제공, 재사용 용이 \n기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조 = 조건(Condition) 구조, \n반복(Repetition) 구조 \n구조적 분석 도구 \n자료 흐름도(DFD : Data Flow Diagram) \n \n시스템 내의 모든 자료 흐름을 4 가지의 기본 기호(처리, 자료 흐름, 자료 저장소, \n단말)로 기술하고 이런 자료 흐름을 중심으로 한 분석용 도구이다. \nDFD 의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시하고 구조적 분석 기법에 \n이용된다. \n시스템이나 프로그램 간의 총체적인 데이터 흐름을 표시할 수 있으며, 기본적인 데이터 \n요소와 그들 사이의 데이터 흐름 형태로 기술된다. \n다차원적이며 자료 흐름 그래프 또는 버블(Bubble) 차트라고도 한다. \n그림 중심의 표현이고 하향식 분할 원리를 적용한다. \n갱신하기 쉬워야 하며 이름의 중복을 제거하여 이름으로 정의를 쉽게 찾을 수 있도록 한다. \n정의하는 방식이 명확해야 한다. \n자료 흐름도(DFD) 작성 원칙 \n \n출력 자료 흐름은 입력 자료 흐름을 이용해 생성해야 한다. \n입력, 출력 자료 자체에 대해서만 인지하고 자료의 위치나 방향은 알 필요가 없다. \n자료 흐름 변환의 형태에는 본질 변환, 합성의 변환, 관점의 변환, 구성의 변환 등이 \n있다. \n자료 보존의 원칙 : 출력 자료 흐름은 반드시 입력 자료 흐름을 이용해 새엇ㅇ한다. \n최소 자료 입력의 원칙 : 출력 자료를 산출하는데 필요한 최소의 자료 흐름만 입력한다. \n독립성의 원칙 : 프로세스는 오직 자신의 입력 자료와 출력 자료 자체에 대해서만 알면 \n된다. \n지속성의 원칙 : 프로세스는 항상 수행하고 있어야 한다. \n순차 처리의 원칙 : 입력 자료 흐름의 순서는 출력되는 자료 흐름에서도 지키도록 한다. \n영구성의 원칙 : 자료 저장소의 자료는 입력으로 사용해도 삭제되지 않는다. \n데이터(자료) 흐름도', '자료 흐름도의 구성 요소 기호 표기법 프로세스(Process) 물품 확인 물품 코드 자료 흐름(Data Flow) 자료 저장소(Data Store) 물품대장 단말(Terminator) 공장']"
4,분산 시스템에서의 미들웨어 (Middleware) 와 관련한 설명으로 틀린 것은?,"[""분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는 소프트웨어로 볼 수 있다."", ""위치 투명성 (Location Transparency) 을 제공한다 ."", ""분산 시스템의 여러 컴포넌트가 요구하는 재사용 가능한 서비스의 구현을 제공한다."", ""애플리케이션과 사용자 사이에서만 분산 서비스를 제공한다.""]",4,4,소프트웨어 설계,소프트웨어 설계,"미들웨어(Middleware)는 분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는 소프트웨어로 볼 수 있다. 미들웨어는 위치 투명성(Location Transparency)을 제공하며, 분산 시스템의 여러 컴포넌트가 요구하는 재사용 가능한 서비스의 구현을 제공한다. 하지만 미들웨어는 애플리케이션과 사용자 사이에서만 분산 서비스를 제공하는 것이 아니라, 운영체제와 응용 프로그램 사이에서 다양한 서비스를 제공하고, 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다. 따라서 보기 4번 '애플리케이션과 사용자 사이에서만 분산 서비스를 제공한다.'는 미들웨어에 대한 설명으로 틀린 것이다.

과목: 소프트웨어 설계","['다음 내용이 설명하는 스토리지 시스템은 ? ㆍ하드디스크와 같은 데이터 저장장치를 호스트버스 어댑 터에 직접 연결하는 방식 ㆍ저장장치와 호스트 기기 사이에 네트워크 디바이스가 있지 말아야 하고 직접 연결하는 방식으로 구성\n\n[보기]\n1) DAS\n2) NAS\n3) N-SCREEN\n4) NFC', '정규화된 엔티티 , 속성 , 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복 , 통합 , 분리 등을 수행하는 데이터 모델링 기법 은?\n\n[보기]\n1) 정규화\n2) 반정규화\n3) 집단화\n4) 머징', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?\n\n[보기]\n1) 합성 중심\n2) 생성 중심\n3) 분리 중심\n4) 구조 중심', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?\n\n[보기]\n1) 합성 중심\n2) 생성 중심\n3) 분리 중심\n4) 구조 중심', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?\n\n[보기]\n1) 합성 중심\n2) 생성 중심\n3) 분리 중심\n4) 구조 중심', '미들웨어(Middleware) 미들웨어는 미들(Middle)과 소프트웨어(Software)의 합 성어로, 운영체제와 응용 프로그램, 또는 서버와 클라 이언트 사이에서 다양한 서비스를 제공하는 소프트웨어 이다.- DB는 데이터베이스 벤더에서 제공하는 클라 이언트에서 원격의 데이터베이스와 연결하기 DB 위한 미들웨어 (DataBase)- DB를 사용하여 시스템을 구축하는 경우 보통 2- Tier 아키텍처라고 함 RPC(원격 프로시저 호출)는 응용 프로그램의 프 RPC (Remote 로시저를 사용하여 원격 프로시저를 마치 로컬 Procedure Call) 프로시저처럼 호출하는 방식의 미들웨어- MOM(메시지 지향 미들웨어)은 메시지 기반의 MOM 비동기형 메시지를 전달하는 방식의 미들웨어 (Message Oriented- 온라인 업무보다는 이기종 분산 데이터 시스 Middleware) 템의 데이터 동기를 위해 많이 사용됨- TP- Monitor(트랜잭션 처리 모니터)는 항공기 나 철도 예약 업무 등과 같은 온라인 트랜잭션 TP- Monitor 업무에서 트랜잭션을 처리 및 감시하는 미들 (Transaction Processing 웨어 Monitor)- 사용자 수가 증가해도 빠른 응답 속도를 유지 해야 하는 업무에 주로 사용됨- ORB(객체 요청 브로커)는 객체 지향 미들웨어 ORB(Object 로 코바(CORBA) 표준 스펙을 구현한 미들웨어 Request- 최근에는 TP- Monitor의 장점인 트랜잭션 처리 Broker) 와 모니터링 등을 추가로 구현한 제품도 있음- WAS(웹 애플리케이션 서버)는 정적인 콘텐츠 를 처리하는 웹 서버와 달리 사용자의 요구에 WAS(Web 따라 변하는 동적인 콘텐츠를 처리하기 위해 Application 사용되는 미들웨어 Server)- 클라이언트/서버 환경보다는 웹 환경을 구현 하기 위한 미들웨어 정보처리기사 필기 요약', '분산 데이터베이스- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site) 에 분산되어 있는 데이터베이스를 말한다.- 데이터베이스 설계 및 소프트웨어 개발이 어렵다.- 분산 데이터베이스의 구성 요소 : 분산 처리기, 분산 데이 터베이스, 통신 네트워크', '분산 데이터베이스- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site) 에 분산되어 있는 데이터베이스를 말한다.- 데이터베이스 설계 및 소프트웨어 개발이 어렵다.- 분산 데이터베이스의 구성 요소 : 분산 처리기, 분산 데이 터베이스, 통신 네트워크', '미들웨어(Middleware)- 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다.- 운영체제와 응용 프로그램 사이에서 다양한 서비스를 제공한다.- 위치 투명성을 제공한다.- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용 소프트웨어를 사용해야 한다. 8', '미들웨어(Middleware)- 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다.- 운영체제와 응용 프로그램 사이에서 다양한 서비스를 제공한다.- 위치 투명성을 제공한다.- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용 소프트웨어를 사용해야 한다. 8']"
5,디자인 패턴 사용의 장٠단점에 대한 설명으로 거리가 먼 것은?,"[""소프트웨어 구조 파악이 용이하다."", ""객체지향 설계 및 구현의 생산성을 높이는데 적합하다."", ""재사용을 위한 개발 시간이 단축된다."", ""절차형 언어와 함께 이용될 때 효율이 극대화된다.""]",4,4,소프트웨어 설계,소프트웨어 설계,"디자인 패턴 사용의 장단점에 대한 설명으로 거리가 먼 것은 절차형 언어와 함께 이용될 때 효율이 극대화된다. 입니다. 
디자인 패턴의 장점에는 개발자 간의 원활한 의사소통을 지원, 소프트웨어 구조 파악이 용이, 재사용을 통한 개발 시간 단축, 설계 변경 요청에 대한 유연한 대처, 객체지향 설계 및 구현의 생산성 향상 등이 있습니다. 
하지만 디자인 패턴은 객체지향 설계/구현 위주로 사용되며, 절차형 언어와 함께 이용될 때 효율이 극대화된다는 내용은 디자인 패턴의 특징과 관련이 없습니다. 
따라서 절차형 언어와 함께 이용될 때 효율이 극대화된다는 설명은 디자인 패턴 사용의 장단점과 관련이 없으므로 정답은 4번입니다.

과목: 소프트웨어 설계","['다음 중 애자일(Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은?\n\n[보기]\n1) 공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.\n2) 동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.\n3) 계약 협상보다는 고객과의 협력을 가치 있게 여긴다.\n4) 계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다.', '다음 중 애자일 (Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은 ?\n\n[보기]\n1) 공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.\n2) 동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.\n3) 계약 협상보다는 고객과의 협력을 가치 있게 여긴다.\n4) 계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다.', 'UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?\n\n[보기]\n1) Feedback\n2) Posture\n3) Module\n4) Hash', '동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?\n\n[보기]\n1) RCS(Revision Control System)\n2) RTS(Reliable Transfer Service)\n3) RPC(Remote Procedure Call)\n4) RVS(Relative Version System)', '소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.\n2) 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.\n3) 관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.\n4) 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.', '디자인 패턴 사용의 장·단점- 범용적인 코딩 스타일로 인해 구조 파악이 용이하다.- 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.- 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약 된다.- 초기 투자 비용이 부담될 수 있다.- 개발자 간의 원활한 의사소통이 가능하다.- 설계 변경 요청에 대한 유연한 대처가 가능하다.- 객체지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않다. 23.7, 23.5, 23.2, 22.7, 22.3, 21.8, 21.5, 21.3, 20.8 2402', '자주 사용하는 설계 형태를 정형화하여 유형별로 설계 템플릿을 만들어 두고 소프트웨어 \n개발 중 나타나는 과제를 해결하기 위한 방법 중 한 가지다. \n다양한 응용 소프트웨어 시스템들을 개발할 때 서로 간에 공통점이 있으며, 이러한 \n유사점을 패턴이라 한다. \n개발자 간 원활한 의사소통, 소프트웨어 구조 파악 용이, 설계 변경에 대한 유연한 대처, \n개발의 효율성, 유지보수성, 운용성 등 소프트웨어 품질 향상에 도움을 준다. \n객체지향 프로그래밍 설계 시 유사한 상황에서 구조적인 문제를 해결할 수 있도록 방안을 \n제공해주며, Gof(Gang of Four) 분류가 가장 많이 사용된다. \n디자인 패턴을 사용할 때의 장/단점 \n \n장점 \n \n개발자 간의 월활한 의사소통을 지원한다. \n소프트웨어 구조 파악이 쉽다. \n재사용을 통한 개발 시간을 단축할 수 있다. \n설계 변경 요청에 대해 유연하게 대처할 수 있다. \n객체지향 설계 및 구현의 생산성을 높이는 데 적합하다. \n단점 \n \n객체지향 설계/구현 위주로 사용된다. \n초기 투자 비용이 부담된다. \n디자인 패턴의 구성 요소 \n \n필수 요소 \n \n패턴의 이름 : 패턴을 부를 때 사용하는 이름과 패턴의 유형 \n문제 및 배경 : 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미 \n해법 : 패턴을 이루는 요소들, 관계, 협동(Collaboration) 과정 \n결과 : 패턴을 사용하면 얻게 되는 이점이나 영향 \n추가 요소 \n \n알려진 사례 : 간단한 적용 사례 \n샘플 코드 : 패턴이 적용된 원시 코드 \n원리, 정당성, 근거 \nGoF(Gangs of Four) 디자인 패턴 \n \n에릭 감마, 리처드 헬름, 랄프 존슨, 존 브리시데스가 제안 \n객체지향 설계 단계 중 재사용에 관한 유용한 설계를 디자인 패턴화하였다. \n생성 패턴, 구조 패턴, 행위 패턴으로 분류한다. \n생성 패턴 \n \n객체를 생성하는 것과 관련된 패턴이다. \n객체의 생성과 변경이 전체 시스템에 미치는 영향은 최소화하도록 만들어주어 유연성을', '객체 간의 혼란스러운 의존 관계들을 줄일 수 있는 행동 디자인 패턴 \n패턴은 객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 협력하도록 함. \n디자인 패턴 vs 아키텍처 패턴 \n \n아키텍처 패턴이 상위 설계에 이용된다. \n아키텍쳐 패턴 : 시스템 전체 구조를 설계하기 위한 참조 \n디자인 패턴 : 서브 시스템 내 컴포넌트와 그들 간의 관계를 구성하기 위한 참조 모델 \n17. 인터페이스 요구사항 확인 \n인터페이스 요구사항 \n인터페이스 내/외부 요구사항 \n \n개발 대상 조직 내/외부의 시스템 연동을 통하여 상호작용을 위한 접속 방법, 규칙을 \n의미한다. \n인터페이스 요구사항 구성 \n \n요구사항의 구성, 내/외부 인터페이스 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 \n방식, 송신 데이터, 인터페이스 주기, 기타 고려사항 \n인터페이스 요구사항의 분류 \n \n기능적 요구사항 : 소프트웨어가 내/외부 시스템 간의 연계를 통하여 수행될 기능과 \n관련하여 가져야 하는 기능적 속성에 대한 요구사항이다. \n비기능적 요구사항 : 기능에 관련되지 않는 사항으로 기능 요구사항을 만족시키는 바탕에서 \n정상적으로 작동하기 위한 시스템 내/외부의 제약 조건을 의미한다. \n인터페이스 요구사항 명세서 \n \n예시 \n \n요구사항 분류 시스템 인터페이스 요구사항 \n요구사항 번호 AAA-MOCK001 \n요구사항 명칭 소셜로그인 연동 \n요구사항 상세 설명 정의 \n네이버 아이디로 회원 연동 \n세부 내용 \n- 네이버 아이디 서비스인 네아로 API 를 이용하여 MOCK 사이트 회원 가입에 \n활용할 수 있도록 한다. \n- MOCK 사이트 네아로 서비스 아이디가 네이버에 전달되고, API 를 통하여 회원 정보를 \n가져온다. \n- 예상 트랜잭션 : 일 1,000 건 \n<추가 정의 내용> \n- 네이버 회원 정보 중 이름, 닉네임, 이메일, 전화번호를 가져온다. \n- 네아로 서비스를 통하여 회원 가입할 때 회원 아이디를 ""NAVER_""로 시작하도록 하여 \n구분한다. \n산출 정보', '특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용된다. \n주로 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 \n방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다. \n15. 객체지향 설계 \n구조적, 절차적 프로그래밍과 객체지향 \n구조적 프로그래밍(Structured Programming) \n \n프로그램의 이해가 쉽고 디버깅 작업이 쉽다. \n한 개의 입구(입력)와 한 개의 출구(출력) 구조를 갖도록 한다. \nGOTO(분기) 문은 사용하지 않는다. \n구조적 프로그래밍의 기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조, \n반복(Iteration) 구조 \n절차적 프로그래밍(Procedural Programming) \n \n순서대로 일련의 명령어를 나열하여 프로그래밍한다. \nFunction 기반의 프로그래밍이며, 프로시저로써 Function 외에도 Subroutine 이 \n문법적으로 구현되어 있다. \n절차형 언어의 경우 규모가 커지면 커질수록 함수가 기하급수적으로 늘어난다. \n함수가 타 프로그램과 문제를 일으킬 수 있는 문제점을 가지고 있다. \n프로그램과 별개로 데이터 취급이 되므로 완전하지 않고 현실 세계 문제를 프로그램으로 \n표현하는데 제약이 있다. \n객체지향 프로그래밍(Object Oriented Programming) \n \n컴퓨터 소프트웨어를 구조적인 코드 단위로 보는 것이 아니라 Object 단위로 구분하고 \nObject 간의 모음으로 설계하는 것이다. \n소프트웨어 내의 Object 는 서로 Message 를 주고받는다. \n처리 요구를 받은 객체가 자기 자신 안에 있는 내용을 가지고 처리하는 방식이다. \n프로그램이 단순화되고 생산성, 신뢰성이 높아져 대규모 개발에 많이 사용된다. \n객체지향 구성 요소 \n \n구분 \n설명 \nClass - 유사한 객체를 정의한 집합으로 속성+행위를 정의한 것으로 일반적인 Type 을 \n의미한다.', '소프트웨어의 유지보수성 향상이 최우선 \n복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거 \n재사용을 수월하게 하며 소프트웨어의 수명을 연장하기 위함. \n과정 \n \n분석(Analysis) => 구성(Restructuring) => 역공학(Reverse Engineering) => \n이식(Migration) \n역공학 \n역공학의 개념 \n \n소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 \n정보를 재발견하거나 다시 만들어내는 작업이다. \n역공학의 가장 간단하고 오래된 형태는 재문서화라고 할 수 있다. \nCASE(Computer Aided Software Engineering) \nCASE \n \n소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 \n컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업이다. \n자료 흐름도 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어 CASE 도구이다. \n작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대한다. \nCASE 가 제공하는 기능 \n \n개발을 신속하게 할 수 있고, 오류 수정이 쉬워 소프트웨어 품질이 향상된다. \n소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화시켜 주는 통합된 도구를 \n제공해주는 기술이다. \n소프트웨어 시스템의 문서화 및 명세화를 위한 그래픽 기능을 제공한다. \n소프트웨어 개발 단계의 표준화를 기할 수 있으며, 자료 흐름도 작성 기능을 제공한다. \n모델들 사이의 모순 검사 기능을 제공하며 다양한 소프트웨어 개발 모형을 지원한다. \n원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술 \nCASE 사용의 장점 \n \n소프트웨어 개발 기간 단축 및 개발 비용을 절약하여 소프트웨어 생산성을 향상시킨다. \n자동화된 검사를 통해 소프트웨어 품질이 향상된다. \n프로그램의 유지보수가 간편해지고 소프트웨어 모듈의 재사용성이 향상된다.']"
6,UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?,"[""UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?"", ""<< >>"", ""(( ))"", ""{{ }}"", ""[[ ]]""]",1,2,소프트웨어 설계,소프트웨어 설계,"UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호는 << >>입니다. 이는 길러멧(Guillemet)이라고 부르는 겹화살괄호로, 스테레오 타입을 표현할 때 사용됩니다. 예를 들어, <<include>>, <<extend>>, <<interface>>, <<exception>>, <<constructor>> 등이 있습니다.
과목: 소프트웨어 설계","['UML 에서 활용되는 다이어그램의 이름과 설명의 연결이 올바르지 않은 것은?\n\n[보기]\n1) 클래스 다이어그램 : 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데 , 메시지뿐만 아니라 객체들 간의 연관까지 표현한다.\n2) 배치 다이어그램 : 결과물 , 프로세스 , 컴포넌트 등 물리적 요소들의 위치를 표현한다.\n3) 유스케이스 다이어그램 : 사용자의 요구를 분석하는 것으로 , 기능 모델링 작업에 사용한다.\n4) 활동 다이어그램 : 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다.', 'UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?\n\n[보기]\n1) Feedback\n2) Posture\n3) Module\n4) Hash', '공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해되고 한 가지로 해석될 수 있도록 작성하는 원칙은?\n\n[보기]\n1) 상호작용성\n2) 명확성\n3) 독립성\n4) 내용성', '데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?\n\n[보기]\n1) Relation\n2) Data Structure\n3) Constraint\n4) Operation', '데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?\n\n[보기]\n1) Relation\n2) Data Structure\n3) Constraint\n4) Operation', '- 다양한 관점에서 의사소통할 수 있도록 View 를 제공한다. \n- 정적 모델 : 구조 다이어그램 \n- 동적 모델 : 행위 다이어그램 \n스테레토 타입 \n \nUML 에서 제공하는 기본 요소 외에 추가적인 확장 요소를 표현할 때 사용한다. \nUML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호는 쌍 꺾쇠와 비슷하게 \n생긴 길러멧(Guillemet) <<>>이며, 길러멧 안에 확장 요소를 적는다. \nUML 접근 제어자 \n \n접근제어자 \n표기 \n설명 \nPublice \n+ \n어떤 클래스의 객체에서든 접근 가능하다. \nPrivate \n- \n해당 클래스로 생성된 객체만 접근 가능하다. \nProtected \n# \n해당 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 \n객체들만 접근 가능하다. \nPackage \n~ \n동일 패키지에 있는 클래스의 객체들만 접근 가능하다. \n연관 관계 다중성 표현 \n \n표기 \n의미 \n1 \n1 개체 연결 \n* 또는 0..* 0 이거나 그 이상 객체 연결 \n1..* 1 이거나 1 이상 객체 연결 \n0..1 0 이거나 1 객체 연결 \n1,3,6 1 이거나 3 이거나 6 객체 연결 \nn \nn 개 객체 연결 \nn..* n 이거나 n 개 이상 객체 연결 \nUML 다이어그램의 분류 \n구조적 다이어그램(Structure Diagram) \n \n정적이고, 구조 표현을 위한 다이어그램이다. \n다이어그램 유형 \n목적 \n클래스 다이어그램(ClassDiagram) 시스템 내 클래스의 정적 구조를 표현하고 시스템을 \n구성하는 클래스들 사이의 관계를 표현한다. \n객체 다이어그램(Object Diagram) \n객체 정보를 보여준다. \n복합체 구조 다이어그램(Composite Structure Diagram) \n복합 구조의 클래스와 \n컴포넌트 내부 구조를 표현한다. \n배치 다이어그램(Deployment Diagram) 소프트웨어, 하드웨어, 네트워크를 포함한 실행 \n시스템의 물리 구조를 표현한다.', '스테레오 타입(Stereotype) 스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가 적인 기능을 표현하기 위해 사용한다.- 길러멧(Guilemet)이라고 부르는 겹화살괄호(<< >>) 사 이에 표현할 형태를 기술한다.- 주로 표현되는 형태는 다음과 같다. 연결된 다른 UML 요소에 대해 포함 관계에 있는 <<include>> 경우 연결된 다른 UML 요소에 대해 확장 관계에 있는 <<extend>> 경우 <<interface>> 인터페이스를 정의하는 경우 <<exception>> 예외를 정의하는 경우 <<constructor>> 생성자 역할을 수행하는 경우 정보처리기사 필기 요약 23.7, 23.5, 22.4, 21.5, 21.3 2401', '- 기본적인 사용자 정의 데이터형이며, 데이터를 추상화하는 단위이다. \n- 구조적 기법에서의 단위 테스트(Unit Test)와 같은 개념이다. \n- 상위 클래스(부모 클래스, Super Class), 하위 클래스(자식 클래스, Sub Class)로 \n나뉜다. \nObject \n- 데이터와 함수를 묶어 캡슐화하는 대상이 된다. \n- Class 에 속한 Instance 를 Object 라고 한다. \n- 하나의 소프트웨어 모듈로서 목적, 대상을 표현한다. \n- 같은 클래스에 속한 각각의 객체를 instance 라고 한다. \nMessage \nObject 간에 서로 주고받는 통신을 의미한다. \nAttribute : Object 가 가지고 있는 데이터 값 \nMethod : Object 의 행위인 함수 \nClass = 틀 = Type \n객체지향의 특징(캡상다추정) \n캡슐화 \n(Encapsulation) 상속성 \n(Inheritance) \n다형성 \n(Polymorphism) \n추상화 \n(Abstraction) \n정보은닉 \n(Information Hiding) \n- 서로 관련성이 높은 데이터(속성)와 그와 관련된 기능(메서드, 함수)을 묶는 기법이다. \n- 결합도가 낮아져 소프트웨어 개발에 있어 재사용성이 높아진다. \n- 정보은닉을 통하여 타 객체와 메시지 교환 시 인터페이스가 단순해진다. \n- 변경 발생 시 오류의 파급 효과가 적다. - 상위 클래스의 모든 속성, 연산을 하위 \n클래스가 재정의 없이 물려받아 사용하는 것이다. \n- 상위 클래스는 추상적 성질을, 자식 클래스는 구체적 성질을 가진다. \n- 하위 클래스는 상속받은 속성과 연산에 새로운 속성과 연산을 추가하여 사용할 수 있다. \n- 다중 상속 : 다수 상위 클래스에서 속성과 연산을 물려받는 것이다. - 객체가 다양한 \n모양을 가지는 성질을 뜻한다. \n- 오퍼레이션이나 속성의 이름이 하나 이상의 클래스에서 정의되고 각 클래스에서 다른 \n형태로 구현될 수 있는 개념이다.', '배열 배열의 개념 배열은 동일한 데이터 유형을 여러 개 사용해야 할 경우 이를 손쉽게 처리하기 위해 여러 개의 변수들을 조합해서 하나의 이름으로 정의해 사용하는 것을 말한다.- 배열은 하나의 이름으로 여러 기억장소를 가리키기 때 문에 배열에서 개별적인 요소들의 위치는 첨자를 이용 하여 지정한다.- 배열은 변수명 뒤에 대괄호 [ ]를 붙이고 그 안에 사용 할 개수를 지정한다.- C언어에서 배열의 위치는 0부터 시작된다.- 배열은 행 우선으로 데이터가 기억장소에 할당된다. 정보처리기사 필기 요약- C 언어에서 배열 위치를 나타내는 첨자 없이 배열 이 름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같다. 1차원 배열- 1차원 배열은 변수들을 일직선상의 개념으로 조합한 배 열이다.- 형식- 자료형 : 배열에 저장할 자료의 형을 지정함- 변수명 : 사용할 배열의 이름으로 사용자가 임 자료형 변수명 의로 지정함 [개수];- 개수 : 배열의 크기를 지정하는 것으로 생략할 수 있음 \ue355 int a[5] : 5개의 요소를 갖는 정수형 배열 a 첫 번째 두 번째 세 번째 네 번째 다섯 번째 배열 a a[0] a[1] a[2] a[3] a[4] ※ a[3] : a는 배열의 이름이고, 3은 첨자로서 배열 a에서 의 위치를 나타냄. a[3]에 4를 저장시키려면 ‘a[3] = 4’ 와 같이 작성함 1차원 배열 a의 각 요소에 10, 11, 12, 13, 14를 저 예제 1 장한 후 출력하기 #include <stdio.h> main( ) { int a[5]; 5개의 요소를 갖는 정수형 배열 a를 선언한다. 선언할 때는 사용할 개수를 선언하고, 사용할 때는 첨자를 0부터 사용하 \x08 므로 주의해야 한다. 첫 번째 두 번째 세 번째 네 번째다섯 번째 \x08 배열 a a[0] a[1] a[2] a[3] a[4] \x08 int i; 정수형 변수 i를 선언한다 for (i = 0; i < 5; i++) 반복 변수 i가 0에서 시작하여 1씩 증가하면서 5보다 작은 동 안 ❶번 문장을 반복하여 수행한다. 그러니까 ❶번 문장을 5 \x08 회 반복하는 것이다. a[i] = i + 10; ❶ 배열 a의 i번째에 i+10을 저장시킨다. i는 0~4까지 변하므로 \x08 배열 a에 저장된 값은 다음과 같다. 배열 a 10 11 12 13 14 \x08 a[0] a[1] a[2] a[3] a[4] for (i = 0; i < 5; i++) 반복 변수 i가 0에서 시작하여 1씩 증가하면서 5보다 작은 동 \x08 안 ❷번 문장을 반복하여 수행한다. printf(“%d “, a[i]); ❷ 배열 a의 i번째를 출력한다. i는 0~4까지 변하므로 출력 결과 \\ 는 다음과 같다. 서식 문자열에 ‘ n’이 없기 때문에 한 줄에 \x08 붙여서 출력한다. \x08 } 10 11 12 13 14 결과 79 400', ""%d : 10 진 정수 \n%o : 8 진 정수 \n%x : 16 진 정수 \n%f : 실수형 \n%e : 지수형 \n%c : 문자 \n%s : 문자열 \nJava 언어 변수명 작성 규칙 \n \n영문 대소문자(AZ, az), 숫자(0~9), '_', '$'를 혼용하여 사용할 수 있다. \n첫 글자는 영문자나 '_', '$'로 시작해야 한다. \n영문자는 대소문자를 구분한다. \n공백을 포함할 수 없다. \n예약어(Reserved Word)를 사용할 수 없다. \nJava 언어의 연산자 \n연산자의 종류 및 우선순위 \n \n연산자 종류 \n결합 방향 \n우선순위 \n단항 연산자 +, -, !, ~, ++, -- \n<- \n높음 \n산술 연산자 *, / ,% \n-> \n \n+, - -> \n \n비트 시프트 <<, >>, >>> -> \n \n관계 연산자 <, <=, >, >=, instanceof \n-> \n \n==, != \n-> \n \n논리 연산자 &, |, ^ \n-> \n \n비트 논리 \n&&, || \n-> \n \n조건 연산자 ? : \n<- \n \n할당 연산자 =, +=, -=, *=, /=, %=, <<=, >>= \n<- \n낮음 \n오버로딩(Overloading)과 오버라이딩(Overriding) \n오버로딩(Overloading - 과적, 과부하) \n \n한 클래스 내에서 같은 메서드를 사용하는 것이다. \n같은 이름의 메서드를 여러 개 정의하면서 매개 변수의 유형과 개수가 달라지도록 하는 \n기술이다. \n오버라이딩(Overriding - 가장 우선되는, 최우선으로 되는, 다른 것보다 우선인) \n \n상속 관계의 두 클래스의 상위 클래스에서 정의한 메서드를 하위 클래스에서 \n변경(재정의)하는 것이다. \nJava 언어에서는 static 메ㅓㅅ드의 오버라이딩을 허용하지 않는다. \n오버라이딩의 경우 하위 객체의 매개 변수 개수와 타입은 상위 객체와 같아야 한다. \n53. 제어문 \n조건문 \nif 문 \n \nif 문 \n \n    if(조건식) ~ : 조건식의 결과가 참일 때 실행하는 명령문; \nif / else 문""]"
7,소프트웨어 설계 시 구축된 플랫폼의 성능 특성 분석에 사용되는 측정 항목이 아닌 것은?,"[""응답 시간(Response Time)"", ""서버 튜닝(Server Tuning)"", ""가용성(Availability)"", ""사용률(Utilization)""]",2,2,소프트웨어 설계,소프트웨어 개발,"소프트웨어 설계 시 구축된 플랫폼의 성능 특성 분석에 사용되는 측정 항목에는 응답 시간(Response Time), 가용성(Availability), 사용률(Utilization) 등이 포함됩니다. 
- 응답 시간(Response Time)은 시스템이 사용자의 요청에 반응하여 응답을 제공하는 데 걸리는 시간을 의미합니다.
- 가용성(Availability)은 시스템이나 서비스가 사용자가 필요할 때 언제든지 사용할 수 있는 상태를 의미합니다.
- 사용률(Utilization)은 시스템 자원의 사용 정도를 나타냅니다.

서버 튜닝(Server Tuning)은 성능 최적화를 위한 일련의 과정이지 측정 항목이 아닙니다. 서버 튜닝은 시스템의 성능을 향상시키기 위해 하드웨어, 소프트웨어, 네트워크 등의 설정을 조정하는 활동을 포함합니다.

과목: 소프트웨어 개발","['객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?\n\n[보기]\n1) Coad 와 Yourdon 방법\n2) Booch 방법\n3) Jacobson 방법\n4) Wirfs-Brocks 방법', '데이터베이스 설계 단계 중 물리적 설계 시 고려 사항으로 적절하지 않은 것은?\n\n[보기]\n1) 스키마의 평가 및 정제\n2) 응답 시간\n3) 저장 공간의 효율화\n4) 트랜잭션 처리량', '소프트웨어를 재사용함으로써 얻을 수 있는 이점으로 가장 거리가 먼 것은?\n\n[보기]\n1) 생산성 증가\n2) 프로젝트 문서 공유\n3) 소프트웨어 품질 향상\n4) 새로운 개발 방법론 도입 용이', '소프트웨어 설계에서 요구사항 분석에 대한 설명으로 틀린 것은?\n\n[보기]\n1) 소프트웨어가 무엇을 해야 하는가를 추적하여 요구사항 명세를 작성하는 작업이다.\n2) 사용자의 요구를 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계이다.\n3) 소프트웨어 시스템이 사용되는 동안 발견되는 오류를 정리하는 단계이다.\n4) 소프트웨어 개발의 출발점이면서 실질적인 첫 번째 단계이다.', '소프트웨어 형상관리(Configuration management)에 관한 설명으로 틀린 것은?\n\n[보기]\n1) 소프트웨어에서 일어나는 수정이나 변경을 알아내고 제어하는 것을 의미한다.\n2) 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다.\n3) 형상관리를 위하여 구성된 팀을 “chief programmer team”이라고 한다.\n4) 형상관리의 기능 중 하나는 버전 제어 기술이다.', '명시된 조건 하에서 소프트웨어 제품의 일정한 성능과 자원 소요량의 관계에 관한 속성 즉 \n요구되는 기능을 수행하기 위해 필요한 자원의 소요 정도 \n무결성 \n허용되지 않는 사용이나 자료의 변경을 제어하는 정도 \n변경 수용 특성 \n이식성 \n다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 정도 \n상호운용성 \n다른 소프트웨어와 정보를 교환할 수 있는 정도 \n재사용성 \n전체나 일부 소프트웨어를 다른 목적으로 사용할 수 있는가 하는 정도 \n유지보수성 \n사용자의 기능 변경의 필요성을 만족하기 위하여 소프트웨어를 진화하는 것이 가능한 정도 \n유연성 \n소프트웨어를 얼마만큼 쉽게 수정할 수 있는가의 정도 \n시험 역량 \n의도된 기능을 수행하도록 보장하기 위해 프로그램을 시험할 수 있는 정도. \n소프트웨어 품질 측정 시 관점별 분류 \n \n사용자 관점 : 제품의 신뢰성, 효율성, 사용 용이성, 간결성 등 \n개발자 관점 : 검증 가능성, 유지보수성, 이식성, 무결성, 사용성 등 \n프로젝트 관리자 관점 : 프로세스의 생산성과 제어 용이성 \n릴리즈 노트 작성하기 \n릴리즈 노트(Release note) \n \n애플리케이션 최종 사용자인 고객에게 제공하는 잘 정리된 배포 정보 문서이다. \n애플리케이션 릴리즈 노트에는 상세 서비스를 포함하여 수정/변경된 정보를 담고 있는 \n문서이다. \n사용자에게 최종 배포된 릴리즈 노트를 보면 테스트가 어떻게 진행됐는지, 개발팀의 제공 \n사양을 얼마나 준수했는지를 확인해 볼 수 있다. \n전체적인 버전 관리 및 릴리즈 정보를 체계적으로 관리할 수 있다. \n릴리즈 노트는 현재 시제로 개발팀에서 직접 작성하여야 하며, 명확하고 정확하며 완전한 \n정보를 제공해야 한다. \n개발자와 테스터가 함께 협업해야 하고 최초 및 변경, 개선 항목까지 연결되어 다음 항목에 \n대한 정보들이 릴리즈 노트를 통해 작성되어야 한다. \n릴리즈 노트 작성 항목 \n \n헤더(Header) : 문서명, 제품명, 배포 버전 번호, 릴리즈 날짜, 참고 날짜, 문서(릴리즈', '진행 순서 : 연계 테스트 케이스 작성 => 연계 테스트 환경 구축 => 연계 테스트 수행 => \n연계 테스트 수행 결과 검증 \n연계 테스트 분류 \n \n소프트웨어 연계 테스트 구간 : 송신 시스템에서 연계 서버 또는 중계 서버를 거치고 수신 \n시스템까지 데이터가 전달되는가를 테스트한다. \n소프트웨어 연계 단위 테스트 : 연계 자체만을 테스트한다. 송신 시스템에서 연계 데이터를 \n추출 및 생성하고 이를 연계 테이블로 생성한다. 연계 서버 또는 중계 서버가 있는 경우 \n연계 테이블 간 송/수신을 한다. \n소프트웨어 연계 통합 테스트 : 연계 테스트보다 큰 통합 기능 테스트의 일부로서 연계 \n통합 테스트를 수행한다.', '요구사항 정의 요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제 공하는 서비스에 대한 설명과 정상적으로 운영되는데 필 요한 제약조건 등을 나타낸다. 요구사항의 유형 유형 내용- 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항 기능- 시스템의 입력이나 출력으로 무엇이 포함되어 요구사항 야 하는지, 시스템이 어떤 데이터를 저장하거나 (Functional 연산을 수행해야 하는지에 대한 사항 requirements)- 시스템이 반드시 수행해야 하는 기능- 사용자가 시스템을 통해 제공받기를 원하는 기능- 시스템 장비 구성 요구사항 : 하드웨어, 소프트웨어, 네트워크 등의 시스템 장비 구성에 대한 요구사항- 성능 요구사항 : 처리 속도 및 시간, 처리량, 동적· 정적 적용량, 가용성 등 성능에 대한 요구사항- 인터페이스 요구사항 : 시스템 인터페이스와 사 용자 인터페이스에 대한 요구사항으로 다른 소 프트웨어, 하드웨어 및 통신 인터페이스, 다른 시스템과의 정보 교환에 사용되는 프로토콜과 의 연계도 포함하여 기술- 데이터 요구사항 : 초기 자료 구축 및 데이터 변 환을 위한 대상, 방법, 보안이 필요한 데이터 등 데이터를 구축하기 위해 필요한 요구사항 비기능- 테스트 요구사항 : 도입되는 장비의 성능 테스 요구사항 (Non- 트(BMT)나 구축된 시스템이 제대로 운영되는지 functional 를 테스트하고 점검하기 위한 테스트 요구사항 requirements)- 보안 요구사항 : 시스템의 데이터 및 기능, 운영 접근을 통제하기 위한 요구사항- 품질 요구사항 : 관리가 필요한 품질 항목, 품질 평가 대상에 대한 요구사항으로 가용성, 정합성, 상호 호환성, 대응성, 신뢰성, 사용성, 유지·관리 성, 이식성, 확장성, 보안성 등으로 구분하여 기술- 제약사항 : 시스템 설계, 구축, 운영과 관련하여 사전에 파악된 기술, 표준, 업무, 법·제도 등의 제약조건- 프로젝트 관리 요구사항 : 프로젝트의 원활한 수행을 위한 관리 방법에 대한 요구사항- 프로젝트 지원 요구사항 : 프로젝트의 원활한 수 행을 위한 지원 사항이나 방안에 대한 요구사항 정보처리기사 필기 요약 2459', '사용량, 네트워크 사용량 \n유형별 성능 분석 도구 \n \n성능/부하/스트레스(Performance/Load/Stress) 정검 도구 : 측정 지표인 처리량, 응답 \n시간, 경과 시간 등을 점검하기 위해 가상의 시스템 부하나 스트레스를 통해 성능을 \n분석하는 도구이다. \n모니터링(Monitoring) 도구 : 성능 모니터링, 성능 저하 원인 분석, 시스템 부하량 \n분석, 장애 진단, 사용자 분석, 용량 산정 등의 기능을 통하여 애플리케이션 실행 시 자원 \n사용량을 확인하고 분석 가능한 도구이다. \n애플리케이션 성능 저하 원인 \n데이터베이스 연결 및 쿼리 실행 시 발생되는 성능 저하 원인 \n \nDB Lock \n과도한 데이터 조회/업데이트/인덱스 생성 시 발생한다. \nLock 의 해제 시까지 대기하거나 처리되지 못하고 종료된다. \n불필요한 DB Fetch \n필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 발생한다. \n결과 세트에서 마지막 위치로 커서를 옮기는 작업이 빈번한 경우 응답 시간 저하 현상이 \n발생한다. \n연결 누수(Connection Leak) \nDB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생한다. \n부적절한 Connection Pool Size \n커넥션 풀 크기가 너무 작거나 크게 설정한 경우 발생한다. \n기타 \n트랜잭션이 Commit 되지 않고 커넥션 풀에 반환되거나, 잘못 작성된 코드로 인해 불필요한 \ncommit 이 자주 발생하는 경우 발생한다. \n내부 로직으로 인한 성능 저하 원인 \n \n웹 애플리케이션의 인터넷 접속 불량이나 대량의 파일로 인해 부하가 발생하는 경우이다. \n정상적으로 처리되지 않은 오류 처리로 인한 부하나 트랜잭션이 수행되는 동안 외부 \n트랜잭션(외부 호출)이 장시간 수행되거나, 타임아웃이 일어나는 경우이다. \n잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인 \n \n환경 설정으로 인한 성능 저하 : Thread pool, Heap Memoty 의 크기를 너무 작게', 'Ⅰ  설계 -> SW 품질을 높일 수 있도록 설계해야! \n1. SW의 품질 특성 \n1) 기능성 : 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 \n2) 신뢰성 : 기능을 요류없이 수행하는지 \n3) 사용성 : 쉽게 배우고 사용할 수 있는지 \n4) 효율성 : 얼마나 빨리 기능이 수행되는지 \n5) 유지 보수성 : 변화에 따라 개선하거나 확장할 수 있는지 \n6) 이식성 : 다른 환경에서도 얼마나 쉽게 적용되는지 \n2. 화면설계 (UIUX 설계) \n1) 사용자 인터페이스 (UI) \n(1) 정의: 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치/SW \n=> 사용자 중심으로 설계되어야함 \n(2) 사용자 인터페이스 구분 \na. CLI (Command Line Interface) : 텍스트 형태 인터페이스 (터미널) \nb. GUI (Graphical User Interface) : 그래픽 환경의 인터페이스  \n=> 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행 \nc. NUI (Natural User Interface) : 말이나 행동으로 기기를 조작 \nd. VUI (Voice User Interface) : 음성으로 조작  \ne. OUI (Organic User Interface) \n: 모든 사물과 사용자간의 상호작용을 위한 인터페이스 \n(3) 기본 원칙 \na. 직관성 : 누구나 쉽게 사용할 수 있어야함 \nb. 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야함 \nc. 학습성 : 누구나 쉽게 배울 수 있어야함  \nd. 유연성 : 실수를 최소화해야함 \n(4) 설계 지침  \n사용자 중심, 사용성(사용자의 편리한 사용) 심미성(가독성을 높이는 설계),  \n오류 발생(오류가 발생하면 사용자가 쉽게 인지할 수 있도록) \n2. 애플리케이션 설계 \n1) 소프트웨어 아키텍처 \n(1) 정의 : 소프트웨어의 골격이 되는 기본 구조 \n(2) 설계 과정 : 목표설정 -> 시스템 타입 결정 -> 패턴 적용 -> 구체화 -> 검토 \n(3) 설계의 기본 원리']"
8,사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측하는 모형은?,"[""나선형 모형"", ""애자일 모형"", ""프로토타입 모형"", ""폭포수 모형""]",3,3,소프트웨어 설계,소프트웨어 설계,"프로토타입 모형(Prototype Model)은 실제 개발될 소프트웨어의 견본품을 만들어 최종 결과물을 예측하는 모형입니다. 이 모형은 개발이 완료되고 나서 사용을 하면 문제점을 알 수 있는 폭포수 모형의 단점을 보완하기 위한 모형으로 요구사항을 충실히 반영할 수 있습니다. 프로토타입 모형은 사용자가 요구하는 기능을 프로토타입으로 구현하여 사용자가 평가하고 요구사항을 수정하는 과정을 반복함으로써 최종 소프트웨어를 개발하는 방식입니다.

과목: 소프트웨어 설계","['소프트웨어 개발 영역을 결정하는 요소 중 다음 사항과 관계있는 것은?\n\n[보기]\n1) 기능(Function)\n2) 성능(Performance)\n3) 제약조건(Constraint)\n4) 인터페이스(Interface)', '소프트웨어 공학에서 모델링 (Modeling) 과 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 개발팀이 응용 문제를 이해하는 데 도움을 줄 수 있다.\n2) 유지보수 단계에서만 모델링 기법을 활용한다.\n3) 개발될 시스템에 대하여 여러 분야의 엔지니어들이 공통된 개념을 공유하는 데 도움을 준다.\n4) 절차적인 프로그램을 위한 자료 흐름도는 프로세스 위주의 모델링 방법이다.', '파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은?\n\n[보기]\n1) 노드와 간선으로 구성된다.\n2) 서브시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복한다.\n3) 계층 모델이라고도 한다.\n4) 3개의 서브시스템(모델, 뷰, 제어)으로 구성되어 있다.', '파이프 필터 형태의 소프트웨어 아키텍처에 대한 설명으로 옳은 것은?\n\n[보기]\n1) 노드와 간선으로 구성된다.\n2) 서브시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브시스템으로 넘겨주는 과정을 반복한다.\n3) 계층 모델이라고도 한다.\n4) 3 개의 서브시스템모델 ( , 뷰 , 제어으로 ) 구성되어 있다 .', '소프트웨어 개발 프레임워크를 적용할 경우 기대 효과로 거리가 먼 것은?\n\n[보기]\n1) 품질 보증\n2) 시스템 복잡도 증가\n3) 개발 용이성\n4) 변경 용이성', '개발 단계 안에서 유지보수가 이루어지는 것으로 볼 수 있다. \n폭포수 모형(Waterfall Model) \n \n보헴(Boehm)이 제안한 고전적 생명주기 모형으로, 선형 순차적 모형이라고도 한다. \n타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수의 단계를 통해 소프트웨어를 \n개발하는 모형이다. \n순차적인 접근 방법을 이용하며, 단계적 정의와 산출물이 명확하다. \n각 단계의 결과가 확인되어야지만 다음 단계로 넘어간다. \n개발 중 발생한 요구사항은 반영하기 어렵다. \n가장 오래된 모형으로 모형의 적용 경험과 성공 사례가 많다. \n나선형 모형(Spiral Model) \n \nBoehm 이 제시하였으며, 반복적인 작업을 수행하는 모형으로 점증적 모형, 집중적 \n모형이라고도 한다. 완성도 높은 소프트웨어를 만들 수 있다. \n여러 번의 개발 과정을 거쳐 완벽한 최종 소프트웨어를 개발하는 점진적 모형이다. \n가장 큰 장점인 위험 분석 단계에서 기술과 관리의 위험 요소들을 하나씩 제거해 \n나감으로써 위험성 평가에 크게 의준하기 때문에 이를 발견하지 않으면 문제가 발생할 수 \n있다. \n대규모 시스템의 소프트웨어 개발에 적합하다. \n나선형 모형의 개발 단계 \n \n계획 수립(Planning) : 위험 요소와 타당성을 분석하여 프로젝트의 추진 여부를 \n결정한다. \n위험 분석(Risk Analysis) : 개발 목적과 기능 선택, 제약 조건 등을 결정하고 \n분석한다. \n개발 및 검증(Development) : 선택된 기능을 수행하는 프로토타입을 개발한다. \n고객 평가(Evaluation) : 개발된 프로토타입을 사용자가 확인하고 추가 및 수정될 \n요구사항이 있으면 이를 반영한 개선 프로토타입을 만든다. \nCMP(Critical Path Method) \n \n프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는 기법이다. \n노드와 간선으로 구성되며, 노드는 작업을 표시하고 간선은 작업 사이의 전후 의존 관계를 \n나타낸다.', '요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기이다. \n3. 소프트웨어 개발 방법론 \n소프트웨어 설계 방법론 \n소프트웨어 생명주기(Software Life Cycle) \n \n소프트웨어 제품의 개념 형성에서 시작하여 운용/유지보수에 이르기까지 변화의 모든 \n과정이다. \n타당성 검토 => 개발 계획 => 요구사항 분석 => 설계 => 구현 => 테스트 => 운용 => \n유지보수 \n폭포수 모형(Waterfall Model)의 개요 \n \n선형 순차적 모델이라고도 하며 Boehm 이 제시한 고전적 생명주기 모형으로, 소프트웨어 \n개발 과정의 각 단계가 순차적으로 진행되는 모형이다. \n나선형 모형(Spiral Model) \n \nBoehm 이 제시하였으며, 반복적인 작업을 수행하는 점증적 생명주기 모형이다. \n점증적 모형, 집중적 모형이라고도 하며 유지보수 과정이 필요 없다. \n소프트웨어 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적이다. \n나선을 따라서 돌아가면서 각 개발 순서를 반복하여 수행하는 점진적 방식으로 누락된 \n요구사항을 추가할 수 있다. \n하향식과 상향식 설계 \n \n하향식 설계 : 소프트웨어 설계 시 제일 상위에 있는 Main User Function 에서 시작하여 \n기능을 하위 기능들로 나눠 가면서 설계하는 방식이다. \n상향식 설계 : 가장 기본적인 컴포넌트를 먼저 설계한 다음 이것을 사용하는 상위 수준의 \n컴포넌트를 설계하는 방식이다. \n프로토타입 모형(Prototype Model)의 개요 \n \n실제 개발될 시스템의 견본(Prototype)을 미리 만들어 최종 결과물을 예측하는 모형이다. \n개발이 완료되고 나서 사용을 하면 문제점을 알 수 있는 폭포수 모형의 단점을 보완하기 \n위한 모형으로 요구사항을 충실히 반영할 수 있다. \nHIPO(Hierarchy Input Process Output) \n \n입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법이다.', '- 정의: 소프트웨어를 개발하기 위한 과정 (요구사항 분석, 설계, 개발, 유지보수 등) | 모델:  - 이름: 폭포수 모형 | 특징: 이전 단계로 돌아갈 수 없음, 앞단계가 끝나야 다음단계로 넘어감 (병행X)  - 이름: 프로토타입 모형 | 특징: 프로토타입(견본)을 만들어 최종 결과물을 예측, 새로운 요구사항 반영 가능  - 이름: 나선형 모형 | 특징: 여러 번의 소프트웨어 개발과정 반복, 위험 관리 중심, 요구사항 첨가 가능  - 이름: 애자일 | 특징: 고객과의 소통에 초점, 스프린트/이터레이션 반복, 요구사항 변화에 유연 대응 | 종류:  - 스크럼  - XP  - 기능 중심 개발(FDD)', 'COCOMO 모형 개요 COCOMO(COnstructive COst MOdel) 모형은 보헴 (Boehm)이 제안한 것으로, 원시 프로그램의 규모인 LOC(원시 코드 라인 수)에 의한 비용 산정 기법이다.- 개발할 소프트웨어의 규모(LOC)를 예측한 후 이를 소 프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정 식에 대입하여 비용을 산정한다.- 비교적 작은 규모의 프로젝트들을 통계 분석한 결과를 반영한 모델이므로 중소 규모 소프트웨어 프로젝트 비 용 추정에 적합하다.- 같은 규모의 프로그램이라도 그 성격에 따라 비용이 다 르게 산정된다.- 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력 (Man- Month)으로 나타난다. 23.5, 22.7, 21.8, 21.5, 21.3, 20.8, 20.6 2417', '소프트웨어 엔지니어 관점에서 요구사항을 확인하기 위한 수단으로 많이 사용되고, 실제 \n구현 전에 잘못된 요구사항을 적용하는 자원 낭비를 방지할 수 있다. \n절차 : 요구사항 분석 단계 => 프로토타입 설계 단계 => 프로토타입 개발 단계 => 고객의 \n평가 단계 => 프로토타입 정제 단계 => 완제품 생산 단계 \n장점 \n단점 \n- 분석가의 가정을 파악하고 잘못되었을 때 유용한 피드백을 제공한다. \n- 문서나 그래픽 모델보다 프로토타입으로 이해하기 쉬워 사용자와 개발자 사이의 \n의사소통에 도움이 된다. \n- 요구사항의 가변성이 프로토타이핑 이후에 급격히 감소한다. \n- 빠르게 제작할 수 있으며, 반복 제작을 통하여 발전된 결과를 가져올 수 있다. \n- \n사용자의 관심이 핵심 기능에서 멀어질 수 있으며, 프로토타입의 디자인이나 품질 문제로 \n집중될 수 있다. \n- 프로토타입 수행 비용이 발생한다. \n- 전체 범위 중 일부 대상 범위만 프로토타입을 제작하면 사용성이 과대하게 평가될 수 \n있다. \n모델 검증(Model Certification) \n \n분석 단계에서 개발된 모델의 품질을 검증ㅈ한다. \n정적 분석(Static Analysis) : 객체 모델에서 객체들 사이에 존재하는 Communication \nPath(의사소통 경로)를 검증하기 위해 사용한다. 명세의 일관성과 정확성을 확인 분석하는 \n도구이다. \n동적 문석(Dynamic Analysis) : 직접 실행을 통하여 모델을 검증하는 방식이다. \n인수 테스트(Acceptance Tests) \n \n최종 제품이 설계 시 제시한 요구사항을 만족하는지 확인하는 단계이다. \n인수 시 각 요구사항의 확인 절차를 계획해야 한다. \n종류 : 계약 인수 테스트, 규정 인수 테스트, 알파 검사, 베타 검사, 사용자 인수 \n테스트, 운영 인수 테스트 \n7. UML \n개념 모델링(Conceptual Modeling) \n개념 모델링 \n \n요구사항을 이해하기 쉽도록 실 세계의 상황을 단순화하여 개념적으로 표현한 것을']"
9,객체지향 분석 방법론 중 Coad-Yourdon 방법에 해당하는 것은 ?,"[""E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다."", ""객체 , 동적 , 기능 모델로 나누어 수행하는 방법이다 ."", ""미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 방법이다."", ""Use-Case 를 강조하여 사용하는 방법이다 .""]",1,1,소프트웨어 설계,소프트웨어 설계,"Coad-Yourdon 방법론은 E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법입니다. 이 방법론은 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성되어 있습니다. 따라서 보기 중에서 'E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다.'라는 설명이 Coad-Yourdon 방법론에 해당합니다.
과목: 소프트웨어 설계","['주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법으로 , 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행하는 할당 기법은?\n\n[보기]\n1) 오버레이\n2) 스와핑\n3) 페이징\n4) 세그먼테이션', '코드 설계에서 코드화 대상 항목의 성질 , 즉 길이 , 넓이 , 부피 , 지름 , 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방식의 코드는?\n\n[보기]\n1) 연상 코드\n2) 블록 코드\n3) 순차 코드\n4) 표의 숫자 코드', '데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?\n\n[보기]\n1) CASE 분석\n2) 일치 분석\n3) CRUD 분석\n4) 연관성 분석', '데이터베이스에 영향을 주는 생성 , 읽기 , 갱신 , 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?\n\n[보기]\n1) CASE 분석\n2) 일치 분석\n3) CRUD 분석\n4) 연관성 분석', '럼바우 (Rumbaugh) 의 객체지향 분석 절차를 가장 바르게 나열한 것은?\n\n[보기]\n1) 객체 모형 → 동적 모형 → 기능 모형\n2) 객체 모형 → 기능 모형 → 동적 모형\n3) 기능 모형 → 동적 모형 → 객체 모형\n4) 기능 모형 → 객체 모형 → 동적 모형', '객체지향 분석의 방법론 객체지향 분석을 위한 여러 방법론이 제시되었으며 각 방 법론은 다음과 같다.- Rumbaugh(럼바우) 방법 : 가장 일반적으로 사용되는 방 법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법- Booch(부치) 방법 : 미시적(Micro) 개발 프로세스와 거 시적(Macro) 개발 프로세스를 모두 사용하는 분석 방 법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함 18- Jacobson 방법 : Use Case를 강조하여 사용하는 분석 방법- Coad와 Yourdon 방법 : E- R 다이어그램을 사용하여 객 체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법- Wirfs- Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하 는 기법 23.7, 22.7, 22.3, 21.8, 21.5, 21.3, 20.9, 20.8, 20.6 2402', '자료에 중점을 두어 자료와 프로세스를 별개의 작업으로 병행 진행한 후 서로 간의 오류를 \n상관 분석하여 검증한다. \n정보 전략 계획(ISP), 업무 영역 분석(BAA), 업무 시스템 설계(BSD), 시스템 구축(SC) \n단계로 구성된다. \n객체지향 방법론(Object-oriented Engineering Methodolohy) \n \n분석, 설계, 개발 단계에 객체지향 기법을 활용하는 방법론이다. \n구조적 프로그래밍 기법의 한계와 소프트웨어 개발의 위기에서 등장하였다. \n요구분석, 설계, 수현, 테스트 및 검증 단계로 구성된다. \n객체지향의 기본 원칙은 캡슐화(Encapsulation), 정보 은닉(Information Hiding), \n추상화(Abstraction), 상속(Inheritance), 다형성(Polymorphism)이다. \n시스템 분석을 위해 유스케이스 다이어그램(UseCase Diagram)이 주로 사용된다. \n시스템 설계를 위해 시퀀스 다이어그램(Sequence Diagram)이 주로 사용된다. \n컴포넌트 기반 개발 방법론(CBD : Component Based Development) \n \n재사용이 가능한 컴포넌트의 개발 또는 상용 컴포넌트들을 조합하여 애플리케이션 개발 \n생산성과 품질을 높이고, 시스템 유지보수 비용을 최소화할 수 있는 개발 방법 \n프로세스이다. \n컴포넌트 단위의 개발 및 조립을 통해 정보 시스템의 신속한 구축, 변경, 확장의 용이성과 \n타 시스템과의 호환성을 달성하고자 하는 소프트웨어 공학 프로세스, 방법론 및 기술의 \n총체적 개념이다. \nCBD(Component Based Development) SW 개발 표준 산출물 \n \n분석 : 사용자 요구사항 정의서, 유스케이스 명세서, 요구사항 추적표 \n설계 : 클래스 명세서, 사용자 인터페이스 설계서, 아키텍처 설계서, 총괄 시험 계획서, \n시스템 시험 시나리오, 엔티티 관계 모형 설계서, 데이터베이스 설계서, 통합 시험', '고려하기 위하여 다양한 관점을 바탕으로 정의한 모델이다. \nLogical View(분석 및 설계), Implementation View(프로그래머), Process \nView(시스템 통합자), Deployment View(시스템 엔지니어), Use Case View(사용자)의 \n5 계층으로 분류한 모델 \n소프트웨어 아키텍처 설계 원리 \n \n구분 \n설명 \n단순성 다양한 요소를 단순화하여 복잡성을 최소화한다. \n효율성 활용 자원의 적절성과 효율성을 높인다. \n분할, 계층화 다루기 쉬운 단위로 묶어서 계층화한다. \n추상화 부가적인 기능이 아닌 핵심 기능 위주로 컴포넌트를 정의한다. \n모듈화 내부 요소의 응집도를 높이고 각 모듈의 외부 결합도를 낮춘다. \n소프트웨어 아키텍처 평가 방법론의 종류 \n \n방법 \n설명 \nSAAM - Software Architecture Analysis Method 의 약어로, 최초 정리된 평가 \n방법이다. \n- 다양한 수정 가능성(Modificability) 관점에서 아키텍처를 평가하고 분석하는 \n방법이다. \n- 수정/변경에 필요한 자원을 가정하고 이를 기반으로 평가한다. \n- ATAM 에 비하여 상세하지는 않지만 보다 많은 영역에 적용할 수 있다. \nATAM - Architecture Trade off Analysis Method 의 약어로 SAAM 을 승계한 \n방법론이다. \n- 아키텍처가 품질 속성을 만족하는지 판단하고, 어떻게 절충(TradeOff)하면서 \n상호작용하는지 분석하는 평가 방법이다. \n- 모든 품질 속성을 평가하고, 관심 있는 모든 관련 당사자들이 참여한다. \n- 정량적/정성적 분석/평가 수행하며, 민감점(Sensitivity Point)과 절충점(TradeOff \nPoint)을 찾는 데 중점을 둔다. \nCBAM - Cost Benefit Analysis Method 의 약어로 ATAM 에서 경제적인 부분을 보완한 \n형태이다. \n- 소프트웨어 아키텍처를 ROI 관점에서 평가하며 시스템이 제공하는 품질에서 경제적 이득', '모델이라고 하고, 이렇게 표현된 모델을 생성해 나가는 과정을 개념 모델링이라고 한다. \n모델은 문제가 발생하는 상황에 대한 이해를 증진하고 해결책을 설명하므로 소프트웨어 \n요구사항 분석의 핵심이라 할 수 있다. \n개발 대상 도메인의 엔티티(Entity)들과 그들의 관계 및 종속성을 반영한다. \n요구사항별로 관점이 다르므로 개념 모델도 다양하게 표현되어야 한다. \n대부분 UML(Unified Modeling Language)을 사용한다. \n종류 : Use Case Diagram, Data Flow Model, State Model, Goal-Based Model, \nUser Interactions, Object Model, Data Model \nUML(Unified Modeling Language) \nUML \n \n객체지향 소프트웨어 개발 과정에서 시스템 분석, 설계, 구현 등의 산출물을 명세화, \n시각화, 문서화 할 때 사용하는 모델링 기술과 방법론을 통합하여 만든 범용 모델링 \n언어이다. \nRumbaugh 의 OMT 방법론과 Booch 의 Booch 방법론, Jacobson 의 OOSE 방법론을 \n통합하여 만든 모델링 개념의 공통 집합으로 객체지향 분석 및 설계 방법론의 표준 지정을 \n목표로 제안된 모델링 언어이다. \nOMG(Object Management Group)에서 표준화 공고 후 IMB, HP, Microsoft, Oracle \n등이 참여하여 1997.1 버전 1.0 을 Release 하였다. \n럼바우(Rumbaugh) 객체지향 분석 기법 \n \n소프트웨어 구성 요소를 그래픽으로 모형화하였다. \n객체 모델링 기법이라고도 한다. \n객체 모델링 : 정보 모델링이라고도 한다. 시스템에서 요구되는 객체를 찾아내어 속성과 \n연산 식별 및 객체들 간의 관계를 규정하여 객체를 다이어그램으로 표시한다.(OMT : \nObject Modeling Technique) \n동적 모델링 : 제어 흐름, 상호작용, 동작 순서 등의 상태를 시간 흐름에 따라 상태', 'PDL(Program Design Language), 상태 전이도(State Transition Diagram), \n행위도(Action Diagram) \nN-S 도표(Nassi-Schneiderman Chart) \n \n구조적 프로그램의 순차, 선택, 반복의 구조를 사각형으로 도식화하여 알고리즘을 논리적 \n기술에 중점을 둔 도형식 표현 방법이다. \n조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합하다. \n제어 구조 : 순차(연속, Sequence), 선택 및 다중 선택(IfThenElse, Case), \n반복(Repeat~Until, While, For) \n주로 박스다이어그램을 사용하여 논리적인 제어 구조로 흐름을 표현한다. \n조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합하다. \n13. Software Architecture \n소프트웨어 아키텍처(Software Architecture) \nSoftware Architecture 의 개요 \n \n요구사항을 기반으로 개발 대상 소프트웨어의 기본 틀(뼈대)을 만드는 것이다. \n다수의 이해관계자가 참여하는 복잡한 개발에서 상호 이해, 타협, 의사소통을 체계적으로 \n접근하기 위한 것이다. \n전체 시스템의 전반적인 구조를 체계적으로 설계하는 것이다. \n권형도(2004) : ""소프트웨어를 구성하는 컴포넌트들의 상호작용 및 관계, 각각의 특성을 \n기반으로 컴포넌트들이 상호 유기적으로 결합하는 소프트웨어의 여러 가지 원칙들의 \n집합""이다. \n역할 : 설계 및 구현을 위한 구조적/비구조적인 틀(Frame)을 제공한다. \nStructure Frame : 시스템 개발을 위하여 결정된 컴포넌트의 구조 모델이다. \nNon Structure frame : 해당 구조 모델 이외 다른 아키텍처 설계의 결정들이다. \nSoftware Architecture 시스템 품질 속성 7 \n \n성능, 사용 운용성, 보안성, 시험 용이성, 가용성, 변경 용이성, 사용성 \nSoftware Architecture 특징']"
10,"객체지향 기법에서 동일한 형의 특성을 갖는 객체들을 모아 구성한 것으로 , 클래스들 사이의 ‘is instance of’ 관계로 설명되는 연관성을 나타내는 용어는?","[""일반화"", ""분류화"", ""연관화"", ""집단화""]",2,2,소프트웨어 설계,소프트웨어 설계,"객체지향 기법에서 동일한 형의 특성을 갖는 객체들을 모아 구성한 것으로, 클래스들 사이의 ‘is instance of’ 관계로 설명되는 연관성은 분류화입니다. 분류화는 객체지향 프로그래밍에서 중요한 개념 중 하나로, 객체들의 공통된 특성을 추출하여 클래스로 정의하고, 이 클래스를 통해 객체들을 생성하는 것을 의미합니다.

과목: 소프트웨어 설계

이유: 
소프트웨어 설계 과목은 객체지향 프로그래밍의 기본 개념과 설계 원리를 다루며, 분류화, 일반화, 집합 관계, 연관 관계 등 객체지향 모델링의 핵심 개념들을 포함합니다. 따라서 이 문제는 소프트웨어 설계 과목과 관련이 있습니다.","['스키마의 종류 중 조직이나 기관의 총괄적 입장에서 본 데이터베이스의 전체적인 논리적 구조로서 , 모든 응용 프로그램이나 사용자들이필요로 하는 데이터를 종합한 조직 전체의 데이터베이스 구조를의미하는 것은?\n\n[보기]\n1) 관계 스키마\n2) 외부 스키마\n3) 내부 스키마\n4) 개념 스키마', '데이터베이스에는 관계형, 계층형, 네트워크형 등 다양한 종류가 있는데 이들을 구분하는 기준은?\n\n[보기]\n1) 개체(Object)\n2) 관계(Relationship)\n3) 속성(Attribute)\n4) 제약 조건(Constraint)', '데이터베이스에는 관계형 , 계층형 , 네트워크형 등 다양한 종류가 있는데 이들을 구분하는 기준은?\n\n[보기]\n1) 개체(Object)\n2) 관계(Relationship)\n3) 속성(Attribute)\n4) 제약 조건(Constraint)', '객체지향 분석 기법의 하나로 객체 모형, 동적 모형, 기능 모형의 3개 모형을 생성하는 방법은?\n\n[보기]\n1) Wirfs-Block Method\n2) Rumbaugh Method\n3) Booch Method\n4) Jacobson Method', '정규화된 엔티티 , 속성 , 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복 , 통합 , 분리 등을 수행하는 데이터 모델링 기법 은?\n\n[보기]\n1) 정규화\n2) 반정규화\n3) 집단화\n4) 머징', '팩토리 메소드 : 상위 클래스를 바탕으로 하위 클래스에서 구체화 \n프로토 타입 : 원본 객체를 복제해서 생성 (비용 저렴) \n싱글톤 : 클래스로 하나의 객체만 생성 \n(4) 구조패턴 : 클래스나 객체를 조합하여 더 큰 구조 만드는 패턴 \n어뎁터 : 호환되지 않는 클래스를 다른 클래스가 이용할 수 있게 변환 \n브리지 : 기능과 구현을 두 개의 별도 클래스로 구현 \n컴포지트 : 객체들을 트리 구조로 구성 \n프록시 : 접근이 어려운 객체 사이의 인터페이스 역할 수행 \n기타 : 데코레이터, 퍼싸드, 플라이웨이트 \n(5) 행위 패턴 : 객체들의 서로 상호작용 하는 방법 정의 \n커맨드 : 요청을 캡슐화해서 저장해둠 \n중재자(Medidator) : 상호작용을 캡슐화하여 객체로 정의 \n옵서버 : 한 객체의 상채가 면화하면 다른 객체들에게 전달 (이벤트) \n상태 : 상태에 따라 다르게 처리 \n전략 : 동일 계열 알고리즘을 개별적 캡슐화 (상호교환 가능) \n템플릿 메소드 : 상위 클래스는 골격정의, 하위 클래스는 세부 처리 \n방문자 : 처리 기능을 분리하여 별도의 클랴스로 \n기타 : 책임 연쇄, 인터프리터, 반복자(Iterator), 메멘토 \n3) 객체 지향 설계 원칙 (SOLID) \nSRP(Single Responsibility, 단일 책임) : 객체는 하나의 책임만 가져야함 \nOCP(Open-Closed, 개방-폐쇄) : 기존 코드 변경없이 기능 추가 가능해야 \nLSP(Liskov Substitution, 리스코프 치환)  \n: 자식 클래스는 부모 클래스의 행위를 할 수 있어야함 => 확장만 \nISP(Interface Segregation, 인터페이스 분리): 인터페이스 버전의 SPR \nDIP(Dependency Inversion, 의존 역전): 추상성이 높은 클래스를 의존', '큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층구조(추상화 및 \n구현)로 나눈 후 각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴. \n기능 클래스 계층과 구현 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 각자 \n독립적으로 변형할 수 있도록 해주는 패턴이다. \nComposite(복합체) \n객체들을 트리 구조들로 구성한 후, 이러한 구조들과 개별 객체들처럼 작업할 수 있도록 \n하는 구조 패턴 \nDecorator \n객체들을 새로운 행동들을 포함한 특수 래퍼 객체들 내에 넣어서 위 행동들을 해당 \n객체들에 연결시키는 구조적 디자인 패턴 \nFacade(퍼사드) \n라이브러리에 대한, 프레임워크에 대한 또는 다른 클래스들의 복잡한 집합에 대한 단순화된 \n인터페이스를 제공하는 구조적 디자인 패턴 \nFlyweight \n각 객체에 모든 데이터를 유지하는 대신 여러 객체들 간에 상태의 공통 부분들을 공유하여 \n사용할 수 있는 RAM 에 더 많은 객체들을 포함할 수 있도록 하는 구조 디자인 패턴 \nProxy \n다른 객체에 대한 대체 또는 자리표시자를 제공할 수 있는 구조 디자인 패턴. \n프록시는 원래 객체에 대한 접근을 제어하므로, 자신의 요청이 원래 객체에 전달되기 전 \n또는 후에 무언가를 수행할 수 있도록 함. \n행위 패턴 \n \n반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 클래스나 객체들이 \n상호작용하는 방법과 책임을 분산하는 방법을 정의한다. \n메시지 교환과 관련된 것으로, 객체 간의 행위나 알고리즘 등과 관련된 패턴을 말한다. \n구성 \nChain of Responsibility(책임 연쇄) \n핸들러들의 체인(사슬)을 따라 요청을 전달할 수 있게 해주는 행동 디자인 패턴. \n각 핸들러는 요청을 받으면 요청을 처리할지 아니면 체인의 다음 핸들러로 전달할지를 결정 \nIterator(반복자) \n컬렉션의 요소들의 기본 표현(리스트, 스택, 트리 등)을 노출하지 않고 그들을 하나씩 \n순회할 수 있도록 하는 행동 디자인 패턴.', '1) 사물 : 구조사물, 행동사물, 그룹사물, 주해사물 \n2) 관계 : 사물과 사물 사이의 연관성 표현 \n종류 \n의미 \n기호 \n연관 관계 \n서로 연관됨 \n의존 관계 \n일시적으로 연관 있음 \n일반화 관계 \n상위 개념 \n실체화 관계 \n공통적인 기능 \n집합 관계 \n다른 사물에 포함됨(종속X) \n포함 관계 \n다른 사물에 포함됨(종속) \n3) 다이어그램 : 사물과 관계를 도형으로 표현한 것 \n구조적 다이어그램 \n행위 다이어그램 \n\uf02d 클래스 다이어그램 \n\uf02d 객체 다이어그램 \n\uf02d 컴포넌트 다이어그램 \n\uf02d 배치 다이어그램 \n\uf02d 복합체 구조 다이어그램 \n\uf02d 패키지 다이어그램 \n\uf02d 유스케이스 다이어그램 \n\uf02d 순차 다이어그램 \n\uf02d 커뮤니케이션 다이어그램 \n\uf02d 상태 다이어그램 \n\uf02d 활동 다이어그램 \n\uf02d 상호작용 개요 다이어그램 \n\uf02d 타이밍 다이어그램 \n5) 자주 사용되는 다이어그램 \na. 클래스 다이어그램 \n정의 : 시스템을 구성하는 클래스, 클래스의 특성과 오퍼레이션(동작),  \n속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 나타냄 \n구성요소 : 클래스(객체의 속성 + 동작), 제약조건, 관계 \nb. 유스케이스 다이어그램 \n정의 : 수행할 수 있는 기능을 사용자 관점에서 표현함 \n구성요소 \n기능 \n시스템 \n시스템 내부의 유스케이스를 사각형으로 묶어 시스템의 범위 표현 \n액터 \n시스템과 상호작용하는 모든 외부 요소 (사람, 외부시스템 등) \n유스케이스 \n시스템이 액터에게 제공하는 기능 \n관계 \n구성요소들간의 관계 \nc. 순차 다이어그램 \n정의 : 시스템이나 객체들이 시간의 흐름에 따라 상호작용하는 과정을 표현 \n<개발 과정>----------------------------------------------------------------- \nⅠ 요구사항 분석 : 개발 전, 고객이 원하는게 뭔지 파악하자! \n1) 요구사항 \n\uf02d 정의 : 소프트웨어에 대한 필요 조건이나 제약사항 \na. 기능 요구사항 : 소프트웨어가 반드시 수행해야하는 기능', '연관성(Relationship) 연관성은 두 개 이상의 객체(클래스)들이 상호 참조하는 관계를 말하며 종류는 다음과 같다. 종류 의미 특징 is member 연관화 2개 이상의 객체가 상호 관련되어 of (Association) 있음을 의미함 is instance 분류화 동일한 형의 특성을 갖는 객체들을 of (Classfication) 모아 구성하는 것 집단화 관련 있는 객체들을 묶어 하나의 상 is part of (Aggregation) 위 객체를 구성하는 것 일반화 공통적인 성질들로 추상화한 상위 (Generalization) 객체를 구성하는 것 is a 특수화/상세화 상위 객체를 구체화하여 하위 객체 (Specialization) 를 구성하는 것 2402', ""UML 의존 관계(Dependency Relation) \n \n연관 관계와 같지만 메소드를 사용할 떄와 같이 매우 짧은 시간만 유지된다. \n영향을 주는 객체(User)에서 영향을 받는 객체 방향으로 점선 화살표를 연결한다. \n운전자ㅡ>자동차--->연료 \n \n운전자 & 자동차 = 연관 관계 \n \n자동차 & 연료 = 의존 관계 \n \nUML 일반화 관계(Generalization Relation) \n \n객체지향에서 상속 관계(Is A Kind Of)를 표현한다. \n한 클래스가 다른 클래스를 포함하는 상위 개념일 때 사용한다.(부모-자식) \nUML 집합 관계 \n \nA 객체가 B 객체에 포함된 관계이다. \n'부분'을 나타내는 객체를 다른 객체와 공유할 수 있다. \n'전체' 클래스 방향에 빈 마름모로 표시하고, or 관계에 놓이면 선 사이를 점선으로 잇고 \n{or}를 표시한다. \nex. 학생(부분) ㅡ◇ 학교(전체) ◇ㅡ 교사(부분) \n \nUML 포함 관계(Composition Relation) \n \n부분 객체가 전체 객체에 속하는 강한 집합 연관의 관계를 표현하는 클래스이다. \n'부분' 객체는 다른 객체와 공유 불가하고, '전체' 객체 방향에 채워진 마름모로 \n표시한다. \nex. 다리(부분) ㅡ◆ 책상(전체) ◆ㅡ 상판(부분) \n \nUML 실체화 관계(Realization Relation) \n \n인터페이스와 실제 구현된 일반 클래스 간의 관계로 존재하는 행동에 대한 구현을 \n표현한다. \n한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계이다. \nex. 미사일 ㅡ▷ 날다 ◁ㅡ 비행기 \n \nUse Case Diagram \nUse Case Diagram 의 개념 \n \n객체지향 초반기 분석 작업에 작성되는 사용자의 요구를 기능적 측면에서 기술할 때 \n사용되는 도구로 Actor 와 User Case 로 구성된다. \n얻어지는 결과는 개발 대상 시스템이 제공해야 하는 서비스 목록이 된다. \nUse Case Diagram 요소 \n \n요소 \n설명""]"
11,"UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며 , 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?","[""Association"", ""Dependency"", ""Realization"", ""Generalization""]",2,2,소프트웨어 설계,소프트웨어 설계,"의존 관계는 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며, 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계입니다. 즉, 의존 관계는 두 클래스 사이에 임시적인 관계로, 한 클래스가 다른 클래스의 오퍼레이션을 사용할 때 사용됩니다. 이 관계는 영향을 주는 객체에서 영향을 받는 객체 방향으로 점선 화살표로 표현됩니다.

과목: 소프트웨어 설계","['UML 에서 활용되는 다이어그램 중 , 시스템의 동작을 표현하는 행위 (Behavioral) 다이어그램에 해당하지 않는 것은 ?\n\n[보기]\n1) 유스케이스 다이어그램(Use Case Diagram)\n2) 시퀀스 다이어그램(Sequence Diagram)\n3) 활동 다이어그램(Activity Diagram)\n4) 배치 다이어그램(Deployment Diagram)', '속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하 는 것을 의미하는 객체지향 개념은?\n\n[보기]\n1) Inheritance\n2) Class\n3) Encapsulation\n4) Association', '다음 중 상태 다이어그램에서 객체 전이의 요인이 되는 요소는 ?\n\n[보기]\n1) event\n2) state\n3) message\n4) transition', '코드 설계에서 코드화 대상 항목의 성질 , 즉 길이 , 넓이 , 부피 , 지름 , 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방식의 코드는?\n\n[보기]\n1) 연상 코드\n2) 블록 코드\n3) 순차 코드\n4) 표의 숫자 코드', '데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?\n\n[보기]\n1) Relation\n2) Data Structure\n3) Constraint\n4) Operation', ""UML 의존 관계(Dependency Relation) \n \n연관 관계와 같지만 메소드를 사용할 떄와 같이 매우 짧은 시간만 유지된다. \n영향을 주는 객체(User)에서 영향을 받는 객체 방향으로 점선 화살표를 연결한다. \n운전자ㅡ>자동차--->연료 \n \n운전자 & 자동차 = 연관 관계 \n \n자동차 & 연료 = 의존 관계 \n \nUML 일반화 관계(Generalization Relation) \n \n객체지향에서 상속 관계(Is A Kind Of)를 표현한다. \n한 클래스가 다른 클래스를 포함하는 상위 개념일 때 사용한다.(부모-자식) \nUML 집합 관계 \n \nA 객체가 B 객체에 포함된 관계이다. \n'부분'을 나타내는 객체를 다른 객체와 공유할 수 있다. \n'전체' 클래스 방향에 빈 마름모로 표시하고, or 관계에 놓이면 선 사이를 점선으로 잇고 \n{or}를 표시한다. \nex. 학생(부분) ㅡ◇ 학교(전체) ◇ㅡ 교사(부분) \n \nUML 포함 관계(Composition Relation) \n \n부분 객체가 전체 객체에 속하는 강한 집합 연관의 관계를 표현하는 클래스이다. \n'부분' 객체는 다른 객체와 공유 불가하고, '전체' 객체 방향에 채워진 마름모로 \n표시한다. \nex. 다리(부분) ㅡ◆ 책상(전체) ◆ㅡ 상판(부분) \n \nUML 실체화 관계(Realization Relation) \n \n인터페이스와 실제 구현된 일반 클래스 간의 관계로 존재하는 행동에 대한 구현을 \n표현한다. \n한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계이다. \nex. 미사일 ㅡ▷ 날다 ◁ㅡ 비행기 \n \nUse Case Diagram \nUse Case Diagram 의 개념 \n \n객체지향 초반기 분석 작업에 작성되는 사용자의 요구를 기능적 측면에서 기술할 때 \n사용되는 도구로 Actor 와 User Case 로 구성된다. \n얻어지는 결과는 개발 대상 시스템이 제공해야 하는 서비스 목록이 된다. \nUse Case Diagram 요소 \n \n요소 \n설명"", '- 다양한 관점에서 의사소통할 수 있도록 View 를 제공한다. \n- 정적 모델 : 구조 다이어그램 \n- 동적 모델 : 행위 다이어그램 \n스테레토 타입 \n \nUML 에서 제공하는 기본 요소 외에 추가적인 확장 요소를 표현할 때 사용한다. \nUML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호는 쌍 꺾쇠와 비슷하게 \n생긴 길러멧(Guillemet) <<>>이며, 길러멧 안에 확장 요소를 적는다. \nUML 접근 제어자 \n \n접근제어자 \n표기 \n설명 \nPublice \n+ \n어떤 클래스의 객체에서든 접근 가능하다. \nPrivate \n- \n해당 클래스로 생성된 객체만 접근 가능하다. \nProtected \n# \n해당 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 \n객체들만 접근 가능하다. \nPackage \n~ \n동일 패키지에 있는 클래스의 객체들만 접근 가능하다. \n연관 관계 다중성 표현 \n \n표기 \n의미 \n1 \n1 개체 연결 \n* 또는 0..* 0 이거나 그 이상 객체 연결 \n1..* 1 이거나 1 이상 객체 연결 \n0..1 0 이거나 1 객체 연결 \n1,3,6 1 이거나 3 이거나 6 객체 연결 \nn \nn 개 객체 연결 \nn..* n 이거나 n 개 이상 객체 연결 \nUML 다이어그램의 분류 \n구조적 다이어그램(Structure Diagram) \n \n정적이고, 구조 표현을 위한 다이어그램이다. \n다이어그램 유형 \n목적 \n클래스 다이어그램(ClassDiagram) 시스템 내 클래스의 정적 구조를 표현하고 시스템을 \n구성하는 클래스들 사이의 관계를 표현한다. \n객체 다이어그램(Object Diagram) \n객체 정보를 보여준다. \n복합체 구조 다이어그램(Composite Structure Diagram) \n복합 구조의 클래스와 \n컴포넌트 내부 구조를 표현한다. \n배치 다이어그램(Deployment Diagram) 소프트웨어, 하드웨어, 네트워크를 포함한 실행 \n시스템의 물리 구조를 표현한다.', '팩토리 메소드 : 상위 클래스를 바탕으로 하위 클래스에서 구체화 \n프로토 타입 : 원본 객체를 복제해서 생성 (비용 저렴) \n싱글톤 : 클래스로 하나의 객체만 생성 \n(4) 구조패턴 : 클래스나 객체를 조합하여 더 큰 구조 만드는 패턴 \n어뎁터 : 호환되지 않는 클래스를 다른 클래스가 이용할 수 있게 변환 \n브리지 : 기능과 구현을 두 개의 별도 클래스로 구현 \n컴포지트 : 객체들을 트리 구조로 구성 \n프록시 : 접근이 어려운 객체 사이의 인터페이스 역할 수행 \n기타 : 데코레이터, 퍼싸드, 플라이웨이트 \n(5) 행위 패턴 : 객체들의 서로 상호작용 하는 방법 정의 \n커맨드 : 요청을 캡슐화해서 저장해둠 \n중재자(Medidator) : 상호작용을 캡슐화하여 객체로 정의 \n옵서버 : 한 객체의 상채가 면화하면 다른 객체들에게 전달 (이벤트) \n상태 : 상태에 따라 다르게 처리 \n전략 : 동일 계열 알고리즘을 개별적 캡슐화 (상호교환 가능) \n템플릿 메소드 : 상위 클래스는 골격정의, 하위 클래스는 세부 처리 \n방문자 : 처리 기능을 분리하여 별도의 클랴스로 \n기타 : 책임 연쇄, 인터프리터, 반복자(Iterator), 메멘토 \n3) 객체 지향 설계 원칙 (SOLID) \nSRP(Single Responsibility, 단일 책임) : 객체는 하나의 책임만 가져야함 \nOCP(Open-Closed, 개방-폐쇄) : 기존 코드 변경없이 기능 추가 가능해야 \nLSP(Liskov Substitution, 리스코프 치환)  \n: 자식 클래스는 부모 클래스의 행위를 할 수 있어야함 => 확장만 \nISP(Interface Segregation, 인터페이스 분리): 인터페이스 버전의 SPR \nDIP(Dependency Inversion, 의존 역전): 추상성이 높은 클래스를 의존', '상호작용(Interaction Use), 메시지(Messages), 활성(Activations), \n객체(Entitiy), Actor \n상호작용 개요 다이어그램 \n여러 상호작용 다이어그램 사이의 제어 흐름을 표현한다. \n통신 다이어그램(Communication Diagram) \n객체 사이의 관계를 중심으로 상호작용을 \n표현한다. \n타이밍 다이어그램(Timing Diagram) \n객체 상태 변화와 시간 제약을 명시적으로 \n표현한다. \n클래스 다이어그램 관계 표현 \nClass Diagram \n \n시스템을 구성하는 객체 간의 관계를 추상화한 모델을 논리적 구조로 표현한다. \n객체지향 개발에서 공통으로 사용된다. \n분석, 설계, 구현 단게 전반에 지속해서 사용된다.(사용: Operation : 클래스의 동작을 \n의미하며, 클래스에 속하는 객체에 대하여 적용될 메소드를 정의한 것) \nUML 관계 표현 \n \n구성 \n표시 \n설명 \n단방향 연관 관계 \nㅡ> \n한쪽은 알지만 반대쪽은 상대방 존재를 모름 \n양방향 연관 관계 \nㅡ \n양쪽 클래스 객체들이 서로의 존재를 인식 \n의존 관계 \n---> 연관 관계와 같지만 메소드를 사용할 때와 같이 매우 짧은 시간만 \n유지 \n일반화 관계 ㅡ▷ \n객체지향에서 상속 관계(IS-A)를 표현하며, 한 클래스가 다른 \n클래스를 포함하는 상위 개념일 때 사용 \n집합/포함 관계 \nㅡ◇ \n클래스 사이 전체나 부분 이 같은 관계 \nㅡ◆ \n전체/부분 객체 라이프타임 의존적(전체 객체 삭제->부분 객체 삭제) \n실체화 관계 ---▷ 책임 집합 인터페이스와 실제로 실현한 클래스들의 사이 \nUML 연관 관계(Association Relation) \n \n한 사물의 객체가 다른 사물의 객체와 연결된 것을 표현한다. \n두 클래스가 서로 연관이 있다면 A, B 객체를 서로 참조할 수 있음을 표현한다. \n이름 : 관계의 의미를 표현하기 위해 이름을 가질 수 있다. \n역할 : 수행하는 역할을 명시적으로 이름을 가질 수 있다.', '클래스(Class) 다이어그램 클래스 다이어그램은 시스템을 구성하는 클래스, 클래스 의 특성인 속성과 오퍼레이션, 속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 표현한 것이다. 클래스 다이어그램의 구성 요소 클래스 다이어그램은 클래스, 제약조건, 관계 등으로 구성된다.- 클래스는 각각의 객체들이 갖는 속성과 오퍼레 이션(동작)을 표현함- 일반적으로 3개의 구획(Compartment)으로 나눠 클래스(Class) 클래스의 이름, 속성, 오퍼레이션을 표기함- 속성(Attribute) : 클래스의 상태나 정보를 표현함- 오퍼레이션(Operation) : 클래스가 수행할 수 있 는 동작으로, 함수(메소드, Method)라고도 함 12 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 제약조건 수행 전후에 지정해야 할 조건이 있다면 이를 적음- 관계는 클래스와 클래스 사이의 연관성을 표현 함 관계- 클래스 다이어그램에 표현하는 관계에는 연관 (Relationships) 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계가 있음 2401']"
12,Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정 기법은?,"[""Putnam 모형"", ""델파이 모형"", ""COCOMO 모형"", ""기능점수 모형""]",1,1,소프트웨어 설계,정보시스템 구축 관리,"Putnam 모형은 Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정 기법입니다. Putnam 모형은 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 가정해 주는 모형으로, 대형 프로젝트의 노력 분포 산정에 이용되는 기법입니다. 
과목: 정보시스템 구축 관리","['COCOMO Model 중 기관 내부에서 개발된 중소규모의 · 소프트웨어 로 일괄 자료 처리나 과학기술 계산용 , 비즈니스 자료 처리용으로 5 만 라인 이하의 소프트웨어를 개발하는 유형은 ?\n\n[보기]\n1) Embeded\n2) Organic\n3) Semi-Detached\n4) Semi-Embeded', 'EAI(Enterprise Application Integration) 의 구축유형에 대한 설명으로 틀린 것은?\n\n[보기]\n1) Point-to-Point 는 가장 기본적인 애플리케이션 통합 방식으로 , 애플리케이션을1 :1 로 연결한다 .\n2) Hub&Spoke 는 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식이다.\n3) 애플리케이션 사이에 미들웨어를 두어 처리하는 방식은 ESB이다.\n4) Hybrid 는 Point-to-Point 와 Hub&Spoke 의 혼합 방식이다 .', '관계 데이터 모델에서 릴레이션(Relation)에 포함되어 있는 튜플(Tuple)의 수를 무엇이라고 하는가?\n\n[보기]\n1) Degree\n2) Cardinality\n3) Attribute\n4) Cartesian product', '소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.\n2) 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.\n3) 관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.\n4) 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.', '소프트웨어 개발 방법론의 테일러링 (Tailoring) 과 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.\n2) 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차 , 산출물 등을 적절히 변경하는 활동이다.\n3) 관리 측면에서의 목적 중 하나는 최단 기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.\n4) 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.', '자동화 추정 도구- SLIM Rayleigh- Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구이다. 기능 점수(FP) 모형-', '자동화 추정 도구- SLIM Rayleigh- Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구이다. 기능 점수(FP) 모형-', '비용 산정 기법- Putnam 모형- 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 가정해 주는 모형이다.- Rayleigh- Norden 곡선의 노력 분포도를 기초로 한다.', '비용 산정 기법- Putnam 모형- 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 가정해 주는 모형이다.- Rayleigh- Norden 곡선의 노력 분포도를 기초로 한다.', 'Putnam 모형 Putnam 모형은 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 가정해 주는 모형이다.- 푸트남(Putnam)이 제안한 것으로 생명 주기 예측 모형 이라고도 한다.- 시간에 따른 함수로 표현되는 Rayleigh- Norden 곡선 의 노력 분포도를 기초로 한다.- 대형 프로젝트의 노력 분포 산정에 이용되는 기법이다.- 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소한다. 2417']"
13,애자일 (Agile) 프로세스 모델에 대한 설명으로 틀린 것은 ?,"[""변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다."", ""프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다."", ""협상과 계약보다는 고객과의 협력을 중시한다."", ""문서 중심이 아닌 , 실행 가능한 소프트웨어를 중시한다 .""]",1,1,소프트웨어 설계,소프트웨어 설계,"애자일(Agile) 프로세스 모델은 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정을 진행하는 방법론입니다. 애자일 모형의 핵심 가치에는 ""변화에 대한 대응""이 포함되어 있습니다. 따라서, ""변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.""는 애자일 프로세스 모델에 대한 설명으로 틀린 것입니다.

과목: 소프트웨어 설계

이유:
- 애자일 프로세스 모델은 변화에 대응하는 것을 중요시합니다. 
- ""변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.""는 전통적인 폭포수 모델이나 계획 기반의 접근 방식에 더 가깝습니다. 
- 애자일 선언문에는 ""계획을 따르는 것보다 변경에 대한 응답이 더 중요하다.""라는 원칙이 있습니다. 
- 따라서, 보기 1은 애자일 프로세스 모델에 대한 설명으로 틀린 것입니다.","['객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?\n\n[보기]\n1) Coad 와 Yourdon 방법\n2) Booch 방법\n3) Jacobson 방법\n4) Wirfs-Brocks 방법', '소프트웨어 재공학의 주요 활동 중 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업을 의미하는 것은?\n\n[보기]\n1) Analysis\n2) Migration\n3) Restructuring\n4) Reverse Engineering', '보헴이 제안한 것으로, 위험 분석 기능이 있으며, 여러 번의 개발과정을 거쳐 점진적으로 개발하는 모형은?\n\n[보기]\n1) 나선형 모형\n2) 애자일 모형\n3) 프로토타입 모형\n4) 폭포수 모형', '좋은 소프트웨어 설계를 위한 소프트웨어의 모듈간의 결합도(Coupling)와 모듈 내 요소 간 응집도(Cohesion)에 대한 설명으로 옳은 것은?\n\n[보기]\n1) 응집도는 낮게 결합도는 높게 설계한다.\n2) 응집도는 높게 결합도는 낮게 설계한다.\n3) 양쪽 모두 낮게 설계한다.\n4) 양쪽 모두 높게 설계한다.', '소프트웨어 재공학의 주요 활동 중 기존 소프트웨어를 다른 운영체제 나 하드웨어 환경에서 사용할 수 있도록 변환하는 것은?\n\n[보기]\n1) 역공학\n2) 분석\n3) 재구성\n4) 이식', 'FDD(Feature Driven Development, 기능 중심 개발) \nCrystal \nASD(Adaptive Software Development, 적응형 소프트웨어 개발방법론) \nDAD(Disciplined Agile Delivery, 학습 애자일 배포) \nAgile 선언문 \n \n프로세스나 도구보다 개인과의 소통이 더 중요하다. \n완벽한 문서보다 실행되는 소프트웨어가 더 중요하다. \n계약 협상보다 고객과의 협업이 더 중요하다. \n계획을 따르는 것보다 변경에 대한 응답이 더 중요하다. \nXP(eXtreme Programming) \nXP(eXtreme Programming) \n \n1999 년 Kent Beck 이 제안하였으며, 개발 단계 중 요구사항이 시시각각 변동이 심한 \n경우 적합한 방법론이다. \n요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 한다. \n요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 \n적용하는 방식으로 예측성보다는 적응성에 더 높은 가치를 부여한 방법이다. \n고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법이다. \nXP 핵심 가치 \n \n소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향한다. \n단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다. \nFeedback : 소프트웨어 개발에서 변화는 불가피하다. 이러한 변화는 지속적 테스트와 \n통합, 반복적 결함 수정 등 빠르게 피드백한다. \n용기(Courage) : 고객 요구사항 변화에 능동적으로 대응한다. \n존중(Respect) : 개발 팀원 간의 상호 존중을 기본으로 한다. \nXP Process \n \n용어 \n설명 \nUser Story 일종의 요구사항으로 UML 의 유즈케이스와 같은 목적으로 생성되나, 형식이 \n없고 고객에 의해 작성된다는 것이 다르다. \nRelease Planning 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을', '애자일 모형(Agile Model) 애자일은 ‘민첩한’, ‘기민한’이라는 의미로, 고객의 요구사 항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복 하면서 개발과정을 진행한다.- 애자일 모형은 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭한다.- 애자일 모형은 기업 활동 전반에 걸쳐 사용된다.- 애자일 모형을 기반으로 하는 소프트웨어 개발 모형에 는 스크럼(Scrum), XP(eXtreme Programming), 칸반 (Kanban), Lean, 크리스탈(Crystal), ASD(Adaptive Software Development), 기능 중심 개발(FDD; Feature Driven Development), DSDM(Dynamic System Development Method), DAD(Disciplined Agile Delivery) 등이 있다. 2400', '- 정의: 소프트웨어를 개발하기 위한 과정 (요구사항 분석, 설계, 개발, 유지보수 등) | 모델:  - 이름: 폭포수 모형 | 특징: 이전 단계로 돌아갈 수 없음, 앞단계가 끝나야 다음단계로 넘어감 (병행X)  - 이름: 프로토타입 모형 | 특징: 프로토타입(견본)을 만들어 최종 결과물을 예측, 새로운 요구사항 반영 가능  - 이름: 나선형 모형 | 특징: 여러 번의 소프트웨어 개발과정 반복, 위험 관리 중심, 요구사항 첨가 가능  - 이름: 애자일 | 특징: 고객과의 소통에 초점, 스프린트/이터레이션 반복, 요구사항 변화에 유연 대응 | 종류:  - 스크럼  - XP  - 기능 중심 개발(FDD)', '경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 방법, 도구와 절차들의 체계를 말한다. \nIEEEE(전기/전자기술협회)는 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 \n접근 방법이라 정의하였다. \n소프트웨어 공학의 기본 원칙 \n \n현대적인 프로그래밍 기술을 적용해야 한다. \n신뢰성이 높아야 한다. \n사용의 편리성과 유지보수성이 높아야 한다. \n지속적인 검증 시행을 해야 한다. \n소프트웨어 공학 계층 구조 \n \n도구 : 프로세스와 방법을 처리하는 기능을 제공하는 것이다. \n방법론 : 소프트웨어를 설계하는데 기술적인 방법을 제공하는 것이다. \n프로세스 : 소프트웨어의 가장 기초가 되며 개발에 사용되는 방법론과 도구가 적용되는 \n순서를 의미한다. \n소프트웨어 품질 \n \n사용자의 요구대로 만들어져야 한다. \n유지보수가 쉬워야 한다. \n에러를 최소화해야 한다. \n초반에 정한 비용에 맞춰 개발해야 한다. \n정확한 결과가 도출되어야 한다. \n원하는 시간에 원하는 기능을 수행할 수 있어야 한다. \n소프트웨어 공학의 목표 \n \n소프트웨어의 생산성과 품질을 향상시킨다. \n최소의 비용으로 단기간에 시스템에 적합한 소프트웨어를 개발하는 것이 소프트웨어 공학의 \n궁극적 목적이다. \n2. 재공학 \n재공학 \n소프트웨어 재공학(Software Reengineering)의 개념 \n \n소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법을 \n의미한다. \n현재의 시스템을 변경하거나 재구조화(Restructuring)하는 것이다. \n재구조화는 재공학의 한 유형으로 사용자의 요구사항이나 기술적 설계의 변경 없이 \n프로그램을 개선하는 것이다. \n소프트웨어 재공학 관점에서 가장 연관 깊은 유지보수 유형은 예방 유지보수(Preventive \nMaintenance)이다. \n재공학의 장점, 목표, 과정 \n \n장점 \n \n개발 시간 및 비용 감소 \n품질 향상 \n생산성 향상 \n신뢰성 향상 \n구축 방법에 대한 지식의 공유 \n프로젝트 실패 위험 감소 \n목표', '소프트웨어 패키징의 개요 소프트웨어 패키징이란 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것을 말한다.- 개발자가 아니라 사용자를 중심으로 진행한다.- 소스 코드는 향후 관리를 고려하여 모듈화하여 패키징 한다.- 사용자가 소프트웨어를 사용하게 될 환경을 이해하여, 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도 록 일반적인 배포 형태로 패키징한다. 2404']"
14,객체지향 소프트웨어 설계 시 디자인 패턴을 구성하는 요소로서 가장 거리가 먼 것은?,"[""실제 적용된 사례"", ""문제 및 배경"", ""개발자의 성명"", ""재사용 가능한 샘플코드""]",3,4,소프트웨어 설계,소프트웨어 설계,"디자인 패턴은 객체지향 소프트웨어 설계 시 사용되는 전형적인 해결 방식 또는 예제를 의미합니다. 디자인 패턴의 구성 요소에는 패턴의 이름, 문제 및 배경, 해법, 결과 등이 필수 요소로 포함됩니다. 추가적인 요소로는 알려진 사례, 샘플 코드 등이 있습니다. 따라서, 보기 중에서 '개발자의 성명'은 디자인 패턴을 구성하는 요소로서 가장 거리가 먼 것입니다.
과목: 소프트웨어 설계","['COCOMO Model 중 기관 내부에서 개발된 중소규모의 · 소프트웨어 로 일괄 자료 처리나 과학기술 계산용 , 비즈니스 자료 처리용으로 5 만 라인 이하의 소프트웨어를 개발하는 유형은 ?\n\n[보기]\n1) Embeded\n2) Organic\n3) Semi-Detached\n4) Semi-Embeded', 'COCOMO Model 중 기관 내부에서 개발된 중소 · 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용 , 비즈니스 자료 처리용으로 5 만 라인 이하의 소프트웨어를 개발하는 유형은 ?\n\n[보기]\n1) Embeded\n2) Organic\n3) Semi-Detached\n4) Semi-Embeded', '소프트웨어 개발에서 모듈(Module)이 되기 위한 주요 특징에 해당하지 않는 것은?\n\n[보기]\n1) 다른 것들과 구별될 수 있는 독립적인 기능을 가진 단위(Unit)이다.\n2) 독립적인 컴파일이 가능하다.\n3) 유일한 이름을 가져야 한다.\n4) 다른 모듈에서의 접근이 불가능해야 한다.', '소프트웨어 생명주기 모형에서 프로토타입 모형의 장점이 아닌 것은?\n\n[보기]\n1) 단기간 제작 목적으로 인하여 비효율적인 언어나 알고리즘을 사용할 수 있다.\n2) 개발과정에서 사용자의 요구를 충분히 반영한다.\n3) 최종 결과물이 만들어지기 전에 의뢰자가 최종결과물의 일부 혹은 모형을 볼 수 있다.\n4) 의뢰자나 개발자 모두에게 공동의 참조 모델을 제공한다.', 'S/W 각 기능의 원시 코드 라인수의 비관치 , 낙관치 , 기대치를 측정하 여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?\n\n[보기]\n1) Effort Per Task 기법\n2) 전문가 감정 기법\n3) 델파이기법\n4) LOC 기법', '1과목: 소프트웨어 설계\n\nⅠ 소프트웨어 생명주기 : 그래서 소프트웨어를 어떤 과정으로 개발한다는거야?  \n1) 소프트웨어 생명 주기 (소프트웨어 수명 주기) \n정의 : 소프트웨어를 개발하기 위한 과정 (요구사항 분석, 설계, 개발, 유지보수 등) \n종류 : 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 \n(1) 폭포수 모형 (고전적 생명 주기 모형) \na. 이전 단계로 돌아갈 수 없음 => 앞단계가 끝나야 다음단계로 넘어감 (병행X) \n(2) 프로토타입 모형 (원형 모형) \na. 프로토타입(견본)을 만들어 최종 결과물을 예측 \nb. 새로운 요구사항이 도출될 때마다 프로토타입 구축 => 새로운 요구사항 반영 OK  \n(3) 나선형 모형 (점진적 모형) \na. 여러 번의 소프트웨어 개발과정 (계획-> 분석-> 개발-> 평가)의 반복 \nb. 위험 관리 중심, 요구사항 첨가 가능, 유지보수 필요X \n(4) 애자일 \na. 고객과의 소통에 초점을 맞춘 개발 방법론 \nb. 스프린트 또는 이터레이션같은 짧은 개발 주기를 반복 -> 테스트 \n=> 고객의 요구사항 변화에 유연하게 대응 가능 \nc. 애자일 모형의 종류 : 스크럼, XP, 기능 중심 개발(FDD) \n폭포수 모형 \n애자일 \n새로운 요구사항 반영 \n어려움 \n지속적으로 반영 \n고객과 의사소통 \n적음 \n지속적 \n테스트 \n마지막에 모든 기능 \n테스트 \n반복적으로 테스트 \n개발 중심 \n계획, 문서(메뉴얼) \n고객 \nd. XP 기법 \n이터레이션(짧은 개발-피드백 단위) 반복  \n핵심가치 : 피드백, 존중, 용기, 단순성, 소통 (피존용 단소) \n주요 실천 방법 : 짝 프로그래밍(함께 프로그래밍 수행),  \n코드 공동 소유 (권한과 책임의 공동 소유),  \n테스트 주도 개발, 전체 팀 (모두가 각자의 역할이 있다!) \nⅠ UML : 개발 과정에서 의사소통은 어떻게해? \n1, UML \n\uf02d 정의 : 의사 소통이 원활하게 이루어지도록 표준화한 객체 지향 모델링 언어 \n\uf02d 구성 요소 : 사물, 관계, 다이어그램', '자주 사용하는 설계 형태를 정형화하여 유형별로 설계 템플릿을 만들어 두고 소프트웨어 \n개발 중 나타나는 과제를 해결하기 위한 방법 중 한 가지다. \n다양한 응용 소프트웨어 시스템들을 개발할 때 서로 간에 공통점이 있으며, 이러한 \n유사점을 패턴이라 한다. \n개발자 간 원활한 의사소통, 소프트웨어 구조 파악 용이, 설계 변경에 대한 유연한 대처, \n개발의 효율성, 유지보수성, 운용성 등 소프트웨어 품질 향상에 도움을 준다. \n객체지향 프로그래밍 설계 시 유사한 상황에서 구조적인 문제를 해결할 수 있도록 방안을 \n제공해주며, Gof(Gang of Four) 분류가 가장 많이 사용된다. \n디자인 패턴을 사용할 때의 장/단점 \n \n장점 \n \n개발자 간의 월활한 의사소통을 지원한다. \n소프트웨어 구조 파악이 쉽다. \n재사용을 통한 개발 시간을 단축할 수 있다. \n설계 변경 요청에 대해 유연하게 대처할 수 있다. \n객체지향 설계 및 구현의 생산성을 높이는 데 적합하다. \n단점 \n \n객체지향 설계/구현 위주로 사용된다. \n초기 투자 비용이 부담된다. \n디자인 패턴의 구성 요소 \n \n필수 요소 \n \n패턴의 이름 : 패턴을 부를 때 사용하는 이름과 패턴의 유형 \n문제 및 배경 : 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미 \n해법 : 패턴을 이루는 요소들, 관계, 협동(Collaboration) 과정 \n결과 : 패턴을 사용하면 얻게 되는 이점이나 영향 \n추가 요소 \n \n알려진 사례 : 간단한 적용 사례 \n샘플 코드 : 패턴이 적용된 원시 코드 \n원리, 정당성, 근거 \nGoF(Gangs of Four) 디자인 패턴 \n \n에릭 감마, 리처드 헬름, 랄프 존슨, 존 브리시데스가 제안 \n객체지향 설계 단계 중 재사용에 관한 유용한 설계를 디자인 패턴화하였다. \n생성 패턴, 구조 패턴, 행위 패턴으로 분류한다. \n생성 패턴 \n \n객체를 생성하는 것과 관련된 패턴이다. \n객체의 생성과 변경이 전체 시스템에 미치는 영향은 최소화하도록 만들어주어 유연성을', '객체 간의 혼란스러운 의존 관계들을 줄일 수 있는 행동 디자인 패턴 \n패턴은 객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 협력하도록 함. \n디자인 패턴 vs 아키텍처 패턴 \n \n아키텍처 패턴이 상위 설계에 이용된다. \n아키텍쳐 패턴 : 시스템 전체 구조를 설계하기 위한 참조 \n디자인 패턴 : 서브 시스템 내 컴포넌트와 그들 간의 관계를 구성하기 위한 참조 모델 \n17. 인터페이스 요구사항 확인 \n인터페이스 요구사항 \n인터페이스 내/외부 요구사항 \n \n개발 대상 조직 내/외부의 시스템 연동을 통하여 상호작용을 위한 접속 방법, 규칙을 \n의미한다. \n인터페이스 요구사항 구성 \n \n요구사항의 구성, 내/외부 인터페이스 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 \n방식, 송신 데이터, 인터페이스 주기, 기타 고려사항 \n인터페이스 요구사항의 분류 \n \n기능적 요구사항 : 소프트웨어가 내/외부 시스템 간의 연계를 통하여 수행될 기능과 \n관련하여 가져야 하는 기능적 속성에 대한 요구사항이다. \n비기능적 요구사항 : 기능에 관련되지 않는 사항으로 기능 요구사항을 만족시키는 바탕에서 \n정상적으로 작동하기 위한 시스템 내/외부의 제약 조건을 의미한다. \n인터페이스 요구사항 명세서 \n \n예시 \n \n요구사항 분류 시스템 인터페이스 요구사항 \n요구사항 번호 AAA-MOCK001 \n요구사항 명칭 소셜로그인 연동 \n요구사항 상세 설명 정의 \n네이버 아이디로 회원 연동 \n세부 내용 \n- 네이버 아이디 서비스인 네아로 API 를 이용하여 MOCK 사이트 회원 가입에 \n활용할 수 있도록 한다. \n- MOCK 사이트 네아로 서비스 아이디가 네이버에 전달되고, API 를 통하여 회원 정보를 \n가져온다. \n- 예상 트랜잭션 : 일 1,000 건 \n<추가 정의 내용> \n- 네이버 회원 정보 중 이름, 닉네임, 이메일, 전화번호를 가져온다. \n- 네아로 서비스를 통하여 회원 가입할 때 회원 아이디를 ""NAVER_""로 시작하도록 하여 \n구분한다. \n산출 정보', ""(Design Pattern)의 개요 디자인 패턴은 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구 현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.- 디자인 패턴은 문제 및 배경, 실제 적용된 사례, 재사용 이 가능한 샘플 코드 등으로 구성되어 있다.- ‘바퀴를 다시 발명하지 마라(Don't reinvent the wheel)’라는 말과 같이, 개발 과정 중에 문제가 발생하 면 새로 해결책을 구상하는 것보다 문제에 해당하는 디 자인 패턴을 참고하여 적용하는 것이 더 효율적이다.- GoF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다. 2402"", '기술, 마이크로 기구 설계, 사용성 평가 기술 및 가상현실 기술 \n11. 소프트웨어 설계 모델링 \n소프트웨어의 설계(Design) \n소프트웨어 설계 모델링 \n \n정의 : 요구사항(기능, 성능)을 만족하는 소프트웨어의 내부 구조 및 동적 행위들을 \n모델링하여 표현하고, 분석 검증하는 과정이며 이 과정에서 만들어지는 산출물을 의미한다. \n목적 : ""무엇을(What)"" 으로부터 ""어떻게(How)""로 관점을 전환하면서 최종 제작할 \n소프트웨어의 청사진을 만드는 것을 의미한다. \n소프트웨어 설계 \n \n본격적인 프로그램의 구현에 들어가기 전에 소프트웨어를 구성하는 뼈대를 정의해 구현의 \n기반을 만드는 것을 의미하며 상위 설계(High-Level Design)와 하위 설계로 구분된다. \n설계의 기본 원리 \n \n분할과 정복, 추상화, 단계적 분해, 모듈화, 정보 은닉 \n소프트웨어 설계 분류 \n \n설계 \n상위 설계 \n아키텍처 설계 \n데이터 설계 \n인터페이스 정의 \n사용자 인터페이스 설계 \n하위 설계 \n모듈 설계 \n자료 구조 설계 \n알고리즘 설계 \n상위 설계(High-Level Design) \n \n아키텍처 설계(Architecture Design), 예비 설계(Preliminary Design)라고 하며 \n전체 골조(뼈대)를 세우는 단계이다. \n아키텍처(구조) 설계 : 시스템의 전체적인 구조 \n데이터 설계 : 시스템에 필요한 정보를 자료 구조/데이터베이스 설계에 반영 \n시스템 분할 : 전체 시스템을 여러 개의 서브 시스템으로 분리 \n인터페이스 설계 : 시스템의 구조와 서브 시스템들 사이의 관계 \n사용자 인터페이스 설계 : 사용자와 시스템의 관계 \n하위 설계(Low_Level Design) \n \n모듈 설계(Module Design), 상세 설계(Detail Design)라고 하며, 시스템 각 구성 \n요소들의 내부 구조, 동적 행위 등을 결정하여 각 구성 요소의 제어와 데이터 간의 연결에 \n대한 구체적인 정의를 하는 단계이다.']"
15,아키텍처 설계 과정이 올바른 순서로 나열된 것은 ?,"[""㉮ → ㉯ → ㉰ → ㉱ → ㉲"", ""㉲ → ㉮ → ㉯ → ㉱ → ㉰"", ""㉮ → ㉲ → ㉯ → ㉱ → ㉰"", ""㉮ → ㉯ → ㉰ → ㉲ → ㉱""]",1,3,소프트웨어 설계,소프트웨어 설계,"아키텍처 설계 과정은 다음과 같은 순서로 진행됩니다.

1.  설계 목표 설정: 시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정합니다.
2.  시스템 타입 결정: 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택합니다.
3.  아키텍처 패턴 적용: 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계합니다.
4.  서브시스템 구체화: 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의합니다.
5.  검토: 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계의 기본 원리를 만족하는지 등을 검토합니다.

따라서, 올바른 순서는 ㉮ → ㉲ → ㉯ → ㉱ → ㉰ 입니다.

과목: 소프트웨어 설계","['객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?\n\n[보기]\n1) Coad 와 Yourdon 방법\n2) Booch 방법\n3) Jacobson 방법\n4) Wirfs-Brocks 방법', '3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가1, 2,1,0,4,1,3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?\n\n[보기]\n1) 1,2,0\n2) 2,4,3\n3) 1,4,2\n4) 4,1,3', '보헴이 제안한 것으로, 위험 분석 기능이 있으며, 여러 번의 개발과정을 거쳐 점진적으로 개발하는 모형은?\n\n[보기]\n1) 나선형 모형\n2) 애자일 모형\n3) 프로토타입 모형\n4) 폭포수 모형', '객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?\n\n[보기]\n1) 메시지(Message)\n2) 캡슐화(Encapsulation)\n3) 다형성(Polymorphism)\n4) 상속(Inheritance)', '객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?\n\n[보기]\n1) 메시지(Message)\n2) 캡슐화 (Encapsulation)\n3) 다형성(Polymorphism)\n4) 상속(Inheritance)', '설계 과정 ❶ 설계 목표 설정 : 시스템의 개발 방향을 명확히 하기 위 해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정 함 ❷ 시스템 타입 결정 : 시스템과 서브시스템의 타입을 결정 하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선 택함 ❸ 아키텍처 패턴 적용 : 아키텍처 패턴을 참조하여 시스템 의 표준 아키텍처를 설계함 ❹ 서브시스템 구체화 : 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의함 ❺ 검토 : 아키텍처가 설계 목표에 부합하는지, 요구사항 이 잘 반영되었는지, 설계의 기본 원리를 만족하는지 등을 검토함 정보처리기사 필기 요약 2459', '추상화: 전체적이고 포괄적인 개념 설계 후 구체화 \n=> 유형 : 제어 추상화, 과정 추상화, 자료(데이터) 추상화 (제과자)  \n단계적 분해: 하향식 설계 (상위 중요 개념 -> 하위 개념) \n정보 은닉 : 모듈 내의 데이터나 기능에 다른 모듈이 접근하지 못하도록 \n모듈화 : 시스템이 모듈 단위로 분해되어야함 \na. 모듈: 시스템의 기능적 단위 \nb. 팬인(입력)은 높게, 팬아웃(출력)은 낮게!  \nc. 약한 결합도, 강한 응집도 필요 (표의 위일수록 좋은거) \n결합도 : 모델 사이의 의존정도 \n응집도 : 내부요소들의 관련 정도 \n자료 결합도: 자료를 주고받음 \n기능적 응집: 전 기능이 단일 문제와 관련 \n스탬프 결합도: 자료구조를 주고받음 \n순차적 응집 : A->B 순차적 수행 \n제어 결합도: 다른 모듈의 흐름 제어 \n교환(통신)적 응집 : 동일 입력 다른 기능 \n외부 결합: 모듈의 데이터를 외부에서 참\n조 \n절차적 응집 : 순차가 많음 \n공통 결합도 : 공통 데이터 영역 사용 \n시간적응집: 특정 시간에 필요한 기능 모음 \n내용 결합도 : 기능이나 자료를 직접 참조 \n논리적 응집 : 유사한 성격의 기능 모음 \n우연적 응집 : 관련 X \n(4) 아키텍처 패턴 : 전형적인 소프트웨어 아키텍처 설계 방법 \n파이프-필터 : 데이터 흐름(스트림)의 각 단계별로 캡슐화(묶어서 관리) \n모델-뷰-컨트롤러 : \na. 모델 : 핵심기능과 데이터보관 \nb. 뷰 : 사용자게 정보 표시 \nc. 컨트롤러 : 사용자의 요청을 처리하기 위해 모델에게 명령 \n마스터-슬레이브 : 동일한 구조의 슬레이브 컴포넌트들이 작업을 분할 수행 \n2) 디자인 패턴 \n(1) 정의 : 모듈의 역할, 모듈 간 인터페이스같은 세부적인 구현 방안 설계시의 패턴 \n(2) 종류 : 생성 패턴, 구조 패턴, 행위 패턴 \n(3) 생성 패턴 : 객체의 생성과 관련된 패턴 \n추상팩토리 : 인터페이스를 조합해 객체 생성 \n빌더 : 다른 객체를 조합해서 객체 생성', '현행 시스템 파악 절차 \n \n1 단계(시스템 구성 파악 - 시스템 기능 파악 - 시스템 인터페이스 현황 파악) \n2 단계(아키텍처 파악 - 소프트웨어 구성 파악) \n3 단계(시스템 하드웨어 현황 파악 - 네트워크 구성 파악) \n시스템 아키텍처 \n \n시스템 내의 상위 시스템과 하위 시스템들이 어떠한 관계로 상호작용하는지 각각의 동작 \n원리와 구성을 표현한 것이다. \n단위 업무 시스템별로 아키텍처가 다른 경우 핵심 기간 업무 처리 시스템을 기준으로 한다. \n시스템의 전체 구조, 행위, 그리고 행위 원리를 나타내며 시스템이 어떻게 작동하는지 \n설명하는 틀이다. \n시스템의 목적 달성을 위해 시스템에 구성된 각 컴포넌트를 식별하고 각 컴포넌트의 \n상호작용을 통하여 어떻게 정보가 교환되는지 설명한다. \n시스템 아키텍처 ↔ 소프트웨어 아키텍처 => 소프트웨어 상세 설계 \n \n시스템 및 인터페이스 현황 파악 \n시스템 구성 파악 \n \n조직 내의 주요 업무를 기간 업무와 지원 업무로 구분하여 기술한다. \n모든 단위 업무를 파악할 수 있도록 하며, 시스템 내의 명칭, 기능 등 주요 기능을 \n명시한다. \n시스템 구성 현황 작성 예 \n구분 \n시스템명 \n시스템 내용 \n기간 업무 \n단위 A 업무 기간 단위 업무 A 처리를 위한 A1, A2 등의 기능을 제공 \n단위 B 업무 기간 단위 업무 B 처리를 위한 B1, B2 등의 기능을 제공 \n지원 업무 \n지원 C 업무 지원 업무 C 처리를 위한 C1, C2 등의 기능을 제공 \n시스템 기능 파악 \n \n단위 업무 시스템이 현재 제공하고 있는 기능을 주요 기능과 하부 기능으로 구분하여 \n계층형으로 표시한다. \n시스템 기능 파악 예 \n시스템명 \n기능 L1 \n기능 L2 \n기능 L3 \nA 단위 업무 시스템 기능 1 하부 기능 11 세부 기능 111 \n세부 기능 112 \n하부 기능 12 세부 기능 121 \n세부 기능 122 \n기능 2 하부 기능 21 세부 기능 211 \n세부 기능 212 \n인터페이스 현황 파악', '간략성 : 이해하고 추론할 수 있을 정도로 간결해야 한다. \n추상화 : 시스템의 추상적인 표현을 사용한다. \n가시성 : 시스템이 포함해야 하는 것들을 가시화해야 한다. \n복잡도 관리 종류 : 과정 추상화, 데이터 추상화, 제어 추상화 \nSoftware Architecture 평가 기준 \n \n시스템은 어떻게 모듈로 구성되는가? \n시스템은 실행 시에 어떻게 행동하고 연결되는가? \n시스템은 어떻게 비 소프트웨어 구조(CPU, 파일 시스템, 네트워크, 개발팀 등)와 관계하고 \n있는가? \n아키텍처 프레임워크 구성 요소 \n \n프레임워크(FrameWork) : 복잡한 소프트웨어 문제를 해결하거나 서술하는데 필요한 기본 \n구조를 제공함으로써 재사용이 가능하게 해준다. \n요소 \n설명 \nArchitecture Description(AD) - 아키텍처를 기록하기 위한 산출물이다. \n- 하나의 AD 는 System 의 하나 이상의 View 로 구성한다. \n이해관계자(Stakeholder) 소프트웨어 시스템 개발에 관련된 모든 사람과 조직을 \n의미하며, 고객, 개발자, 프로젝트 관리자 등을 포함한다. \n관심사(Concerns) 같은 시스템에 대해 서로 다른 이해관계자의 의견이다. \nex. 사용자 입장 : 기본 기능 + 신뢰성/보안성 요구 \n관점(View point) 서로 다른 역할이나 책임으로 시스템이나 산출물에 대한 서로 다른 \n관점이다. \n뷰(View) \nView: 이해관계자들과 이들이 가지는 생각이나 견해로부터 전체 시스템을 \n표현(4+1 View)한다. \n소프트웨어 아키텍처 4+1 View Model \n \nKruchten 에 의해 Object 표기법을 사용하다가 1995 년 Booch 의 UML 이 정의되면서 \nBooch 표기법을 포함하여 4+1 이 되었다. \n다양하고 동시적인 View 를 기반으로 소프트웨어 위주 시스템의 아키텍처를 묘사하는 View \n모델이다. \n복잡한 소프트웨어 아키텍처를 다양한 이해관계자들이 바라보는 관점으로, 다양한 측면을', '요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 한다. \n정해진 시간을 철저히 지켜야 하며, 완료된 모든 작업은 제품 백로그에 기록된다. \n가장 기본적인 정보 교환 수단은 일일 스탠드 업 미팅, 또는 일일 스크럼이다. \nSCRUM 팀의 역할 \n \n담당자 역할 \n제품 책임자(Product Owner) \n- 개발 목표에 이해도가 높은 개발 의뢰자, 사용자가 \n담당한다. \n- 제품 요구사항을 파악하여 기능 목록(Product Backlog)을 작성한다. \n- 제품 테스트 수행 및 요구사항 우선순위를 갱신한다. \n- 업무 관점에서 우선순위와 중요도를 표시하고 신규 항목을 추가한다. \n- 스프린트 계획 수립까지만 임무를 수행한다. \n- 스프린트가 시작되면 팀 운영에 관여하지 않는다. \n스크럼 마스터 - 업무를 배분만 하고 일은 강요하지 않으며 팀을 스스로 조직하고 \n관리하도록 지원한다. 개발 과정 장애 요소를 찾아 제거한다. \n- 개발 과정에서 스크럼의 원칙과 가치를 지키도록 지원한다. \nSCRUM 과정 \nProduct Backlog \n \n제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록이다. \n개발 과정에서 새롭게 도출되는 요구사항으로 인해 지속해서 업데이트된다. \n제품 백로그에 작성된 사용자 스토리를 기반으로 전체 일정 계획인 릴리즈 계획을 \n수립한다. \nSprint \n \n작은 단위의 개발 업무를 단기간에 전력 질주하여 개발한다는 의미로 반복 \n주기(2~4 주)마다 이해 관계자에게 일의 진척도를 보고한다. \nSprint Planning Meeting \n \nProduct Backlog(제품 기능 목록)에서 진행할 항목을 선택한다. \n선택한 Sprint 에 대한 단기 일정을 수립하고, 요구사항을 개발자들이 나눠 작업할 수 \n있도록 Task 단위로 나눈다. \n개발자별로 Sprint Backlog 를 작성하고 결과물에 대한 반복 완료 시 모습을 결정한다.']"
16,"클래스 (Class) 에 대한 다음 설명에서 괄호 ( ㉠ , ㉡ ) 에 들어갈 알맞은 용어는?","[""㉠ - 제약조건 , ㉡ - 속성"", ""㉠ - 속성 , ㉡ - 오퍼레이션"", ""㉠ - 오퍼레이션 , ㉡ - 제약조건"", ""㉠ - 속성 , ㉡ - 관계""]",2,2,소프트웨어 설계,소프트웨어 설계,"클래스(Class)는 객체지향 프로그래밍에서 객체를 정의하는 틀입니다. 클래스는 속성과 오퍼레이션으로 구성됩니다. 
속성(Attribute)은 클래스의 상태나 정보를 표현하며, 오퍼레이션(Operation)은 클래스가 수행할 수 있는 동작으로, 함수(메소드, Method)라고도 합니다. 
또한, 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적습니다. 
따라서, ㉠은 속성, ㉡은 오퍼레이션입니다.
과목: 소프트웨어 설계","['다음 내용이 설명하는 접근 제어 모델은 ? ㆍ군대의 보안 레벨처럼 정보의 기밀성에 따라 상하 관계가 구분된 정보를 보호하기 위해 사용 ㆍ자신의 권한보다 낮은 보안 레벨 권한을 가진 경우에는 높은 보안 레벨의 문서를 읽을 수 없고 자신의 권한보 다 낮은 수준의 문서만 읽을 수 있다. ㆍ자신의 권한보다 높은 보안 레벨의 문서에는 쓰기가 가능하지만 보안 레벨이 낮은 문서의 쓰기 권한은 제한한다.\n\n[보기]\n1) Clark-Wilson Integrity Model\n2) PDCA Model\n3) Bell-Lapadula Model\n4) Chinese Wall Model', '테이블 두 개를 조인하여 뷰 V_1을 정의하고, V_1을 이용하여 뷰 V_2를 정의하였다. 다음 명령 수행 후 결과로 옳은 것은?\n\n[보기]\n1) V_1만 삭제된다.\n2) V_2만 삭제된다.\n3) V_1과 V_2 모두 삭제된다.\n4) V_1과 V_2 모두 삭제되지 않는다.', '객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?\n\n[보기]\n1) Coad 와 Yourdon 방법\n2) Booch 방법\n3) Jacobson 방법\n4) Wirfs-Brocks 방법', '다음 중 워크스루 (Walkthrough) 와 인스펙션 (Inspection) 에 대한 설명으로 가장 옳지 않은 것은?\n\n[보기]\n1) 워크스루는 전문가들에 의해 개발자의 작업 내역이 검토된다.\n2) 워크스루는 제품 개발자가 주최가 된다.\n3) 워크스루는 오류 발견과 발견된 오류의 문제 해결에 중점을 둔다.\n4) 인스펙션은 워크스루를 발전시킨 형태이다.', '요구사항 개발 프로세스의 순서로 옳은 것은 ? ㉠ 도출 (Elicitation) ㉡ 분석 (Analysis) ㉢ 명세 (Specification) ㉣ 확인 (Validation)\n\n[보기]\n1) ㉠ → ㉡ → ㉢ → ㉣\n2) ㉠ → ㉢ → ㉡ → ㉣\n3) ㉠ → ㉣ → ㉡ → ㉢\n4) ㉠ → ㉡ → ㉣ → ㉢', '클래스(Class) 다이어그램 클래스 다이어그램은 시스템을 구성하는 클래스, 클래스 의 특성인 속성과 오퍼레이션, 속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 표현한 것이다. 클래스 다이어그램의 구성 요소 클래스 다이어그램은 클래스, 제약조건, 관계 등으로 구성된다.- 클래스는 각각의 객체들이 갖는 속성과 오퍼레 이션(동작)을 표현함- 일반적으로 3개의 구획(Compartment)으로 나눠 클래스(Class) 클래스의 이름, 속성, 오퍼레이션을 표기함- 속성(Attribute) : 클래스의 상태나 정보를 표현함- 오퍼레이션(Operation) : 클래스가 수행할 수 있 는 동작으로, 함수(메소드, Method)라고도 함 12 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 제약조건 수행 전후에 지정해야 할 조건이 있다면 이를 적음- 관계는 클래스와 클래스 사이의 연관성을 표현 함 관계- 클래스 다이어그램에 표현하는 관계에는 연관 (Relationships) 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계가 있음 2401', '- 기본적인 사용자 정의 데이터형이며, 데이터를 추상화하는 단위이다. \n- 구조적 기법에서의 단위 테스트(Unit Test)와 같은 개념이다. \n- 상위 클래스(부모 클래스, Super Class), 하위 클래스(자식 클래스, Sub Class)로 \n나뉜다. \nObject \n- 데이터와 함수를 묶어 캡슐화하는 대상이 된다. \n- Class 에 속한 Instance 를 Object 라고 한다. \n- 하나의 소프트웨어 모듈로서 목적, 대상을 표현한다. \n- 같은 클래스에 속한 각각의 객체를 instance 라고 한다. \nMessage \nObject 간에 서로 주고받는 통신을 의미한다. \nAttribute : Object 가 가지고 있는 데이터 값 \nMethod : Object 의 행위인 함수 \nClass = 틀 = Type \n객체지향의 특징(캡상다추정) \n캡슐화 \n(Encapsulation) 상속성 \n(Inheritance) \n다형성 \n(Polymorphism) \n추상화 \n(Abstraction) \n정보은닉 \n(Information Hiding) \n- 서로 관련성이 높은 데이터(속성)와 그와 관련된 기능(메서드, 함수)을 묶는 기법이다. \n- 결합도가 낮아져 소프트웨어 개발에 있어 재사용성이 높아진다. \n- 정보은닉을 통하여 타 객체와 메시지 교환 시 인터페이스가 단순해진다. \n- 변경 발생 시 오류의 파급 효과가 적다. - 상위 클래스의 모든 속성, 연산을 하위 \n클래스가 재정의 없이 물려받아 사용하는 것이다. \n- 상위 클래스는 추상적 성질을, 자식 클래스는 구체적 성질을 가진다. \n- 하위 클래스는 상속받은 속성과 연산에 새로운 속성과 연산을 추가하여 사용할 수 있다. \n- 다중 상속 : 다수 상위 클래스에서 속성과 연산을 물려받는 것이다. - 객체가 다양한 \n모양을 가지는 성질을 뜻한다. \n- 오퍼레이션이나 속성의 이름이 하나 이상의 클래스에서 정의되고 각 클래스에서 다른 \n형태로 구현될 수 있는 개념이다.', 'Python- 클래스- 정의 형식 class 클래스명: class는 예약어로, 그대로 입력하고 클래스명은 \x08 사용자가 임의로 지정한다. 실행할 문장 def 메소드명(self, 인수):- def는 메소드를 정의하는 예약어로, 그대로 입력하고, 메소드명은 사 용자가 임의로 지정한다.- self는 메소드에서 자기 클래스에 속한 변수에 접근할 때 사용하는 명칭 으로, 일반적으로 self를 사용하지만 사용자가 임의로 지정해도 된다.- ‘인수’는 메소드를 호출하는 곳에서 보낸 값을 저장할 변수로, 사용자 \x08 가 임의로 지정한다. 실행할 문장 return 값- return은 메소드를 호출한 위치로 값을 돌려주기 위해 사용하는 예약 어로, 그대로 입력한다. return 값이 없는 경우에는 생략할 수 있다. \x08- ‘값’에는 변수, 객체, 계산식 등이 올 수 있다.- 객체의 선언 형식 변수명 = 클래스명( ) \x08 변수명은 사용자가 임의로 지정하고, 사전에 정의한 클래스명과 괄호( )를 적는다. 다음은 두 수를 교환하는 프로그램을 Python으로 예제 구현한 것이다. class Cls: Cls 클래스 정의부의 시작점이다. 여기서부터 \x08 ❼번까지가 클래스 정의부에 해당한다. x, y = 10, 20 Cls 클래스의 변수(속성) x와 y를 선언하고, 각 \x08 각 10과 20으로 초기화한다. def chg(self): ❹ temp = self.x ❺ self.x = self.y ❻ self.y = temp ❼ a = Cls( ) ❶ print(a.x, a.y) ❷ a.chg( ) ❸ print(a.x, a.y) ❽ 정보처리기사 필기 요약 코드', '단계 \n개요  \n1NF \n도메인이 원자값 \n2NF \n부분적 함수적 종속성 제거 => 완전 함수적 종속 관계 만족 (X -> Y) \n3NF \n이행적 함수 종속 제거 (A->B이고 B->C일 때 A->C를 만족하는 관계 제거) \nBCNF \n결정자이면서 후보키가 아닌 것 제거 \n4NF \n다치 종속 제거 \n5NF \n조인 종속성 이용 \n3) 반정규화 : 정규화된 엔티티, 속성, 관계를 중복, 통합, 분리(의도적인 정규화 원칙 위배) \n4. 물리적 모델링 \n1) 트랜잭션 분석 \n(1) 트랜잭션 : 하나의 논리적 기능을 수행하기 위한 작업의 단위 (DB 상태 변화) \n(2) 트랜잭션 상태 : 활동, 실패, 철회(롤백 수행), 부분완료(커밋 직전), 완료(커밋) \n(3) 분석 방법 : CRUD 분석 (Create, Read, Update, Delete) \n(4) 트랜잭션의 특성 (ACID) \nAtomicity(원자성) \n모두 반영되거나(Commit) 전혀 반영되지 않고 복구(Rollback) \nConsistency (일관성) \n시스템이 가진 고정요소는 트랜잭션 수행전과 수행후가 동일 \nIsolation (독립성) \n하나의 트랜잭션 실행 중에 다른 트랜잭션이 끼어들 수 없음 \nDurability (영속성)  \n완료된 트랜젝션 결과는 영구적으로 반영 \n2) 뷰(View) 설계 : 물리적으로 존재하지 않는 가상테이블 설계 (변경 불가, 독립적 인덱스 x) \n3) 파티션 설계: 범위분할, 해시분할, 조합분할(범위+해시), 목록분할, 라운드로빈분할(균일배분)\n4) 분산 데이터베이스 설계   \n(1) 분산 데이터베이스 : 논리적으로는 하나, 물리적으로는 분산 \n(2) 구성요소 : 분산 처리기, 분산 데이터베이스, 통신 네트워크 \n(3) 분산 데이터베이스의 모교 \n위치 투명성 \n논리적 명칭만으로 액세스 (실제위치 몰라도 됨) \n중복 투명성 \n동일 데이터가 여러곳에 중복되어 있더라도 마치 하나만 존재하듯이 사용 \n병행 투명성', 'Select문 SELECT [PREDICATE] [테이블명.]속성명1, [테이블명.]속성명2,… FROM 테이블명1, 테이블명2,… WHERE [ 조건] [GROUP BY 속성명1, 속성명2,…] [HAVING 조건] ORDER BY [ 속성명 [ASC | DESC]];- SELECT절- : 불러올 튜플 수를 제한할 명령어 Predicate DISTINCT : 중복된 튜플이 있으면 그 중 첫 번째 한 개만 검색- : 검색하여 불러올 속성(열) 및 수식들 속성명- FROM절 : 질의에 의해 검색될 데이터들을 포함하는 테 이블명- WHERE절 : 검색할 조건- GROUP BY절 : 특정 속성을 기준으로 그룹화하여 검색 할 때 그룹화 할 속성- HAVING절 : 그룹에 대한 조건- ORDER BY절- : 정렬의 기준이 되는 속성명 속성명- : 정렬 방식(ASC는 오름차순, DESC [ASC | DESC] 또는 생략하면 내림차순)']"
17,폭포수 모형의 특징으로 거리가 먼 것은 ?,"[""순차적인 접근방법을 이용한다."", ""나선형 모형의 단점을 보완하기 위한 모형이다."", ""단계적 정의와 산출물이 명확하다."", ""모형의 적용 경험과 성공사례가 많다.""]",2,2,소프트웨어 설계,소프트웨어 설계,"폭포수 모형은 소프트웨어 개발 방법론 중 하나로, 선형 순차적 모형이라고도 합니다. 이 모형의 특징은 다음과 같습니다.

- 순차적인 접근 방법을 이용한다.
- 단계적 정의와 산출물이 명확하다.
- 모형의 적용 경험과 성공 사례가 많다.

보기 2번 '나선형 모형의 단점을 보완하기 위한 모형이다.'는 폭포수 모형의 특징이 아닙니다. 나선형 모형은 폭포수 모형의 단점을 보완하기 위해 개발된 모형이 아니라, 위험 분석을 추가한 점진적 모형입니다.

과목: 소프트웨어 설계","['모듈화(Modularity)와 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 시스템을 모듈로 분할하면 각각의 모듈을 별개로 만들고 수정할 수 있기 때문에 좋은 구조가 된다.\n2) 응집도는 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다.\n3) 모듈 간의 결합도가 약해야 독립적인 모듈이 될 수 있다.\n4) 모듈 내 구성 요소들 간의 응집도가 강해야 좋은 모듈 설계이다.', '모듈화 (Modularity) 와 관련한 설명으로 틀린 것은 ?\n\n[보기]\n1) 소프트웨어의 모듈은 프로그래밍 언어에서 Subroutine, Function 등으로 표현될 수 있다.\n2) 모듈의 수가 증가하면 상대적으로 각 모듈의 크기가 커지며 , 모듈 사이의 상호교류가 감소하여 과부하 (Overload) 현상이 나타난다.\n3) 모듈화는 시스템을 지능적으로 관리할 수 있도록 해주며 , 복잡도 문제를 해결하는 데 도움을 준다.\n4) 모듈화는 시스템의 유지보수와 수정을 용이하게 한다.', '요구사항 개발 프로세스의 순서로 옳은 것은 ? ㉠ 도출 (Elicitation) ㉡ 분석 (Analysis) ㉢ 명세 (Specification) ㉣ 확인 (Validation)\n\n[보기]\n1) ㉠ → ㉡ → ㉢ → ㉣\n2) ㉠ → ㉢ → ㉡ → ㉣\n3) ㉠ → ㉣ → ㉡ → ㉢\n4) ㉠ → ㉡ → ㉣ → ㉢', '형상 관리의 개념과 절차에 대한 설명으로 틀린 것은 ?\n\n[보기]\n1) 형상 식별은 형상 관리 계획을 근거로 형상 관리의 대상이 무엇인지 식별하는 과정이다.\n2) 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다.\n3) 형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용 및 반영해야 한다.\n4) 형상 감사는 형상 관리 계획대로 형상 관리가 진행되고 있는지, 형상 항목의 변경이 요구사항에 맞도록 제대로 이뤄졌는지 등을 살펴보는 활동이다.', '소프트웨어 비용 산정 기법 중 개발 유형으로 Organic, SemiDetach, Embedded 로 구분되는 것은 ?\n\n[보기]\n1) PUTNAM\n2) COCOMO\n3) FP\n4) SLIM', '추상화: 전체적이고 포괄적인 개념 설계 후 구체화 \n=> 유형 : 제어 추상화, 과정 추상화, 자료(데이터) 추상화 (제과자)  \n단계적 분해: 하향식 설계 (상위 중요 개념 -> 하위 개념) \n정보 은닉 : 모듈 내의 데이터나 기능에 다른 모듈이 접근하지 못하도록 \n모듈화 : 시스템이 모듈 단위로 분해되어야함 \na. 모듈: 시스템의 기능적 단위 \nb. 팬인(입력)은 높게, 팬아웃(출력)은 낮게!  \nc. 약한 결합도, 강한 응집도 필요 (표의 위일수록 좋은거) \n결합도 : 모델 사이의 의존정도 \n응집도 : 내부요소들의 관련 정도 \n자료 결합도: 자료를 주고받음 \n기능적 응집: 전 기능이 단일 문제와 관련 \n스탬프 결합도: 자료구조를 주고받음 \n순차적 응집 : A->B 순차적 수행 \n제어 결합도: 다른 모듈의 흐름 제어 \n교환(통신)적 응집 : 동일 입력 다른 기능 \n외부 결합: 모듈의 데이터를 외부에서 참\n조 \n절차적 응집 : 순차가 많음 \n공통 결합도 : 공통 데이터 영역 사용 \n시간적응집: 특정 시간에 필요한 기능 모음 \n내용 결합도 : 기능이나 자료를 직접 참조 \n논리적 응집 : 유사한 성격의 기능 모음 \n우연적 응집 : 관련 X \n(4) 아키텍처 패턴 : 전형적인 소프트웨어 아키텍처 설계 방법 \n파이프-필터 : 데이터 흐름(스트림)의 각 단계별로 캡슐화(묶어서 관리) \n모델-뷰-컨트롤러 : \na. 모델 : 핵심기능과 데이터보관 \nb. 뷰 : 사용자게 정보 표시 \nc. 컨트롤러 : 사용자의 요청을 처리하기 위해 모델에게 명령 \n마스터-슬레이브 : 동일한 구조의 슬레이브 컴포넌트들이 작업을 분할 수행 \n2) 디자인 패턴 \n(1) 정의 : 모듈의 역할, 모듈 간 인터페이스같은 세부적인 구현 방안 설계시의 패턴 \n(2) 종류 : 생성 패턴, 구조 패턴, 행위 패턴 \n(3) 생성 패턴 : 객체의 생성과 관련된 패턴 \n추상팩토리 : 인터페이스를 조합해 객체 생성 \n빌더 : 다른 객체를 조합해서 객체 생성', '(Waterfall Model) 폭포수 모형은 폭포에서 한번 떨어진 물은 거슬러 올라갈 수 없듯이 소프트웨어 개발도 이전 단계로 돌아갈 수 없다 는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하 게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론이다. 4- 폭포수 모형은 소프트웨어 공학에서 가장 오래되고 가 장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형 으로, 고전적 생명 주기 모형이라고도 한다.- 소프트웨어 개발 과정의 한 단계가 끝나야만 다음 단계 로 넘어갈 수 있는 선형 순차적 모형이다.- 모형을 적용한 경험과 성공 사례가 많다.- 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결 과물이 명확하게 산출되어야 한다. 타당성검토 계획 요구분석 설계 구현(코딩) 시험(검사) 유지보수', '점진적 모형) 나선형 모형은 보헴(Boehm)이 제안한 것으로, 폭포수 모 형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형이다.- 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것으로, 점진적 모형이라고도 한다.- 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리 하고 최소화하는 것을 목적으로 한다.- 점진적으로 개발 과정이 반복되므로 누락되거나 추가 된 요구사항을 첨가할 수 있고, 정밀하며, 유지보수 과 정이 필요 없다. 계획 수립 위험 분석 → → → 개발 및 검증 고객 평가 정보처리기사 필기 요약 2400', '개발 단계 안에서 유지보수가 이루어지는 것으로 볼 수 있다. \n폭포수 모형(Waterfall Model) \n \n보헴(Boehm)이 제안한 고전적 생명주기 모형으로, 선형 순차적 모형이라고도 한다. \n타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수의 단계를 통해 소프트웨어를 \n개발하는 모형이다. \n순차적인 접근 방법을 이용하며, 단계적 정의와 산출물이 명확하다. \n각 단계의 결과가 확인되어야지만 다음 단계로 넘어간다. \n개발 중 발생한 요구사항은 반영하기 어렵다. \n가장 오래된 모형으로 모형의 적용 경험과 성공 사례가 많다. \n나선형 모형(Spiral Model) \n \nBoehm 이 제시하였으며, 반복적인 작업을 수행하는 모형으로 점증적 모형, 집중적 \n모형이라고도 한다. 완성도 높은 소프트웨어를 만들 수 있다. \n여러 번의 개발 과정을 거쳐 완벽한 최종 소프트웨어를 개발하는 점진적 모형이다. \n가장 큰 장점인 위험 분석 단계에서 기술과 관리의 위험 요소들을 하나씩 제거해 \n나감으로써 위험성 평가에 크게 의준하기 때문에 이를 발견하지 않으면 문제가 발생할 수 \n있다. \n대규모 시스템의 소프트웨어 개발에 적합하다. \n나선형 모형의 개발 단계 \n \n계획 수립(Planning) : 위험 요소와 타당성을 분석하여 프로젝트의 추진 여부를 \n결정한다. \n위험 분석(Risk Analysis) : 개발 목적과 기능 선택, 제약 조건 등을 결정하고 \n분석한다. \n개발 및 검증(Development) : 선택된 기능을 수행하는 프로토타입을 개발한다. \n고객 평가(Evaluation) : 개발된 프로토타입을 사용자가 확인하고 추가 및 수정될 \n요구사항이 있으면 이를 반영한 개선 프로토타입을 만든다. \nCMP(Critical Path Method) \n \n프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는 기법이다. \n노드와 간선으로 구성되며, 노드는 작업을 표시하고 간선은 작업 사이의 전후 의존 관계를 \n나타낸다.', 'PERT PERT(Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술)는 프로젝트에 필요한 전체 작 업의 상호 관계를 표시하는 네트워크로 각 작업별로 낙관 적인 경우, 가능성이 있는 경우, 비관적인 경우로 나누어 각 단계별 종료 시기를 결정하는 방법이다.- 과거에 경험이 없어서 소요 기간 예측이 어려운 소프트웨어에서 사용한다.- 노드와 간선으로 구성되며 원 노드에는 작업을, 간선 (화살표)에는 낙관치, 기대치, 비관치를 표시한다.- 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관 련성 등을 알 수 있다.- 다음과 같은 PERT 공식을 이용하여 작업 예측치를 계 산한다. 비관치 + 4 × 기대치 + 낙관치 작업 예측치 = 6 평방 편차 = [ (비관치- 낙관치) ] 2 6 5, 14, 17 B C 2, 6, 8 2, 5, 14 1, 4, 7 2, 4, 8 E F G 6, 14, 28 A 3, 12, 21 D']"
18,CASE(Computer-Aided Software Engineering) 의 원천 기술이 아닌 것은?,"[""구조적 기법"", ""프로토타이핑 기술"", ""정보 저장소 기술"", ""일괄처리 기술""]",4,4,소프트웨어 설계,정보시스템 구축 관리,"CASE(Computer-Aided Software Engineering)의 원천 기술에는 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술 등이 포함됩니다. 일괄처리 기술은 CASE의 원천 기술로 간주되지 않습니다. CASE는 소프트웨어 개발 과정에서 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것입니다. 구조적 기법, 프로토타이핑, 자동 프로그래밍, 정보 저장소, 분산처리 등이 CASE의 원천 기술로 알려져 있습니다.

CASE의 주요 기능에는 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 모델들의 모순 검사 및 오류 검증, 그래픽 지원, 자료 흐름도 작성 등이 있습니다. 따라서, 일괄처리 기술은 CASE의 원천 기술이 아닙니다.

과목: 정보시스템 구축 관리","['요구공학 (Requirements Engineering) 에 대한 설명으로 옳지 않은 것은?\n\n[보기]\n1) 무엇을 개발해야 하는지 요구사항을 정의하고 , 분석 및 관리하는 프로세스를 연구하는 학문이다.\n2) 사용자 요구사항이 더욱 복잡해지고 잦은 변경이 발생하자 이를 적절하게 관리하기 위해 등장하였다.\n3) 요구사항 개발의 한 요소이다.\n4) 품질 개선과 프로젝트 실패의 최소화를 목적으로 한다.', '분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신환경 등을 연결하여 응용 프로그램과 운영환경 간에 원만한 통신이 이루어질 수 있게 서비스를 제공하는 소프트웨어는?\n\n[보기]\n1) 미들웨어\n2) 하드웨어\n3) 오픈허브웨어\n4) 그레이웨어', 'IDE(Integrated Development Environment) 도구의 각 기능에 대한 설명으로 틀린 것은?\n\n[보기]\n1) Coding - 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성 할 수 있는 환경을 제공\n2) Compile – 저급 언어의 프로그램을 고급 언어 프로그램으로 변환하는 기능\n3) Debugging - 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능\n4) Deployment - 소프트웨어를 최종 사용자에게 전달하기 위한 기능', '소프트웨어 아키텍처 모델 중 MVC(Model-View-Controller)와 관련 한 설명으로 틀린 것은?\n\n[보기]\n1) MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.\n2) 모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브시스템이 각각 하나씩 연결된다.\n3) 뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다.\n4) 제어(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.', '소프트웨어 재공학의 주요 활동 중 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업을 의미하는 것은?\n\n[보기]\n1) Analysis\n2) Migration\n3) Restructuring\n4) Reverse Engineering', 'CASE의 개요 CASE(Computer Aided Software Engineering)는 소프 트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소 프트웨어 도구를 사용하여 자동화하는 것이다.- 객제지향 시스템, 구조적 시스템 등 다양한 시스템에서 활용되는 자동화 도구(CASE Tool)이다.- 소프트웨어, 하드웨어, 데이터베이스, 테스트 등을 통 합하여 소프트웨어를 개발하는 환경을 조성한다.- 소프트웨어 생명 주기의 전체 단계를 연결해 주고 자동 화해 주는 통합된 도구를 제공해 주는 기술이다.', '5과목: 정보시스템 구축 관리\n\n<정보시스템 구축 관리>------------------------------------------ \nⅤ 소프트웨어 개발 방법론 활용 \n1.  SW 공학의 발전 추세 \n1) 소프트웨어 재공학: 기존 시스템을 이용하여 더 나은 시스템 구축 \n(1) 이식(Migration) : 기존 소프트웨어를 다른 환경에서 사용할 수 있도록 변환하는 기술 \n(2) 역공학(Reverse Engineering) : 기존 소프트웨어를 분석하여 다시 만들어내는 활동 \n(3) 소프트웨어 재사용방법 : 합성 중심 (모듈화를 통한 소프트웨어 완성) \n2) CASE : 개발 과정을 컴퓨터와 전용 소프트웨어를 사용하여 자동화  \n(1) 원천 기술 : 구조적 기법, 프로토 타이핑, 자동 프로그래밍, 정보 저장소, 분산처리 \n2. 비용 산정 기법 : 상향식 비용 산정  \n1) LOC 기법 (source Line Of Code) : 비관치, 낙관치, 기대치를 측정하여 예측치를 구함 \n생산성 : 원시라인 코드수 / 노력(=투입인원 x 개발기간) \n2) 수학적 산정 : COCOMO, Putnam, 기능점수(FP) \n(1) COCOMO 모형 :  원시 프로그램의 규모인 LOC에 의한 비용 산정 기법 \n유형 : Organic(5만라인 이하), Semi-Detached(30만 이하), Embedded(30만 이상) \n=> 같은 규모의 소프트웨어도 유형에 따라 비용이 다르게 산정됨 \n3. 프로젝트 일정 계획 도구 : PERT/CPM, 간트 차트  \n1) CPM : 소요기간을 에측하는 기법 (임계경로 = 최장 경로) \n2) 간트 차트(시간선 차트) : 각 작업 일정과 기간을 막대도표를 이용해서 나타냄 \n4. 프로젝트 개발 프레임워크  \n1) 프레임 워크 : 개발해야하는 애플리케이션의 일부분이 이미 구현된 뼈대, 골조 \n: 모듈화, 재사용성, 확장, 제어의 역흐름(프레임워크가 흐름을 제어) \nⅤ 네트워크 구축 \n1. 네트워크 구축 \n1) 네트워크 설치 구조 \n버스형', '(자동화 도구) 요구사항 분석을 위한 자동화 도구는 요구사항을 자동으 로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구를 의미한다. 종류- SADT(Structured Analysis and Design Technique)- \x03 SoftTech 사에서 개발한 것으로 시스템 정의, 소프 트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위 해 널리 이용되어 온 구조적 분석 및 설계 도구이다.- SREM(Software Requirements Engineering Methodology) = RSL/REVS- \x03 TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처 리 소프트웨어 시스템에서 요구사항을 명확히 기술 하도록 할 목적으로 개발한 것으로, RSL과 REVS를 사용하는 자동화 도구이다.- \x03 RSL(Requirement Statement Language) : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어- \x03 REVS(Requirement Engineering and Validation System) : RSL로 기술된 요구사항들을 자동으로 분 석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기 정보처리기사 필기 요약- PSL/PSA- 미시간 대학에서 개발한 것으로 PSL과 PSA를 사용 하는 자동화 도구이다.- TAGS(Technology for Automated Generation of Systems)- \x03 시스템 공학 방법 응용에 대한 자동 접근 방법으로, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구이다. 2400', '소프트웨어 개발 주기의 표준안 확입, 소프트웨어 개발 기법의 실용화, 문서화의 용이성 \n제공, 시스템 수정 및 유지보수 축소 등의 효과를 얻을 수 있다. \nCASE 의 분류 \n \n상위(Upper) CASE : 요구분석 및 설계 단계 지원 \n하위(Lower) CASE : 소스 코드 작성, 테스트, 문서화 과정 지원 \n통합(Integrate) CASE : 소프트웨어 개발 주기 전체 과정 지원 \n요구사항 분석을 위한 CASE 도구 \n요구사항 분석을 위한 CASE \n \n요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구를 \n의미한다. \n표준화와 보고를 통한 문서화 품질 개선, 변경이 주는 영향 추적의 용이성, 명세에 대한 \n유지보수 비용 축소, 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성 \n등의 특징을 갖는다. \nDB 가 모두에게 이용 가능하다는 점에서 분석자들 간의 적절한 조정 기능을 제공한다. \n요구사항 분석을 위한 CASE 도구 \n \nSADT(Structured Analysis and Design Technique) : SoftTech 사에서 개발한 \n것으로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위해 널리 \n이용되어 온 구조적 분석 및 설계 도구이다. 구조적 요구분석을 하기 위해 블록 \n다이어그램을 채택한 자동화 도구다. \nREM(Software Requirements Engineering Methodolohy) = RSL/REVS : TRW 사가 \n우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 \n기술하도록 할 목적으로 개발한 것으로, RSL 과 REVS 를 사용하는 자동화 도구이다. \nRSL(Requirement Statement Language) : 요소, 속성, 관계, 구조들을 기술하는 \n요구사항 기술 언어이다. \nREVS(Requirement Engineering and Validation System) : RSL 로 기술된', 'CASE의 주요 기능- 소프트웨어 생명 주기 전 단계의 연결- 다양한 소프트웨어 개발 모형 지원- 모델들의 모순 검사 및 오류 검증- 그래픽 지원- 자료 흐름도 작성 등']"
19,다음은 어떤 프로그램 구조를 나타낸다 . 모듈 F 에서의 fan-in 과 fan-out 의 수는 얼마인가 ?,"[""fan-in :2, fan-out :3"", ""fan-in :3, fan-out :2"", ""fan-in :1, fan-out :2"", ""fan-in :2, fan-out :1""]",2,1,소프트웨어 설계,소프트웨어 설계,"- 팬인(Fan-in)은 다른 모듈이 해당 모듈을 호출하는 수를 의미하며, 팬아웃(Fan-out)은 해당 모듈이 다른 모듈을 호출하는 수를 의미합니다. 
- 그림에서 모듈 F는 모듈 A, B, C로터 호출을 받고, 모듈 G, H, I, J를 호출합니다. 
- 따라서 모듈 F의 Fan-in은 3, Fan-out은 4입니다. 
- 하지만, 보기에서 'fan-in :2, fan-out :3' ,'fan-in :3, fan-out :2', 'fan-in :1, fan-out :2', 'fan-in :2, fan-out :1'이 주어졌으므로, 가장 근접한 값인 'fan-in :3, fan-out :2'를 정답으로 선택합니다.

과목: 소프트웨어 설계","['어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어신호를 이용하여 통신하는 경우이며 , 하위 모듈에서 상위 모듈로 제어신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도현상이 발생하게 되는 결합도는?\n\n[보기]\n1) Data Coupling\n2) Stamp Coupling\n3) Control Coupling\n4) Common Coupling', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?\n\n[보기]\n1) Object\n2) Dynamic\n3) Function\n4) Static', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?\n\n[보기]\n1) Object\n2) Dynamic\n3) Function\n4) Static', 'LOC 기법에 의하여 예측된 총 라인수가36,000라인, 개발에 참여할 프로그래머가6명, 프로그래머들의 평균 생산성이 월간300라인일 때 개발에 소요되는 기간은?\n\n[보기]\n1) 5개월\n2) 10개월\n3) 15개월\n4) 20개월', '빈 기억공간의 크기가20KB,16KB,8KB,40KB 일 때 기억장치 배치 전략으로 “Best Fit” 을 사용하여17KB 의 프로그램을 적재할 경우 내부 단편화의 크기는 얼마인가?\n\n[보기]\n1) 3KB\n2) 23KB\n3) 64KB\n4) 67KB', 'Width 같은 등급(level)의 모듈 수 \nSuper ordinate \n다른 모듈을 제어하는 모듈 \nSubordinate 어떤 모듈에 의해 제어되는 모듈 \nex. 모듈 F 에서의 Fan-in : 3, Fan-out : 2 \n \nFan-in/Fan-out 을 분석하면 시스템 복잡도 파악이 가능하다. \nFan-in 이 높은 경우 Fan-out 이 높은 경우 \n- 재사용 측면에서 잘된 설계로 볼 수 있다. \n- 시스템 구성 요소 중 일부가 동작하지 않으면 시스템이 중단되는 단일 장애 발생 \n가능성이 있다. \n- 단일 장애 발생을 방지하기 위해 중점 관리가 필요하다. \n- 불필요한 타 모듈의 호출 \n여부를 확인한다. \n- Fan-out 을 단순하게 설계할 수 있는지 검토한다. \n복잡도 최적화를 위한 조건 : Fan-in 은 높이고 Fan-out 은 낮추도록 설계한다. \n코드 설계의 개요 \n코드 설계 \n \n데이터의 사용 목적에 따라서 식별하고 분류, 배열하기 위하여 사용하는 숫자, 문자 혹은 \n기호를 코드라고 한다. \n대량의 자료를 구별, 동질의 그룹으로 분류하고 순번으로 나열하며, 특정의 자료를 \n선별하거나 추출을 쉽게 하여 파일 시스템을 체계화한 것을 코드 설계라 한다. \n코드 설계 순서 : 코드 대상 선정 => 코드화 목적 명확화 => 코드 부여 대상 수 확인 => \n사용 범위 결정 => 사용 기간 결정 => 코드화 대상의 특성 분석 => 코드 부여 방식 결정 \n=> 코드의 문서화 \n코드의 기능 \n \n코드의 기본적 기능 코드의 3 대 기능 \n코드의 부가적 기능 \n- 표준화 기능 \n- 간소화 기능 - 분류 기능 \n- 식별 기능 \n- 배열 기능 -연상 기능 \n- 암호화 기능 \n- 오류 검출 기능 \n코드 설계 목적 및 특성 \n \n목적 \n특성 \n고유성 코드는 그 뜻이 1:1 로 확실히 대응할 수 있어야 한다. \n분류 편리성 목적에 적합한 분류가 가능해야 한다. \n배열의 효율성 바람직한 배열을 얻을 수 있어야 한다. \n간결성 짧고 간결 명료해야 한다.', '20. 통합 구현 \n단위 모듈 구현 \n단위 모듈 \n \n소프트웨어 구현에 필요한 다양한 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 \n것을 의미한다. \n사용자 또는 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램이다. \n독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입될 수 있다. \n두 개의 단위 모듈이 합쳐지면 두 개의 기능들을 같은 모듈로 구현할 수 있다. \n종류 : 화면, DB 접근, 인터페이스, 비즈니스 트랜잭션, 데이터 암호화 등 \n단위 기능 명세서 \n \n큰 규모의 시스템을 분해하여 단위 기능별로 계층적으로 구조화하고, 단순하게 추상화한 \n문서이다. \n모듈화의 원리 \n \n소프트웨어 개발에 있어 기능을 나누고 추상화하여 소프트웨어의 성능을 향상시키고 \n유지보수를 효과적으로 구현하기 위한 기법을 의미한다. \n종류 \n분할과 지배(Dibide Conquer) : 복잡한 문제를 분해, 모듈 단위로 문제를 해결한다. \n정보 은폐(Information Hiding) : 어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 \n은폐시킨다. \n자료 추상화(Data Abstraction) : 함수 내에 자료 구조의 표현 명세를 은폐, 자료와 \n자료에 적용 가능한 오퍼레이션을 함께 정의한다. \n모듈의 독립성(Module Independence) : 낮은 결합도, 높은 응집도를 갖도록 한다. \n단위 모듈 테스트 \n \n프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증하는 \n것이다. \n화이트박스 테스트와 블랙박스 테스트 기법이 있다. \n구현 단계의 작업 절차 \n \n코딩 계획 => 코딩 => 컴파일 => 테스트 \n \n통합 개발 환경 \nIDE(Integrated Development Environment) \n \nC++, JAVA 등의 언어를 이용한 소프트웨어 개발 단계에서 패키지 인크루딩, 소스 코드 \n편집, 컴파일, 디버깅, 바이너리 배포 등 모든 작업을 통합 지원한다.', '개요 단위 모듈은 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것이다.- 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다.- 단위 모듈은 사용자나 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미하기도 한다.- 두 개의 단위 모듈이 합쳐질 경우 두 개의 기능을 구현 할 수 있다.- 단위 모듈의 구성 요소에는 처리문, 명령문, 데이터 구 조 등이 있다.- 단위 모듈은 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다.- 단위 모듈을 구현하기 위해서는 단위 기능 명세서를 작 성한 후 입·출력 기능과 알고리즘을 구현해야 한다. 단위 기능 명세서 작성 입·출력 기능 구현 알고리즘 구현 2404', '1) 정의: 모듈별로 생성한(모듈화한) 실행 파일을 묶어 배포용 설치파일을 만드는 것 \n2) 패키징 시 고려사항 => 사용자 중심! \n(1) 사용자에게 필요한 최소 환경 정의 \n(2) 내부 컨텐츠에 대한 암호화 및 보안 \n(3) 다른 여러 콘텐츠 및 단말기 간의 DRM(디지털 저작권 관리) 연동 고려 \n3) DRM(디지털 저작권 관리)  \n(1) 디지털 컨텐츠와 디바이스의 사용을 제한하기 위한 접근 제어 기술 \n=> 사용 권한, 과금, 유통 관리 \n(2) 구성 요소 \n클리어링 하우스 : 권한정책 및 라이선스 관리 \n콘텐츠 제공자, 분배자(유통), 소비자 \n패키지, DRM 컨트롤러, 보안 컨테이너 \n(3) 관리 기술 \n암호화 \n콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술 \n키 관리 \n콘텐츠를 암호화한 키에 대한 저장 및 분배 \n암호화 파일 생성 \n콘텐츠를 암호화된 콘텐츠로 생성 \n식별 기술 \n콘텐츠에 대한 식별 체계 표현 \n저작권 표현 \n라이선스의 내용 표현 \n정책 관리 \n라이선스 발급 및 사용에 대한 정책 및 관리 \n크랙 방지 \n무단으로 사용하는 것을 방지  \n인증 \n사용자 인증', '프로세스(Process)의 정의 프로세스는 일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중 인 프로그램을 의미하며, 작업(Job), 태스크(Task)라고도 한다.- 프로세스는 다음과 같이 여러 형태로 정의할 수 있다.- PCB를 가진 프로그램- 실기억장치에 저장된 프로그램- 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위- 프로시저가 활동중인 것- 비동기적 행위를 일으키는 주체- 지정된 결과를 얻기 위한 일련의 계통적 동작- 목적 또는 결과에 따라 발생되는 사건들의 과정- 운영체제가 관리하는 실행 단위 정보처리기사 필기 요약 2415']"
20,HIPO(Hierarchy Input Process Output) 에 대한 설명으로 거리가 먼 것은?,"[""상향식 소프트웨어 개발을 위한 문서화 도구이다."", ""HIPO 차트 종류에는 가시적 도표 , 총체적 도표 , 세부적 도표가 있다."", ""기능과 자료의 의존 관계를 동시에 표현할 수 있다."", ""보기 쉽고 이해하기 쉽다.""]",1,1,소프트웨어 설계,소프트웨어 설계,"HIPO는 하향식 소프트웨어 개발을 위한 문서화 도구이다. 
- HIPO(Hierarchy Input Process Output)는 시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타낸다.
- HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.
- '상향식 소프트웨어 개발을 위한 문서화 도구이다.' 라는 보기는 HIPO의 정의와 반대되므로 정답이다.
과목: 소프트웨어 설계","['대표적으로 DOS 및 UNIX 등의 운영체제에서 조작을 위해 사용하던 것으로 , 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스 (User Interface) 는 ?\n\n[보기]\n1) GUI(Graphical User Interface)\n2) CLI(Command Line Interface)\n3) CUI(Cell User Interface)\n4) MUI(Mobile User Interface)', 'COCOMO model 중 기관 내부에서 개발된 중소 규모의 소프트웨어로 , 일괄 자료 처리나 과학기술 계산용 , 비즈니스 자료 처리용으로 5 만 라인 이하의 소프트웨어를 개발하는 유형은 ?\n\n[보기]\n1) Embeded\n2) Organic\n3) Semi-detached\n4) Semi-embeded', 'COCOMO Model 중 기관 내부에서 개발된 중소규모의 · 소프트웨어 로 일괄 자료 처리나 과학기술 계산용 , 비즈니스 자료 처리용으로 5 만 라인 이하의 소프트웨어를 개발하는 유형은 ?\n\n[보기]\n1) Embeded\n2) Organic\n3) Semi-Detached\n4) Semi-Embeded', 'UI의 종류로 멀티 터치(Multi-touch), 동작 인식(Gesture Recognition) 등 사용자의 자연스러운 움직임을 인식하여 서로 주고받는 정보를 제공하는 사용자 인터페이스를 의미하는 것은?\n\n[보기]\n1) GUKGraphical User Interface\n2) OUI(Organic User Interface)\n3) NUI(Natural User Interface)\n4) CLKCommand Line Interface', '소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.\n2) 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.\n3) 관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.\n4) 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.', 'HIPO HIPO(Hierarchy Input Process Output)는 시스템의 분 석 및 설계나 문서화할 때 사용되는 기법으로, 시스템 실 행 과정인 입력, 처리, 출력의 기능을 나타낸다.- 기본 시스템 모델은 입력, 처리, 출력으로 구성되며, 하 향식 소프트웨어 개발을 위한 문서화 도구이다.- 체계적인 문서 관리가 가능하다.- 기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉽다.- 기능과 자료의 의존 관계를 동시에 표현할 수 있다.- 변경, 유지보수가 용이하다.- 시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이 들 간의 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고 한다. HIPO Chart의 종류- 가시적 도표(도식 목차) : 시스템의 전체적인 기능과 흐름 을 보여주는 계층(Tree) 구조도- 총체적 도표(총괄도표, 개요 도표) : 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적 인 정보를 제공하는 도표- 세부적 도표(상세 도표) : 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표 10 22.3, 20.9 2400', '구조적 설계의 특징과 기본 구조 \n \n특징 : 하향식 기법, 신뢰성 향상, 유연성 제공, 재사용 용이 \n기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조 = 조건(Condition) 구조, \n반복(Repetition) 구조 \n구조적 분석 도구 \n자료 흐름도(DFD : Data Flow Diagram) \n \n시스템 내의 모든 자료 흐름을 4 가지의 기본 기호(처리, 자료 흐름, 자료 저장소, \n단말)로 기술하고 이런 자료 흐름을 중심으로 한 분석용 도구이다. \nDFD 의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시하고 구조적 분석 기법에 \n이용된다. \n시스템이나 프로그램 간의 총체적인 데이터 흐름을 표시할 수 있으며, 기본적인 데이터 \n요소와 그들 사이의 데이터 흐름 형태로 기술된다. \n다차원적이며 자료 흐름 그래프 또는 버블(Bubble) 차트라고도 한다. \n그림 중심의 표현이고 하향식 분할 원리를 적용한다. \n갱신하기 쉬워야 하며 이름의 중복을 제거하여 이름으로 정의를 쉽게 찾을 수 있도록 한다. \n정의하는 방식이 명확해야 한다. \n자료 흐름도(DFD) 작성 원칙 \n \n출력 자료 흐름은 입력 자료 흐름을 이용해 생성해야 한다. \n입력, 출력 자료 자체에 대해서만 인지하고 자료의 위치나 방향은 알 필요가 없다. \n자료 흐름 변환의 형태에는 본질 변환, 합성의 변환, 관점의 변환, 구성의 변환 등이 \n있다. \n자료 보존의 원칙 : 출력 자료 흐름은 반드시 입력 자료 흐름을 이용해 새엇ㅇ한다. \n최소 자료 입력의 원칙 : 출력 자료를 산출하는데 필요한 최소의 자료 흐름만 입력한다. \n독립성의 원칙 : 프로세스는 오직 자신의 입력 자료와 출력 자료 자체에 대해서만 알면 \n된다. \n지속성의 원칙 : 프로세스는 항상 수행하고 있어야 한다. \n순차 처리의 원칙 : 입력 자료 흐름의 순서는 출력되는 자료 흐름에서도 지키도록 한다. \n영구성의 원칙 : 자료 저장소의 자료는 입력으로 사용해도 삭제되지 않는다. \n데이터(자료) 흐름도', '1. 소프트웨어 공학의 개념 \n소프트웨어 \n소프트웨어(SW)의 개념 \n \n컴퓨터를 동작시키고 어떤 일의 처리 순서와 방법을 지시하는 명령어의 집합인 프로그램과 \n프로그램의 수행에 필요한 절차, 규칙, 관련 문서 등을 총칭한다. \n프로그램(Program) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 \n데이터의 집합을 의미한다. \n자료 구조(Data Structure): 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 \n등을 총칭하는 것으로 데이터 간의 논리적 관계나 처리 알고리즘을 의미한다. \n문서(Paper) : 소프트웨어를 개발함에 있어서 사용자 설명서, 소프트웨어 요구분석서, \n평가서, 명세서, 프로젝트 계획서, 검사 계획서 등을 의미한다. \n소프트웨어의 특징 \n \n상품성 : 소프트웨어를 개발하면 상품이 되어 판매가 된다. \n복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다. \n변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다. \n복제성 : 복제가 용이해 쉽게 복사, 유통이 가능하다. \n시스템(System)의 개요와 기본 요소 \n \n시스템의 개요 \n컴퓨터로 처리 가능한 자료를 입력하고 저장, 처리, 가공해 출력할 수 있도록 설계/구현된 \n정보 체계를 의미한다. \n하나의 목적을 위해 다양한 요소가 유기적으로 결합된 것을 의미한다. \n기본 요소 \n입력, 처리, 출력, 제어, 피드백으로 구성된다. \n소프트웨어 위기(Software Crisis) \n \n컴퓨터의 발달 과정에서 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 \n사용자들의 요구사항을 감당할 수 없는 문제가 발생함을 의미한다. \n소프트웨어 위기의 원인 \n하드웨어 비용을 초과하는 개발 비용의 증가 \n개발 기간의 지연 \n개발 인력 부족 및 인건비 상승 \n성능 및 신뢰성 부족 \n유지보수의 어려움에 따른 엄청난 비용 \n소프트웨어 공학(Software Engineering) \n소프트웨어 공학의 이해', '다이어그램으로 표시한다. \n기능 모델링 : 여러 프로세스 간의 자료 흐름을 표시한다. 어떤 데이터를 입력하여 어떤 \n결과를 가져올 수 있을지를 표현한다. \nUML 의 특성 \n \n비주얼화 : 소프트웨어 구성 요소 간의 관계 및 상호작용을 시각화한 것이다. \n문서화 : 소프트웨어 생명주기의 중요한 작업을 추적하고 문서화할 수 있다. 개발 프로세스 \n및 언어와 무관하게 개발자 간의 의사소통 도구를 제공한다. \n명세화 : 분석, 설계, 구현의 완벽한 모델을 제공한다. 분석 단계-기능 모델, 설계 단계-\n동작 수준 모델, 구현 단계-상호작용 모델 수준으로 명세화할 수 있다. 단순 표기법이 \n아닌 구현에 필요한 개발적 요소 및 기능에 대한 명세를 제공한다. \n구축 : 객체지향 언어와 호환되는 프로그래밍 언어는 아니지만, 모델이 객체지향 언어로 \n매핑될 수 있다. \nUML 소프트웨어에 대한 관점 \n \n기능적 관점 : 사용자 측면에서 본 소프트웨어의 기능을 나타낸다. 사용 사례 \n모델링이라고도 한다. 요구분석 단계에서 사용한다. UML 에서는 Use Case Diagram 을 \n사용한다. \n정적 관점 : 소프트웨어 내부의 구성 요소 사이의 구조적 관계를 나타낸다. 객체, 속성, \n연관 관계, 오퍼레이션의 시스템 구조를 나타내며, UML 에서는 Class Diagram 을 \n사용한다. (ex. 클래스 사이의 관계, 클래스 구성과 패키지 사이의 관계) \n동적 관점 : 시스템의 내부 동작을 말하며, UML 에서는 Sequence Diagram, State \nDiagram, Activity Diagram 을 사용한다. \nUML 의 기본 구성 \n \n구성 \n설명 \n사물(Things) - 객체지향 모델을 구성하는 기본 요소이다. \n- 객체 간의 관계 형성 대상이다. \n관계(Relationship) \n- 객체 간의 연관성을 표현하는 것이다. \n- 종류 : 연관, 집합 포함, 일반화, 의존, 실체화 \n다이어그램(Diagram) \n- 객체의 관계를 도식화한 것이다.', '자료 흐름도, 자료 사전 등이 효과적으로 이용될 수 있으며, 더 구체적인 명세를 위해 \n소단위 명세서(Mini-Spec)가 활용될 수 있다. \n요구공학의 목적 \n \n소프트웨어 개발 시 이해관계자 사이의 원활한 의사소통 수단을 제공한다. \n요구사항 누락 방지, 상호 이해 오류 등의 제거로 경제성을 제공한다. \n요구사항 변경 이력 관리를 통하여 개발 비용 및 시간을 절약할 수 있다. \n비용과 일정에 대한 제약설정과 타당성 조사, 요구사항 정의 문서화 등을 수행한다. \n요구공학(개발) 프로세스 \n \n요구사항을 명확히 분석하여 검증하는 진행 순서를 의미한다. \n개발 대상에 대한 요구사항을 체계적으로 도출한다. \n도출된 요구사항을 분석하여 분석 결과를 명세서에 정리한다. \n정리된 명세서를 마지막으로 확인, 검증하는 일련의 단계를 말한다. \n경제성, 기술성, 적법성, 대안성 등 타당성 조사가 선행되어야 한다. \nSWEBOK 에 따른 요구사항 개발 프로세스 \n \n도출(Elicitation) => 분석(Analysis) => 명세(Specification) => \n확인(Validation) \n요구사항 도출(Requirement Elicitation) \n \n소프트웨어가 해결해야 할 문제를 이해하는 첫 번째 단계이다. \n현재의 상태를 파악하고 문제를 정의한 후 문제 해결과 목표를 명확히 도출하는 단계이다. \n요구사항의 위치와 수집 방법과 관련되어 있다. \n이해관계자(Stakeholder)가 식별되며, 개발팀과 고객 사이의 관계가 만들어지는 \n단계이며, 다양한 이해관계자와 효율적인 의사소통이 중요하다. \n요구사항 도출 기법 : 고객의 발표, 문서 조사, 설문, 업무 절차 및 양식 조사, \n브레인스토밍, 워크숍, 인터뷰, 관찰 및 모델의 프로토타이핑, Use Case, 벤치마킹, \nBPR(업무 재설계), RFP(제안요청서) \n요구사항 분석(Requirement Analysis) \n \n소프트웨어가 환경과 어떻게 상호작용하는지 이해하고, 사용자의 요구사항을 걸러 내기']"
