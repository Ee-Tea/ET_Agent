id,question,options,gt_answer_idx,gen_answer_idx,gt_sub,gen_subject,gen_explanation,retrieved_problems,retrieved_concepts,contexts
1,XP(eXtreme Programming) 에 대한 설명으로 옳지 않은 것은 ?,"[""릴리즈 기간을 짧게 반복하여 고객의 요구 변화에 빠르게 대응한다."", ""코 드들은 하나의 작업이 마무리될 때마다 지속적으로 통합한다."", ""테스트가 지속적으로 진행될 수 있도록 테스트 자동화 도구를 사용한다."", ""개발 책임자가 모든 책임을 가지므로 팀원들은 책임 없이 자유로운 개발이 가능하다.""]",4,4,소프트웨어 설계,소프트웨어 설계,"XP(eXtreme Programming)는 고객의 요구사항 변화에 빠르게 대응할 수 있는 소프트웨어 개발 방법론입니다. XP의 핵심 가치에는 소통, 단순성, 피드백, 용기, 존중이 있습니다. XP의 주요 실천 방법에는 쌍 프로그래밍, 공동 코드 소유, 지속적인 통합, 테스트 주도 개발, 리팩토링 등이 있습니다.

보기 4번 ""개발 책임자가 모든 책임을 가지므로 팀원들은 책임 없이 자유로운 개발이 가능하다.""는 XP의 원칙과 맞지 않습니다. XP는 팀원 모두가 책임을 공유하고 협력하여 개발하는 것을 강조합니다. 따라서 보기 4번이 정답입니다.

과목: 소프트웨어 설계

XP는 소프트웨어 설계와 개발에 중점을 둔 방법론으로, 고객의 요구사항 변화에 빠르게 대응할 수 있는 유연한 개발 프로세스를 제공합니다. 따라서 이 문제는 소프트웨어 설계 과목에 적합합니다.","['객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?', '대표적으로 DOS 및 Unix 등의 운영체제에서 조작을 위해 사용하던 것으로, 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스(User Interface)는?', '대표적으로 DOS 및 Unix 등의 운영체제에서 조작을 위해 사용하던 것으로 , 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스 (User Interface) 는 ?', 'S/W 각 기능의 원시 코드 라인수의 비관치 , 낙관치 , 기대치를 측정하 여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?', '배치 프로그램의 자동 수행 주기 중 사용자가 특정 조건을 설정해 두고 해당 조건이 충족될 때만 수행되도록 하는 것은?']","['FDD(Feature Driven Development, 기능 중심 개발) \nCrystal \nASD(Adaptive Software Development, 적응형 소프트웨어 개발방법론) \nDAD(Disciplined Agile Delivery, 학습 애자일 배포) \nAgile 선언문 \n \n프로세스나 도구보다 개인과의 소통이 더 중요하다. \n완벽한 문서보다 실행되는 소프트웨어가 더 중요하다. \n계약 협상보다 고객과의 협업이 더 중요하다. \n계획을 따르는 것보다 변경에 대한 응답이 더 중요하다. \nXP(eXtreme Programming) \nXP(eXtreme Programming) \n \n1999 년 Kent Beck 이 제안하였으며, 개발 단계 중 요구사항이 시시각각 변동이 심한 \n경우 적합한 방법론이다. \n요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 한다. \n요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 \n적용하는 방식으로 예측', 'XP(eXtreme Programming) XP(eXtreme Programming)는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방 법이다.- XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.- 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반 영에 대한 가시성을 높인다.- XP의 5가지 가치 : 의사소통(Communication), 단 순성(Simplicity), 용기(Courage), 존중(Respect), 피드 백(Feedback) 23.5, 22.4, 20.9 2400', '(Practice) 다른 사람과 함께 프로그래밍을 수행함으 Pair Programming 로써 개발에 대한 책임을 공동으로 나눠 (짝 프로그래밍) 갖는 환경을 조성함 Collective Ownership 개발 코드에 대한 권한과 책임을 공동으 (공동 코드 소유) 로 소유함- 개발자가 실제 코드를 작성하기 전에 테 스트 케이스를 먼저 작성하므로 자신이 Test- Driven 무엇을 해야할지를 정확히 파악함 Development- 테스트가 지속적으로 진행될 수 있도록 (테스트 주도 개발) 자동화된 테스팅 도구(구조, 프레임워 크)를 사용함 개발에 참여하는 모든 구성원(고객 포함) Whole Team 들은 각자 자신의 역할이 있고 그 역할에 (전체 팀) 대한 책임을 가져야 함 Continuous 모듈 단위로 나눠서 개발된 코드들은 하 Integration 나의 작업이 마무리될 때마다 지속적으로 (계속적인 통합) 통합됨 Design Improvement 프로그램 기능의 변경 없이, 단순화,', 'Small Releases \n짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 \n한다. \nShared Understanding \nCoding Standards 소스 코드 작성 포맷과 규칙들을 \n표준화된 관례에 따라 작성한다. \nCollective Code Ownership \n시스템에 있는 소스 코드는 팀의 모든 프로그래머가 \n누구든지 언제라도 수정할 수 있다. \nSimple Design \n가능한 가장 간결한 디자인 상태를 유지한다. \nSystem Metaphor 최종적으로 개발되어야 할 시스템의 구조를 기술한다. \nProgrammer Welfare \nSustainable Pace 일주일에 40 시간 이상 작업 금지. 2 주 \n연속 오버타임을 금지한다. \n효과적인 프로젝트 관리를 위한 3 대 요소 \n \n사람(People) - 인적 자원 \n문제(Problem) - 문제 인식 \n프로세스(Process) - 작업 계획 \n4. SCRUM \nSCRUM \nSCRUM 개념과 특징 ', '편집기, 컴파일러, 디버거 등의 다양한 도구를 하나의 인터페이스로 통합하여 제공한다. \n오류 체크를 시각화하여 확인 및 수정을 쉽도록 지원한다. \n컴파일에 필요한 외부 추가 기능을 연계하여 개발의 편의성을 높였다. \n종류 : 이클립스, 비주얼 스튜디오, XCode, 안드로이드 스튜디오, IDEA, VSC 등 \n빌드 자동화 도구 \n \n소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만든다. \n소프트웨어 개발자가 반복 작업해야 하는 코딩을 잘 짜여진 프로세스를 통해 자동으로 \n실행하여, 신뢰성 있는 결과물을 생산해 낼 수 있는 작업 방식 및 방법이다. \n소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 \n생성하는 프로그램이며, 지속해서 증가하는 라이브러리의 자동 추가 및 관리(전처리, \nPreprocessing)를 지원한다. \n최근에는 오픈소스인 Gradle 이 등장했으며, 구글이 안드로이드의 기본 빌드 시스템으로 \nGradle 을 선']","['객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?\n\n[보기]\n1) Coad 와 Yourdon 방법\n2) Booch 방법\n3) Jacobson 방법\n4) Wirfs-Brocks 방법', '대표적으로 DOS 및 Unix 등의 운영체제에서 조작을 위해 사용하던 것으로, 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스(User Interface)는?\n\n[보기]\n1) GUI(Graphical User Interface)\n2) CLI(Command Line Interface)\n3) CUI(Cell User Interface)\n4) MUI(Mobile User Interface)', '대표적으로 DOS 및 Unix 등의 운영체제에서 조작을 위해 사용하던 것으로 , 정해진 명령 문자열을 입력하여 시스템을 조작하는 사용자 인터페이스 (User Interface) 는 ?\n\n[보기]\n1) GUI(Graphical User Interface)\n2) CLI(Command Line Interface)\n3) CUI(Cell User Interface)\n4) MUI(Mobile User Interface)', 'S/W 각 기능의 원시 코드 라인수의 비관치 , 낙관치 , 기대치를 측정하 여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?\n\n[보기]\n1) Effort Per Task 기법\n2) 전문가 감정 기법\n3) 델파이기법\n4) LOC 기법', '배치 프로그램의 자동 수행 주기 중 사용자가 특정 조건을 설정해 두고 해당 조건이 충족될 때만 수행되도록 하는 것은?\n\n[보기]\n1) 정기 배치\n2) 이벤트성 배치\n3) On-Demand 배치\n4) 사용자 배치', 'FDD(Feature Driven Development, 기능 중심 개발) \nCrystal \nASD(Adaptive Software Development, 적응형 소프트웨어 개발방법론) \nDAD(Disciplined Agile Delivery, 학습 애자일 배포) \nAgile 선언문 \n \n프로세스나 도구보다 개인과의 소통이 더 중요하다. \n완벽한 문서보다 실행되는 소프트웨어가 더 중요하다. \n계약 협상보다 고객과의 협업이 더 중요하다. \n계획을 따르는 것보다 변경에 대한 응답이 더 중요하다. \nXP(eXtreme Programming) \nXP(eXtreme Programming) \n \n1999 년 Kent Beck 이 제안하였으며, 개발 단계 중 요구사항이 시시각각 변동이 심한 \n경우 적합한 방법론이다. \n요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 한다. \n요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 \n적용하는 방식으로 예측성보다는 적응성에 더 높은 가치를 부여한 방법이다. \n고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법이다. \nXP 핵심 가치 \n \n소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향한다. \n단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다. \nFeedback : 소프트웨어 개발에서 변화는 불가피하다. 이러한 변화는 지속적 테스트와 \n통합, 반복적 결함 수정 등 빠르게 피드백한다. \n용기(Courage) : 고객 요구사항 변화에 능동적으로 대응한다. \n존중(Respect) : 개발 팀원 간의 상호 존중을 기본으로 한다. \nXP Process \n \n용어 \n설명 \nUser Story 일종의 요구사항으로 UML 의 유즈케이스와 같은 목적으로 생성되나, 형식이 \n없고 고객에 의해 작성된다는 것이 다르다. \nRelease Planning 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을', 'XP(eXtreme Programming) XP(eXtreme Programming)는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방 법이다.- XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.- 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반 영에 대한 가시성을 높인다.- XP의 5가지 가치 : 의사소통(Communication), 단 순성(Simplicity), 용기(Courage), 존중(Respect), 피드 백(Feedback) 23.5, 22.4, 20.9 2400', '(Practice) 다른 사람과 함께 프로그래밍을 수행함으 Pair Programming 로써 개발에 대한 책임을 공동으로 나눠 (짝 프로그래밍) 갖는 환경을 조성함 Collective Ownership 개발 코드에 대한 권한과 책임을 공동으 (공동 코드 소유) 로 소유함- 개발자가 실제 코드를 작성하기 전에 테 스트 케이스를 먼저 작성하므로 자신이 Test- Driven 무엇을 해야할지를 정확히 파악함 Development- 테스트가 지속적으로 진행될 수 있도록 (테스트 주도 개발) 자동화된 테스팅 도구(구조, 프레임워 크)를 사용함 개발에 참여하는 모든 구성원(고객 포함) Whole Team 들은 각자 자신의 역할이 있고 그 역할에 (전체 팀) 대한 책임을 가져야 함 Continuous 모듈 단위로 나눠서 개발된 코드들은 하 Integration 나의 작업이 마무리될 때마다 지속적으로 (계속적인 통합) 통합됨 Design Improvement 프로그램 기능의 변경 없이, 단순화, 유연 (디자인 개선) 또는 성 강화 등을 통해 시스템을 재구성함 Refactoring(리팩토링) Small Releases 릴리즈 기간을 짧게 반복함으로써 고객의 (소규모 릴리즈) 요구 변화에 신속히 대응할 수 있음 6 2400', 'Small Releases \n짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 \n한다. \nShared Understanding \nCoding Standards 소스 코드 작성 포맷과 규칙들을 \n표준화된 관례에 따라 작성한다. \nCollective Code Ownership \n시스템에 있는 소스 코드는 팀의 모든 프로그래머가 \n누구든지 언제라도 수정할 수 있다. \nSimple Design \n가능한 가장 간결한 디자인 상태를 유지한다. \nSystem Metaphor 최종적으로 개발되어야 할 시스템의 구조를 기술한다. \nProgrammer Welfare \nSustainable Pace 일주일에 40 시간 이상 작업 금지. 2 주 \n연속 오버타임을 금지한다. \n효과적인 프로젝트 관리를 위한 3 대 요소 \n \n사람(People) - 인적 자원 \n문제(Problem) - 문제 인식 \n프로세스(Process) - 작업 계획 \n4. SCRUM \nSCRUM \nSCRUM 개념과 특징 \n \n요구사항 변경에 신속하게 대처할 수 있는 반복적이고 점진적인 소규모 팀원 간 활발한 \n소통과 협동심이 필요한 팀 중심의 소프트웨어 개발 방법론이다. \n신속하게 반복적으로 실제 작동하는 소프트웨어를 제공한다. \n개발자들의 팀 구성과 각 구성원의 역할, 일정 결과물 및 그 외 규칙을 정하는 것을 \n말한다. \n기능 개선점에 우선순위를 부여하고, 개발 주기 동안 실제 동작 가능한 결과를 제공한다. \n개발 주기마다 적용된 기능이나 개선점의 리스트를 제공한다. \n커뮤니케이션을 위하여 팀은 개방된 공간에서 개발하고, 매일 15 분 정도 회의를 한다. \n팀원 스스로 팀을 구성해야 한다.(Self Organizing) \n개발 작업에 관한 모든 것을 팀원 스스로 해결해야 한다.(Cross Functional) \nSCRUM 기본 원리 \n \n기능 협업을 기준으로 배치된 팀은 스프린트 단위로 소프트웨어를 개발한다. \n스프린트는 고정된 30 일의 반복이며, 스프린트를 시행하는 작업은 고정된다.', '편집기, 컴파일러, 디버거 등의 다양한 도구를 하나의 인터페이스로 통합하여 제공한다. \n오류 체크를 시각화하여 확인 및 수정을 쉽도록 지원한다. \n컴파일에 필요한 외부 추가 기능을 연계하여 개발의 편의성을 높였다. \n종류 : 이클립스, 비주얼 스튜디오, XCode, 안드로이드 스튜디오, IDEA, VSC 등 \n빌드 자동화 도구 \n \n소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만든다. \n소프트웨어 개발자가 반복 작업해야 하는 코딩을 잘 짜여진 프로세스를 통해 자동으로 \n실행하여, 신뢰성 있는 결과물을 생산해 낼 수 있는 작업 방식 및 방법이다. \n소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 \n생성하는 프로그램이며, 지속해서 증가하는 라이브러리의 자동 추가 및 관리(전처리, \nPreprocessing)를 지원한다. \n최근에는 오픈소스인 Gradle 이 등장했으며, 구글이 안드로이드의 기본 빌드 시스템으로 \nGradle 을 선택하면서 사용자가 급증하였다. \n기능 : 코드 컴파일, 컴포넌트 패키징, 파일 조작, 개발 테스트 실행, 버전 관리 도구 \n통합, 문서 생성, 배포 기능, 코드 품질 분석 \n프로세스 : 컴파일 => 패키징 => 단위 테스트 => 정적 분석 => 리포팅 => 배포 => 최종 \n빌드 \n종류 : Gradle, Jenkins, Makefile, Ant, Maven 등 \nAnt \n아파치 소프트웨어 재단에서 개발. XML 기반 빌드 스크립트를 사용한다. \n정해진 규칙이 없고, 절차적이다.(명확한 빌드 절차 정의가 필요). \n생명주기를 갖지 않아 각 Target 에 대한 의존관계와 작업을 정의해 주어야 한다. \n유연성이 높으나 프로젝트가 복잡해지는 경우 Build 과정의 이해가 어려워진다. \nXML, Remote Repository 를 가져올 수 없고 스크립트의 재사용이 어렵다. \nMaven \n프로젝트에 필요한 모든 종속성(Dependency)을 리스트의 형태로 Maven 에 알려서']"
2,자료 흐름도 (Data Flow Diagram) 의 구성 요소로 옳은 것은 ?,"[""process, data flow, data store, comment"", ""process, data flow, data store, terminator"", ""data flow, data store, terminator, data dictionary"", ""process, data store, terminator, mini-spec""]",2,2,소프트웨어 설계,소프트웨어 설계,"자료 흐름도(DFD; Data Flow Diagram)는 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트라고도 한다. 자료 흐름도에서는 자료의 흐름과 기능을 프로세스(Process), 자료 흐름(Flow), 자료 저장소(Data Store), 단말(Terminator)의 네 가지 기본 기호로 표시한다.

- 프로세스(Process): 자료를 변환시키는 시스템의 한 부분(처리 과정)을 나타낸다.
- 자료 흐름(Data Flow): 자료의 이동(흐름)이나 연관관계를 나타낸다.
- 자료 저장소(Data Store): 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타낸다.
- 단말(Terminator): 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받는다.

따라서, 자료 흐름도의 구성 요소로 옳은 것은 'process, data flow, data store, terminator'이다.

과목: 소프트웨어 설계","['스키마의 종류 중 조직이나 기관의 총괄적 입장에서 본 데이터베이스의 전체적인 논리적 구조로서 , 모든 응용 프로그램이나 사용자들이필요로 하는 데이터를 종합한 조직 전체의 데이터베이스 구조를의미하는 것은?', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며 , 인터페이스를 통해서만 접근할 수 있는 것은?']","['자료 흐름도(DFD) 자료 흐름도(DFD; Data Flow Diagram)는 요구사항 분 석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트라고도 한다.- 자료 흐름도에서는 자료의 흐름과 기능을 프로세스 (Process), 자료 흐름(Flow), 자료 저장소(Data Store), 단말(Terminator)의 네 가지 기본 기호로 표시한다. 표기법 기 호 의 미 Yourdon/ Gane/ DeMacro Sarson- 자료를 변환시키는 시스템의 한 부분(처 리 과정)을 나타내며 처리, 기능, 변환, 버 프로세스 물품 확인 물품 확인 블이라고도 함 (Process)- 원이나 둥근 사각 형으로 표시하고 그 안에 프로세스 이름을 기입함- 자료의 이동(흐름) 이나 연관관계를 자료 흐름 물품 코드 나타냄 (Data Flow)- 화살표 위에 자료 의 이름을 기입함- 시스템에서의 자료 저장소(파일, 데이 자료 저장소 물품대장 물품대장 ID 터', '일반적으로 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Overview \nDiagram), 세부적 다이어그램(Detail Diagram)으로 구성된다. \n구조도(가시적 도표, Visual Table of Contents), 개요, 도표(Index Diagram), \n상세 도표(Detail Diagram)로 구성된다. \n가시적 도표는 전체적인 기능과 흐름을 보여주는 구조이다. \n기능과 자료의 의존 관계를 동시에 표현할 수 있다. \n보기 쉽고 이해하기 쉬우며 유지보수가 쉽다. \n하향식 소프트웨어 개발을 위한 문서화 도구이다. \nV-모델 \n \n폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델이다. \n세부적인 프로세스로 구성되어 있어서 신뢰도 높은 시스템 개발에 효과적이다. \n개발 단계의 작업을 확인하기 위해 테스트 작업을 수행한다. \n생명주기 초반부터 테스트 작업을 지원한다. \n코드뿐만 아니라 요구사항과 설계 결과도 테스트할 수 있어야 한다. \n폭포', '구성 요소 \n의미 \n표기법 \n프로세스(Process) 자료를 변환시키는 시스템의 한 부분을 나타낸다. 원 안에 프로세스 \n이름 \n자료 흐름(Data Flow) \n자료의 이동(흐름)을 나타낸다. \n자료 이름 아래 ㅡ▶ \n자료 저장소(Data Store) 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타낸다.\n \n가로 수평선 사이 자료 저장소 이름 \n단말(Terminator) - 자료의 발생지와 종착지를 나타낸다. \n- 시스템의 외부에 존재하는 사람이나 조직체이다. \n직사각형 안에 단말 이름 \n소단위 명세서(Mini-Specification) \n \n세분화된 자료 흐름도에서 최하위 단계 프로세스의 처리 절차를 설명한 것이다. \n세분화된 자료 흐름도에서 최하위 단계 버블(프로세스)의 처리 절차를 기술한 것으로 \n프로세스 명세서라고도 한다. \n분석가의 문서이며, 자료 흐름도(DFD)를 지원하기 위하여 작성한다. \n서술 문장, 구조적 언어, 의사 결정 나무, 의사 결정 표(판단표), 그래프', '구조적 설계의 특징과 기본 구조 \n \n특징 : 하향식 기법, 신뢰성 향상, 유연성 제공, 재사용 용이 \n기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조 = 조건(Condition) 구조, \n반복(Repetition) 구조 \n구조적 분석 도구 \n자료 흐름도(DFD : Data Flow Diagram) \n \n시스템 내의 모든 자료 흐름을 4 가지의 기본 기호(처리, 자료 흐름, 자료 저장소, \n단말)로 기술하고 이런 자료 흐름을 중심으로 한 분석용 도구이다. \nDFD 의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시하고 구조적 분석 기법에 \n이용된다. \n시스템이나 프로그램 간의 총체적인 데이터 흐름을 표시할 수 있으며, 기본적인 데이터 \n요소와 그들 사이의 데이터 흐름 형태로 기술된다. \n다차원적이며 자료 흐름 그래프 또는 버블(Bubble) 차트라고도 한다. \n그림 중심의 표현이고 하향식 분할 원리를 적용한다. \n갱신하기 쉬워야 하며 이름의 중복', '자료 흐름도의 구성 요소 기호 표기법 프로세스(Process) 물품 확인 물품 코드 자료 흐름(Data Flow) 자료 저장소(Data Store) 물품대장 단말(Terminator) 공장']","['스키마의 종류 중 조직이나 기관의 총괄적 입장에서 본 데이터베이스의 전체적인 논리적 구조로서 , 모든 응용 프로그램이나 사용자들이필요로 하는 데이터를 종합한 조직 전체의 데이터베이스 구조를의미하는 것은?\n\n[보기]\n1) 관계 스키마\n2) 외부 스키마\n3) 내부 스키마\n4) 개념 스키마', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?\n\n[보기]\n1) Object\n2) Dynamic\n3) Function\n4) Static', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?\n\n[보기]\n1) Object\n2) Dynamic\n3) Function\n4) Static', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?\n\n[보기]\n1) Model\n2) Sheet\n3) Component\n4) Cell', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며 , 인터페이스를 통해서만 접근할 수 있는 것은?\n\n[보기]\n1) Model\n2) Sheet\n3) Component\n4) Cell', '자료 흐름도(DFD) 자료 흐름도(DFD; Data Flow Diagram)는 요구사항 분 석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트라고도 한다.- 자료 흐름도에서는 자료의 흐름과 기능을 프로세스 (Process), 자료 흐름(Flow), 자료 저장소(Data Store), 단말(Terminator)의 네 가지 기본 기호로 표시한다. 표기법 기 호 의 미 Yourdon/ Gane/ DeMacro Sarson- 자료를 변환시키는 시스템의 한 부분(처 리 과정)을 나타내며 처리, 기능, 변환, 버 프로세스 물품 확인 물품 확인 블이라고도 함 (Process)- 원이나 둥근 사각 형으로 표시하고 그 안에 프로세스 이름을 기입함- 자료의 이동(흐름) 이나 연관관계를 자료 흐름 물품 코드 나타냄 (Data Flow)- 화살표 위에 자료 의 이름을 기입함- 시스템에서의 자료 저장소(파일, 데이 자료 저장소 물품대장 물품대장 ID 터베이스)를 나타냄 (Data Store)- 도형 안에 자료 저 장소 이름을 기입함- 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지 고 출력 데이터를 단말 공장 (Terminator) 받음(정보의 생산자 와 소비자)- 도형 안에 이름을 기입함 9 2400', '일반적으로 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Overview \nDiagram), 세부적 다이어그램(Detail Diagram)으로 구성된다. \n구조도(가시적 도표, Visual Table of Contents), 개요, 도표(Index Diagram), \n상세 도표(Detail Diagram)로 구성된다. \n가시적 도표는 전체적인 기능과 흐름을 보여주는 구조이다. \n기능과 자료의 의존 관계를 동시에 표현할 수 있다. \n보기 쉽고 이해하기 쉬우며 유지보수가 쉽다. \n하향식 소프트웨어 개발을 위한 문서화 도구이다. \nV-모델 \n \n폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델이다. \n세부적인 프로세스로 구성되어 있어서 신뢰도 높은 시스템 개발에 효과적이다. \n개발 단계의 작업을 확인하기 위해 테스트 작업을 수행한다. \n생명주기 초반부터 테스트 작업을 지원한다. \n코드뿐만 아니라 요구사항과 설계 결과도 테스트할 수 있어야 한다. \n폭포수 모형보다 반복과 재처리 과정이 명확하다. \n테스트 작업을 단계별로 구분하므로 책임이 명확해진다. \n애자일(Agile) 개발 방법론 \n애자일(Agile) 개발방법론 \n \n날렵한, 재빠른 이란 사전적 의미가 있다. \n특정 방법론이 아닌 소프트웨어를 빠르고 낭비 없이 제작하기 위해 고객과의 협업에 초점을 \n두고 소프트웨어 개발 중 설계 변경에 신속히 대응하여 요구사항을 수용할 수 있다. \n절차와 도구보다 개인과 소통을 중요시하고 고객과의 피드백을 중요하게 생각한다. \n소프트웨어가 잘 실행되는데 가치를 두며, 소프트웨어 배포 시차를 최소화할 수 있다. \n특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 \n커뮤니케이션 변화 \n종류 \n익스트림 프로그래밍(XP, eXtreame Programming) \n스크럼(SCRUM) \n린(Lean) \nDSDM(Dynamic System Development Method, 동적 시스템 개발 방법론)', '구성 요소 \n의미 \n표기법 \n프로세스(Process) 자료를 변환시키는 시스템의 한 부분을 나타낸다. 원 안에 프로세스 \n이름 \n자료 흐름(Data Flow) \n자료의 이동(흐름)을 나타낸다. \n자료 이름 아래 ㅡ▶ \n자료 저장소(Data Store) 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타낸다.\n \n가로 수평선 사이 자료 저장소 이름 \n단말(Terminator) - 자료의 발생지와 종착지를 나타낸다. \n- 시스템의 외부에 존재하는 사람이나 조직체이다. \n직사각형 안에 단말 이름 \n소단위 명세서(Mini-Specification) \n \n세분화된 자료 흐름도에서 최하위 단계 프로세스의 처리 절차를 설명한 것이다. \n세분화된 자료 흐름도에서 최하위 단계 버블(프로세스)의 처리 절차를 기술한 것으로 \n프로세스 명세서라고도 한다. \n분석가의 문서이며, 자료 흐름도(DFD)를 지원하기 위하여 작성한다. \n서술 문장, 구조적 언어, 의사 결정 나무, 의사 결정 표(판단표), 그래프 등을 이용하여 \n기술한다. \n구조적 언어, 의사 결정 나무, 의사 결정표 \n \n구조적 언어 : 자연어 일부분으로 한정된 단어와 문형, 제한된 구조를 사용하여 명세서를 \n작성하는데 이용하는 명세 언어이다. \n의사 결정 나무 : 현재 상황과 목표와의 상호 관련성을 나무의 가지를 이용해 표현한 \n것으로 불확실한 상황에서의 의사결정을 위한 분석 방법이다. \n의사 결정표(Decision Table) : 복잡한 의사결정 논리를 기술하는데 사용하며, 주로 \n자료 처리 분야에서 이용된다. \n자료 사전(DD : Data Dictionary) \n \n시스템과 관련된 모든 자료의 명세와 자료 석성을 파악할 수 있도록 조직화한 도구이다. \n표기법 \n기호 \n의미 \n설명 \n= \n자료의 정의 ~로 구성되어 있다.(is compose of). \n+ \n자료의 연결 그리고(and, along with) \n( ) \n자료의 생략 생략 가능한 자료(optional)', '구조적 설계의 특징과 기본 구조 \n \n특징 : 하향식 기법, 신뢰성 향상, 유연성 제공, 재사용 용이 \n기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조 = 조건(Condition) 구조, \n반복(Repetition) 구조 \n구조적 분석 도구 \n자료 흐름도(DFD : Data Flow Diagram) \n \n시스템 내의 모든 자료 흐름을 4 가지의 기본 기호(처리, 자료 흐름, 자료 저장소, \n단말)로 기술하고 이런 자료 흐름을 중심으로 한 분석용 도구이다. \nDFD 의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시하고 구조적 분석 기법에 \n이용된다. \n시스템이나 프로그램 간의 총체적인 데이터 흐름을 표시할 수 있으며, 기본적인 데이터 \n요소와 그들 사이의 데이터 흐름 형태로 기술된다. \n다차원적이며 자료 흐름 그래프 또는 버블(Bubble) 차트라고도 한다. \n그림 중심의 표현이고 하향식 분할 원리를 적용한다. \n갱신하기 쉬워야 하며 이름의 중복을 제거하여 이름으로 정의를 쉽게 찾을 수 있도록 한다. \n정의하는 방식이 명확해야 한다. \n자료 흐름도(DFD) 작성 원칙 \n \n출력 자료 흐름은 입력 자료 흐름을 이용해 생성해야 한다. \n입력, 출력 자료 자체에 대해서만 인지하고 자료의 위치나 방향은 알 필요가 없다. \n자료 흐름 변환의 형태에는 본질 변환, 합성의 변환, 관점의 변환, 구성의 변환 등이 \n있다. \n자료 보존의 원칙 : 출력 자료 흐름은 반드시 입력 자료 흐름을 이용해 새엇ㅇ한다. \n최소 자료 입력의 원칙 : 출력 자료를 산출하는데 필요한 최소의 자료 흐름만 입력한다. \n독립성의 원칙 : 프로세스는 오직 자신의 입력 자료와 출력 자료 자체에 대해서만 알면 \n된다. \n지속성의 원칙 : 프로세스는 항상 수행하고 있어야 한다. \n순차 처리의 원칙 : 입력 자료 흐름의 순서는 출력되는 자료 흐름에서도 지키도록 한다. \n영구성의 원칙 : 자료 저장소의 자료는 입력으로 사용해도 삭제되지 않는다. \n데이터(자료) 흐름도', '자료 흐름도의 구성 요소 기호 표기법 프로세스(Process) 물품 확인 물품 코드 자료 흐름(Data Flow) 자료 저장소(Data Store) 물품대장 단말(Terminator) 공장']"
3,분산 시스템에서의 미들웨어 (Middleware) 와 관련한 설명으로 틀린 것은?,"[""분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는 소프트웨어로 볼 수 있다."", ""위치 투명성 (Location Transparency) 을 제공한다 ."", ""분산 시스템의 여러 컴포넌트가 요구하는 재사용 가능한 서비스의 구현을 제공한다."", ""애플리케이션과 사용자 사이에서만 분산 서비스를 제공한다.""]",4,4,소프트웨어 설계,소프트웨어 설계,"미들웨어(Middleware)는 분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는 소프트웨어로 볼 수 있다. 
미들웨어는 위치 투명성 (Location Transparency) 을 제공하고, 분산 시스템의 여러 컴포넌트가 요구하는 재사용 가능한 서비스의 구현을 제공한다. 
하지만, 애플리케이션과 사용자 사이에서만 분산 서비스를 제공하는 것이 아니라, 운영체제와 응용 프로그램 사이에서 다양한 서비스를 제공하고, 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다. 
따라서, 보기 4번 '애플리케이션과 사용자 사이에서만 분산 서비스를 제공한다.'는 미들웨어에 대한 설명으로 틀린 것이다.

과목: 소프트웨어 설계","['다음 내용이 설명하는 스토리지 시스템은 ? ㆍ하드디스크와 같은 데이터 저장장치를 호스트버스 어댑 터에 직접 연결하는 방식 ㆍ저장장치와 호스트 기기 사이에 네트워크 디바이스가 있지 말아야 하고 직접 연결하는 방식으로 구성', '정규화된 엔티티 , 속성 , 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복 , 통합 , 분리 등을 수행하는 데이터 모델링 기법 은?', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?']","['미들웨어(Middleware) 미들웨어는 미들(Middle)과 소프트웨어(Software)의 합 성어로, 운영체제와 응용 프로그램, 또는 서버와 클라 이언트 사이에서 다양한 서비스를 제공하는 소프트웨어 이다.- DB는 데이터베이스 벤더에서 제공하는 클라 이언트에서 원격의 데이터베이스와 연결하기 DB 위한 미들웨어 (DataBase)- DB를 사용하여 시스템을 구축하는 경우 보통 2- Tier 아키텍처라고 함 RPC(원격 프로시저 호출)는 응용 프로그램의 프 RPC (Remote 로시저를 사용하여 원격 프로시저를 마치 로컬 Procedure Call) 프로시저처럼 호출하는 방식의 미들웨어- MOM(메시지 지향 미들웨어)은 메시지 기반의 MOM 비동기형 메시지를 전달하는 방식의 미들웨어 (Message Oriented- 온라인 업무보다는 이기종 분산 데이터 시스 Middleware) 템의 데이터 동기를 위해 많이 사용됨- TP- Monitor(트랜잭션 처리 모니터)는 항공기 나 철도 예', '분산 데이터베이스- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site) 에 분산되어 있는 데이터베이스를 말한다.- 데이터베이스 설계 및 소프트웨어 개발이 어렵다.- 분산 데이터베이스의 구성 요소 : 분산 처리기, 분산 데이 터베이스, 통신 네트워크', '분산 데이터베이스- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site) 에 분산되어 있는 데이터베이스를 말한다.- 데이터베이스 설계 및 소프트웨어 개발이 어렵다.- 분산 데이터베이스의 구성 요소 : 분산 처리기, 분산 데이 터베이스, 통신 네트워크', '미들웨어(Middleware)- 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다.- 운영체제와 응용 프로그램 사이에서 다양한 서비스를 제공한다.- 위치 투명성을 제공한다.- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용 소프트웨어를 사용해야 한다. 8', '미들웨어(Middleware)- 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다.- 운영체제와 응용 프로그램 사이에서 다양한 서비스를 제공한다.- 위치 투명성을 제공한다.- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용 소프트웨어를 사용해야 한다. 8']","['다음 내용이 설명하는 스토리지 시스템은 ? ㆍ하드디스크와 같은 데이터 저장장치를 호스트버스 어댑 터에 직접 연결하는 방식 ㆍ저장장치와 호스트 기기 사이에 네트워크 디바이스가 있지 말아야 하고 직접 연결하는 방식으로 구성\n\n[보기]\n1) DAS\n2) NAS\n3) N-SCREEN\n4) NFC', '정규화된 엔티티 , 속성 , 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복 , 통합 , 분리 등을 수행하는 데이터 모델링 기법 은?\n\n[보기]\n1) 정규화\n2) 반정규화\n3) 집단화\n4) 머징', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?\n\n[보기]\n1) 합성 중심\n2) 생성 중심\n3) 분리 중심\n4) 구조 중심', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?\n\n[보기]\n1) 합성 중심\n2) 생성 중심\n3) 분리 중심\n4) 구조 중심', '전자 칩과 같은 소프트웨어 부품 , 즉 블록모듈을 ( ) 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?\n\n[보기]\n1) 합성 중심\n2) 생성 중심\n3) 분리 중심\n4) 구조 중심', '미들웨어(Middleware) 미들웨어는 미들(Middle)과 소프트웨어(Software)의 합 성어로, 운영체제와 응용 프로그램, 또는 서버와 클라 이언트 사이에서 다양한 서비스를 제공하는 소프트웨어 이다.- DB는 데이터베이스 벤더에서 제공하는 클라 이언트에서 원격의 데이터베이스와 연결하기 DB 위한 미들웨어 (DataBase)- DB를 사용하여 시스템을 구축하는 경우 보통 2- Tier 아키텍처라고 함 RPC(원격 프로시저 호출)는 응용 프로그램의 프 RPC (Remote 로시저를 사용하여 원격 프로시저를 마치 로컬 Procedure Call) 프로시저처럼 호출하는 방식의 미들웨어- MOM(메시지 지향 미들웨어)은 메시지 기반의 MOM 비동기형 메시지를 전달하는 방식의 미들웨어 (Message Oriented- 온라인 업무보다는 이기종 분산 데이터 시스 Middleware) 템의 데이터 동기를 위해 많이 사용됨- TP- Monitor(트랜잭션 처리 모니터)는 항공기 나 철도 예약 업무 등과 같은 온라인 트랜잭션 TP- Monitor 업무에서 트랜잭션을 처리 및 감시하는 미들 (Transaction Processing 웨어 Monitor)- 사용자 수가 증가해도 빠른 응답 속도를 유지 해야 하는 업무에 주로 사용됨- ORB(객체 요청 브로커)는 객체 지향 미들웨어 ORB(Object 로 코바(CORBA) 표준 스펙을 구현한 미들웨어 Request- 최근에는 TP- Monitor의 장점인 트랜잭션 처리 Broker) 와 모니터링 등을 추가로 구현한 제품도 있음- WAS(웹 애플리케이션 서버)는 정적인 콘텐츠 를 처리하는 웹 서버와 달리 사용자의 요구에 WAS(Web 따라 변하는 동적인 콘텐츠를 처리하기 위해 Application 사용되는 미들웨어 Server)- 클라이언트/서버 환경보다는 웹 환경을 구현 하기 위한 미들웨어 정보처리기사 필기 요약', '분산 데이터베이스- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site) 에 분산되어 있는 데이터베이스를 말한다.- 데이터베이스 설계 및 소프트웨어 개발이 어렵다.- 분산 데이터베이스의 구성 요소 : 분산 처리기, 분산 데이 터베이스, 통신 네트워크', '분산 데이터베이스- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트(Site) 에 분산되어 있는 데이터베이스를 말한다.- 데이터베이스 설계 및 소프트웨어 개발이 어렵다.- 분산 데이터베이스의 구성 요소 : 분산 처리기, 분산 데이 터베이스, 통신 네트워크', '미들웨어(Middleware)- 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다.- 운영체제와 응용 프로그램 사이에서 다양한 서비스를 제공한다.- 위치 투명성을 제공한다.- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용 소프트웨어를 사용해야 한다. 8', '미들웨어(Middleware)- 분산 컴퓨팅 환경에서 서로 다른 기종 간을 연결한다.- 운영체제와 응용 프로그램 사이에서 다양한 서비스를 제공한다.- 위치 투명성을 제공한다.- 사용자가 미들웨어의 내부 동작을 확인하려면 별도의 응용 소프트웨어를 사용해야 한다. 8']"
4,디자인 패턴 사용의 장٠단점에 대한 설명으로 거리가 먼 것은?,"[""소프트웨어 구조 파악이 용이하다."", ""객체지향 설계 및 구현의 생산성을 높이는데 적합하다."", ""재사용을 위한 개발 시간이 단축된다."", ""절차형 언어와 함께 이용될 때 효율이 극대화된다.""]",4,4,소프트웨어 설계,소프트웨어 설계,"디자인 패턴 사용의 장단점에 대한 설명으로 거리가 먼 것은 '절차형 언어와 함께 이용될 때 효율이 극대화된다.'입니다. 디자인 패턴은 객체지향 설계 및 구현의 생산성을 높이는데 적합하며, 객체지향 프로그래밍 설계 시 유사한 상황에서 구조적인 문제를 해결할 수 있도록 방안을 제공합니다. 따라서 절차형 언어와 함께 이용될 때 효율이 극대화된다는 설명은 디자인 패턴의 장단점과 관련이 없습니다.

과목: 소프트웨어 설계","['다음 중 애자일(Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은?', '다음 중 애자일 (Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은 ?', 'UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?', '동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?', '소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?']","['디자인 패턴 사용의 장·단점- 범용적인 코딩 스타일로 인해 구조 파악이 용이하다.- 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.- 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약 된다.- 초기 투자 비용이 부담될 수 있다.- 개발자 간의 원활한 의사소통이 가능하다.- 설계 변경 요청에 대한 유연한 대처가 가능하다.- 객체지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않다. 23.7, 23.5, 23.2, 22.7, 22.3, 21.8, 21.5, 21.3, 20.8 2402', '자주 사용하는 설계 형태를 정형화하여 유형별로 설계 템플릿을 만들어 두고 소프트웨어 \n개발 중 나타나는 과제를 해결하기 위한 방법 중 한 가지다. \n다양한 응용 소프트웨어 시스템들을 개발할 때 서로 간에 공통점이 있으며, 이러한 \n유사점을 패턴이라 한다. \n개발자 간 원활한 의사소통, 소프트웨어 구조 파악 용이, 설계 변경에 대한 유연한 대처, \n개발의 효율성, 유지보수성, 운용성 등 소프트웨어 품질 향상에 도움을 준다. \n객체지향 프로그래밍 설계 시 유사한 상황에서 구조적인 문제를 해결할 수 있도록 방안을 \n제공해주며, Gof(Gang of Four) 분류가 가장 많이 사용된다. \n디자인 패턴을 사용할 때의 장/단점 \n \n장점 \n \n개발자 간의 월활한 의사소통을 지원한다. \n소프트웨어 구조 파악이 쉽다. \n재사용을 통한 개발 시간을 단축할 수 있다. \n설계 변경 요청에 대해 유연하게 대처할 수 있다. \n객체지향 설계 및 구현의 생산성을 높이는 데 적합하다. \n단점 \n \n객체지향 설', '객체 간의 혼란스러운 의존 관계들을 줄일 수 있는 행동 디자인 패턴 \n패턴은 객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 협력하도록 함. \n디자인 패턴 vs 아키텍처 패턴 \n \n아키텍처 패턴이 상위 설계에 이용된다. \n아키텍쳐 패턴 : 시스템 전체 구조를 설계하기 위한 참조 \n디자인 패턴 : 서브 시스템 내 컴포넌트와 그들 간의 관계를 구성하기 위한 참조 모델 \n17. 인터페이스 요구사항 확인 \n인터페이스 요구사항 \n인터페이스 내/외부 요구사항 \n \n개발 대상 조직 내/외부의 시스템 연동을 통하여 상호작용을 위한 접속 방법, 규칙을 \n의미한다. \n인터페이스 요구사항 구성 \n \n요구사항의 구성, 내/외부 인터페이스 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 \n방식, 송신 데이터, 인터페이스 주기, 기타 고려사항 \n인터페이스 요구사항의 분류 \n \n기능적 요구사항 : 소프트웨어가 내/외부 시스템 간의 연계를 통하여 수행될 기능과 \n관련하여 가져야 하는 기능적 속성에 ', '특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용된다. \n주로 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 \n방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다. \n15. 객체지향 설계 \n구조적, 절차적 프로그래밍과 객체지향 \n구조적 프로그래밍(Structured Programming) \n \n프로그램의 이해가 쉽고 디버깅 작업이 쉽다. \n한 개의 입구(입력)와 한 개의 출구(출력) 구조를 갖도록 한다. \nGOTO(분기) 문은 사용하지 않는다. \n구조적 프로그래밍의 기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조, \n반복(Iteration) 구조 \n절차적 프로그래밍(Procedural Programming) \n \n순서대로 일련의 명령어를 나열하여 프로그래밍한다. \nFunction 기반의 프로그래밍이며, 프로시저로써 Function 외에도 Subroutine 이 \n문법적으로 구현되어', '소프트웨어의 유지보수성 향상이 최우선 \n복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거 \n재사용을 수월하게 하며 소프트웨어의 수명을 연장하기 위함. \n과정 \n \n분석(Analysis) => 구성(Restructuring) => 역공학(Reverse Engineering) => \n이식(Migration) \n역공학 \n역공학의 개념 \n \n소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 \n정보를 재발견하거나 다시 만들어내는 작업이다. \n역공학의 가장 간단하고 오래된 형태는 재문서화라고 할 수 있다. \nCASE(Computer Aided Software Engineering) \nCASE \n \n소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 \n컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업이다. \n자료 흐름도 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어 CASE 도구이다.']","['다음 중 애자일(Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은?\n\n[보기]\n1) 공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.\n2) 동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.\n3) 계약 협상보다는 고객과의 협력을 가치 있게 여긴다.\n4) 계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다.', '다음 중 애자일 (Agile) 소프트웨어 개발에 대한 설명으로 틀린 것은 ?\n\n[보기]\n1) 공정과 도구보다 개인과의 상호작용을 더 가치 있게 여긴다.\n2) 동작하는 소프트웨어보다는 포괄적인 문서를 가치 있게 여긴다.\n3) 계약 협상보다는 고객과의 협력을 가치 있게 여긴다.\n4) 계획을 따르기보다 변화에 대응하기를 가치 있게 여긴다.', 'UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?\n\n[보기]\n1) Feedback\n2) Posture\n3) Module\n4) Hash', '동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?\n\n[보기]\n1) RCS(Revision Control System)\n2) RTS(Reliable Transfer Service)\n3) RPC(Remote Procedure Call)\n4) RVS(Relative Version System)', '소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.\n2) 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.\n3) 관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.\n4) 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.', '디자인 패턴 사용의 장·단점- 범용적인 코딩 스타일로 인해 구조 파악이 용이하다.- 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.- 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약 된다.- 초기 투자 비용이 부담될 수 있다.- 개발자 간의 원활한 의사소통이 가능하다.- 설계 변경 요청에 대한 유연한 대처가 가능하다.- 객체지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않다. 23.7, 23.5, 23.2, 22.7, 22.3, 21.8, 21.5, 21.3, 20.8 2402', '자주 사용하는 설계 형태를 정형화하여 유형별로 설계 템플릿을 만들어 두고 소프트웨어 \n개발 중 나타나는 과제를 해결하기 위한 방법 중 한 가지다. \n다양한 응용 소프트웨어 시스템들을 개발할 때 서로 간에 공통점이 있으며, 이러한 \n유사점을 패턴이라 한다. \n개발자 간 원활한 의사소통, 소프트웨어 구조 파악 용이, 설계 변경에 대한 유연한 대처, \n개발의 효율성, 유지보수성, 운용성 등 소프트웨어 품질 향상에 도움을 준다. \n객체지향 프로그래밍 설계 시 유사한 상황에서 구조적인 문제를 해결할 수 있도록 방안을 \n제공해주며, Gof(Gang of Four) 분류가 가장 많이 사용된다. \n디자인 패턴을 사용할 때의 장/단점 \n \n장점 \n \n개발자 간의 월활한 의사소통을 지원한다. \n소프트웨어 구조 파악이 쉽다. \n재사용을 통한 개발 시간을 단축할 수 있다. \n설계 변경 요청에 대해 유연하게 대처할 수 있다. \n객체지향 설계 및 구현의 생산성을 높이는 데 적합하다. \n단점 \n \n객체지향 설계/구현 위주로 사용된다. \n초기 투자 비용이 부담된다. \n디자인 패턴의 구성 요소 \n \n필수 요소 \n \n패턴의 이름 : 패턴을 부를 때 사용하는 이름과 패턴의 유형 \n문제 및 배경 : 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미 \n해법 : 패턴을 이루는 요소들, 관계, 협동(Collaboration) 과정 \n결과 : 패턴을 사용하면 얻게 되는 이점이나 영향 \n추가 요소 \n \n알려진 사례 : 간단한 적용 사례 \n샘플 코드 : 패턴이 적용된 원시 코드 \n원리, 정당성, 근거 \nGoF(Gangs of Four) 디자인 패턴 \n \n에릭 감마, 리처드 헬름, 랄프 존슨, 존 브리시데스가 제안 \n객체지향 설계 단계 중 재사용에 관한 유용한 설계를 디자인 패턴화하였다. \n생성 패턴, 구조 패턴, 행위 패턴으로 분류한다. \n생성 패턴 \n \n객체를 생성하는 것과 관련된 패턴이다. \n객체의 생성과 변경이 전체 시스템에 미치는 영향은 최소화하도록 만들어주어 유연성을', '객체 간의 혼란스러운 의존 관계들을 줄일 수 있는 행동 디자인 패턴 \n패턴은 객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 협력하도록 함. \n디자인 패턴 vs 아키텍처 패턴 \n \n아키텍처 패턴이 상위 설계에 이용된다. \n아키텍쳐 패턴 : 시스템 전체 구조를 설계하기 위한 참조 \n디자인 패턴 : 서브 시스템 내 컴포넌트와 그들 간의 관계를 구성하기 위한 참조 모델 \n17. 인터페이스 요구사항 확인 \n인터페이스 요구사항 \n인터페이스 내/외부 요구사항 \n \n개발 대상 조직 내/외부의 시스템 연동을 통하여 상호작용을 위한 접속 방법, 규칙을 \n의미한다. \n인터페이스 요구사항 구성 \n \n요구사항의 구성, 내/외부 인터페이스 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 \n방식, 송신 데이터, 인터페이스 주기, 기타 고려사항 \n인터페이스 요구사항의 분류 \n \n기능적 요구사항 : 소프트웨어가 내/외부 시스템 간의 연계를 통하여 수행될 기능과 \n관련하여 가져야 하는 기능적 속성에 대한 요구사항이다. \n비기능적 요구사항 : 기능에 관련되지 않는 사항으로 기능 요구사항을 만족시키는 바탕에서 \n정상적으로 작동하기 위한 시스템 내/외부의 제약 조건을 의미한다. \n인터페이스 요구사항 명세서 \n \n예시 \n \n요구사항 분류 시스템 인터페이스 요구사항 \n요구사항 번호 AAA-MOCK001 \n요구사항 명칭 소셜로그인 연동 \n요구사항 상세 설명 정의 \n네이버 아이디로 회원 연동 \n세부 내용 \n- 네이버 아이디 서비스인 네아로 API 를 이용하여 MOCK 사이트 회원 가입에 \n활용할 수 있도록 한다. \n- MOCK 사이트 네아로 서비스 아이디가 네이버에 전달되고, API 를 통하여 회원 정보를 \n가져온다. \n- 예상 트랜잭션 : 일 1,000 건 \n<추가 정의 내용> \n- 네이버 회원 정보 중 이름, 닉네임, 이메일, 전화번호를 가져온다. \n- 네아로 서비스를 통하여 회원 가입할 때 회원 아이디를 ""NAVER_""로 시작하도록 하여 \n구분한다. \n산출 정보', '특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용된다. \n주로 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 \n방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다. \n15. 객체지향 설계 \n구조적, 절차적 프로그래밍과 객체지향 \n구조적 프로그래밍(Structured Programming) \n \n프로그램의 이해가 쉽고 디버깅 작업이 쉽다. \n한 개의 입구(입력)와 한 개의 출구(출력) 구조를 갖도록 한다. \nGOTO(분기) 문은 사용하지 않는다. \n구조적 프로그래밍의 기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조, \n반복(Iteration) 구조 \n절차적 프로그래밍(Procedural Programming) \n \n순서대로 일련의 명령어를 나열하여 프로그래밍한다. \nFunction 기반의 프로그래밍이며, 프로시저로써 Function 외에도 Subroutine 이 \n문법적으로 구현되어 있다. \n절차형 언어의 경우 규모가 커지면 커질수록 함수가 기하급수적으로 늘어난다. \n함수가 타 프로그램과 문제를 일으킬 수 있는 문제점을 가지고 있다. \n프로그램과 별개로 데이터 취급이 되므로 완전하지 않고 현실 세계 문제를 프로그램으로 \n표현하는데 제약이 있다. \n객체지향 프로그래밍(Object Oriented Programming) \n \n컴퓨터 소프트웨어를 구조적인 코드 단위로 보는 것이 아니라 Object 단위로 구분하고 \nObject 간의 모음으로 설계하는 것이다. \n소프트웨어 내의 Object 는 서로 Message 를 주고받는다. \n처리 요구를 받은 객체가 자기 자신 안에 있는 내용을 가지고 처리하는 방식이다. \n프로그램이 단순화되고 생산성, 신뢰성이 높아져 대규모 개발에 많이 사용된다. \n객체지향 구성 요소 \n \n구분 \n설명 \nClass - 유사한 객체를 정의한 집합으로 속성+행위를 정의한 것으로 일반적인 Type 을 \n의미한다.', '소프트웨어의 유지보수성 향상이 최우선 \n복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거 \n재사용을 수월하게 하며 소프트웨어의 수명을 연장하기 위함. \n과정 \n \n분석(Analysis) => 구성(Restructuring) => 역공학(Reverse Engineering) => \n이식(Migration) \n역공학 \n역공학의 개념 \n \n소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 \n정보를 재발견하거나 다시 만들어내는 작업이다. \n역공학의 가장 간단하고 오래된 형태는 재문서화라고 할 수 있다. \nCASE(Computer Aided Software Engineering) \nCASE \n \n소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 \n컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업이다. \n자료 흐름도 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어 CASE 도구이다. \n작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대한다. \nCASE 가 제공하는 기능 \n \n개발을 신속하게 할 수 있고, 오류 수정이 쉬워 소프트웨어 품질이 향상된다. \n소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화시켜 주는 통합된 도구를 \n제공해주는 기술이다. \n소프트웨어 시스템의 문서화 및 명세화를 위한 그래픽 기능을 제공한다. \n소프트웨어 개발 단계의 표준화를 기할 수 있으며, 자료 흐름도 작성 기능을 제공한다. \n모델들 사이의 모순 검사 기능을 제공하며 다양한 소프트웨어 개발 모형을 지원한다. \n원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술 \nCASE 사용의 장점 \n \n소프트웨어 개발 기간 단축 및 개발 비용을 절약하여 소프트웨어 생산성을 향상시킨다. \n자동화된 검사를 통해 소프트웨어 품질이 향상된다. \n프로그램의 유지보수가 간편해지고 소프트웨어 모듈의 재사용성이 향상된다.']"
5,형상 관리 도구의 주요 기능으로 거리가 먼 것은 ?,"[""정규화(Normalization)"", ""체크인(Check-in)"", ""체크아웃(Check-out)"", ""커밋(commit)""]",1,1,소프트웨어 개발,소프트웨어 개발,"형상 관리 도구의 주요 기능에는 체크인(Check-in), 체크아웃(Check-out), 커밋(commit) 등이 포함됩니다. 정규화(Normalization)는 데이터베이스에서 데이터의 일관성을 유지하고 중복을 최소화하기 위한 프로세스입니다. 따라서, 형상 관리 도구와 직접적인 관련이 없는 옵션은 정규화(Normalization)입니다.
과목: 소프트웨어 개발","['럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?', 'COCOMO Model 중 기관 내부에서 개발된 중소 · 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용 , 비즈니스 자료 처리용으로 5 만 라인 이하의 소프트웨어를 개발하는 유형은 ?', 'UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며, 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?', 'UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며 , 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?']","['형상 관리 기능- 형상 식별 : 형상 관리 대상에 이름과 관리 번호를 부여 하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이 하도록 하는 작업- 버전 제어 : 소프트웨어 업그레이드나 유지 보수 과정에 서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위 해 특정 절차와 도구(Tool)를 결합시키는 작업- 형상 통제(변경 관리) : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업- 형상 감사 : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업- 형상 기록(상태 보고) : 형상의 식별, 통제, 감사 작업의 결과를 기록·관리하고 보고서를 작성하는 작업 23.2, 21.5, 20.8 2405', '요구사항 변경 요구를 관리하고, 변경 제어, 형상 관리 등의 통제를 지원하고 기준선에 \n대한 관리 및 형상 통제를 수행할 수 있다. \n형상 보고 및 감사 \n기준선의 무결성 평가 단계로서 개발자, 유지보수 담당자가 아닌 제3 자의 객관적인 확인 \n및 검증 과정을 통해 새로운 형상의 무결성을 확보하는 활동이다. -형상 감사 시 고려사항 \n- 명시된 변경이 정확하게 수정되었는가? - 기술 검토를 수행하였는가? - 개발 프로세스를 \n준수하였는가? - 변경 발생 시, 형상 관리 절차를 준수하였는가? - 변경에 대한 \n정보(변경일, 변경인, 변경사항)를 기록하였는가? \n형상 기록/보고 \n소프트웨어 개발 상태에 대한 보고서를 제공하는 단계로 기준선에 대한 변경과 처리 \n과정에서의 변경을 상태 보고에 모두 기록한다. \n기록/보고 항목 : 승인된 형상 리스트, 계획된 변경 상태, 승인된 변경의 구현 상태 \n형상 관리, 버전 관리, 변경 관리 \n \n형상 관리 \n(Configuration Managem', '추상화: 전체적이고 포괄적인 개념 설계 후 구체화 \n=> 유형 : 제어 추상화, 과정 추상화, 자료(데이터) 추상화 (제과자)  \n단계적 분해: 하향식 설계 (상위 중요 개념 -> 하위 개념) \n정보 은닉 : 모듈 내의 데이터나 기능에 다른 모듈이 접근하지 못하도록 \n모듈화 : 시스템이 모듈 단위로 분해되어야함 \na. 모듈: 시스템의 기능적 단위 \nb. 팬인(입력)은 높게, 팬아웃(출력)은 낮게!  \nc. 약한 결합도, 강한 응집도 필요 (표의 위일수록 좋은거) \n결합도 : 모델 사이의 의존정도 \n응집도 : 내부요소들의 관련 정도 \n자료 결합도: 자료를 주고받음 \n기능적 응집: 전 기능이 단일 문제와 관련 \n스탬프 결합도: 자료구조를 주고받음 \n순차적 응집 : A->B 순차적 수행 \n제어 결합도: 다른 모듈의 흐름 제어 \n교환(통신)적 응집 : 동일 입력 다른 기능 \n외부 결합: 모듈의 데이터를 외부에서 참\n조 \n절차적 응집 : 순차가 많음 \n공통 결합도 : 공통 데이터 영역 사용 ', 'b. 비기능 요구 사항 : 성능, 보안, 품질, 제약사항 등  \n2) 요구사항 분석 과정 \n(1) 도출 : 질문을 바탕으로 요구사항을 수집함 (프로토타이핑, 유스케이스 등 활용) \n(2) 분석 : 요구사항의 타당성 분석, 상충될 경우 중재 \n(3) 명세 : 문서화(명세서 작성) \n(4) 확인 : 방법 - 동료검토 / 워크스루 (사전 검토 후 회의) / 인스펙션 (전문가 검토) \n3) 요구사항 분석 시 이용되는 도구 \na. 자료흐름도 (Data Flow Diagram, DFD) : 자료의 흐름을 도형 중심으로 기술 \nb. 자료 사전 : 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록 \n기호 \n의미 \n= \n자료의 정의 (~is composed of) \n+ \n자료의 연결 (and) \n[ | ] \n자료의 선택 (or) \n{ } \n자료의 반복 \n( ) \n생략 가능 \n* * \n주석 \n3) 객체지향 분석 : 요구 사항을 객체 기준으로 분석 \n(1) 정의 \n객체지향 : 현실 세계의 대상을 하나', '2과목: 소프트웨어 개발\n\nⅡ 개발 + 테스트 : 개발하면서 테스트 진행 (개발 끝나고만 하는거 아님!) \n1. 기본적인 구현 방법 \n1) 자료 구조 \n(1) 선형 자료 구조 : 배열, 선형 리스트(연속리스트와 연결리스트), 스택, 큐, 데크 \na. 스택 \n특징 : 한 쪽으로만 입출력 => 후입선출 (LIFO, Last In First Out) \n오버플로우 : 스택이 가득 찬 상태에서 데이터 삽입시 발생 \n언더플로우 :스택이 텅 빈 상태에서 데이터 삭제시 발생 \n활용 : 인터럽트의 처리. 수식의 계산, 서브루틴 호출 작업 등 \nb. 큐 : 선입선출 (FIFO, First In First Out) \nc. 데크 : 삽입과 삭제가 양쪽 끝에서 모두 발생 가능 \n(2) 비선형 자료 구조 : 트리, 그래프 \na. 트리 \n정의 : 사이클이 없는 그래프 \n노드(정점) \n트리의 기본 요소 (하나의 기억 공간) \n링크(간선) \n노드와 노드를 연결하는 선 \n차수(Degree) \n연결된 하위 노드(자식']","['럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?\n\n[보기]\n1) Object\n2) Dynamic\n3) Function\n4) Static', '럼바우 (Rumbaugh) 분석 기법에서 정보 모델링이라고도 하며 , 시스 템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링은?\n\n[보기]\n1) Object\n2) Dynamic\n3) Function\n4) Static', 'COCOMO Model 중 기관 내부에서 개발된 중소 · 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용 , 비즈니스 자료 처리용으로 5 만 라인 이하의 소프트웨어를 개발하는 유형은 ?\n\n[보기]\n1) Embeded\n2) Organic\n3) Semi-Detached\n4) Semi-Embeded', 'UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며, 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?\n\n[보기]\n1) Association\n2) Dependency\n3) Realization\n4) Generalization', 'UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며 , 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?\n\n[보기]\n1) Association\n2) Dependency\n3) Realization\n4) Generalization', '형상 관리 기능- 형상 식별 : 형상 관리 대상에 이름과 관리 번호를 부여 하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이 하도록 하는 작업- 버전 제어 : 소프트웨어 업그레이드나 유지 보수 과정에 서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위 해 특정 절차와 도구(Tool)를 결합시키는 작업- 형상 통제(변경 관리) : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업- 형상 감사 : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업- 형상 기록(상태 보고) : 형상의 식별, 통제, 감사 작업의 결과를 기록·관리하고 보고서를 작성하는 작업 23.2, 21.5, 20.8 2405', '요구사항 변경 요구를 관리하고, 변경 제어, 형상 관리 등의 통제를 지원하고 기준선에 \n대한 관리 및 형상 통제를 수행할 수 있다. \n형상 보고 및 감사 \n기준선의 무결성 평가 단계로서 개발자, 유지보수 담당자가 아닌 제3 자의 객관적인 확인 \n및 검증 과정을 통해 새로운 형상의 무결성을 확보하는 활동이다. -형상 감사 시 고려사항 \n- 명시된 변경이 정확하게 수정되었는가? - 기술 검토를 수행하였는가? - 개발 프로세스를 \n준수하였는가? - 변경 발생 시, 형상 관리 절차를 준수하였는가? - 변경에 대한 \n정보(변경일, 변경인, 변경사항)를 기록하였는가? \n형상 기록/보고 \n소프트웨어 개발 상태에 대한 보고서를 제공하는 단계로 기준선에 대한 변경과 처리 \n과정에서의 변경을 상태 보고에 모두 기록한다. \n기록/보고 항목 : 승인된 형상 리스트, 계획된 변경 상태, 승인된 변경의 구현 상태 \n형상 관리, 버전 관리, 변경 관리 \n \n형상 관리 \n(Configuration Management) \n버전 관리 \n(Version Management) \n변경 관리(Version Management) \n버전, 변경 관리 개념을 포함하고, 프로젝트 진행 상황, 빌드와 릴리즈 퍼블리싱까지 모두 \n관리할 수 있는 통합 시스템이라고 할 수 있다. - 변경 이력을 추적 관리하는 가장 좋은 \n방법이 버전으로 구분하는 것이다. \n- 사소한 체크인, 체크아웃부터 릴리즈, 퍼블리싱의 과정을 버전으로 관리한다. \n- \n소스 코드의 변경 상황을 관리한다. \n- 문서의 변경 이력과 복원 등의 기능이 제공된다. \n버전 관리 도구 \n버전 관리 도구 구분 \n \n공유 폴더 방식 \n담당자 한 명이 공유 폴더 내 자료를 자신의 PC 로 복사한 후 컴파일하여 이상 유무를 \n확인하고, 파일의 오류가 확인되면, 해당 파일을 등록한 개발자에게 수정 의뢰한다. \n개발자들은 매일 완료된 파일을 공유 폴더에 복사하여 관리한다. \n파일에 이상이 없다면 다음날 각 개발자가 동작 여부를 다시 확인한다.', '추상화: 전체적이고 포괄적인 개념 설계 후 구체화 \n=> 유형 : 제어 추상화, 과정 추상화, 자료(데이터) 추상화 (제과자)  \n단계적 분해: 하향식 설계 (상위 중요 개념 -> 하위 개념) \n정보 은닉 : 모듈 내의 데이터나 기능에 다른 모듈이 접근하지 못하도록 \n모듈화 : 시스템이 모듈 단위로 분해되어야함 \na. 모듈: 시스템의 기능적 단위 \nb. 팬인(입력)은 높게, 팬아웃(출력)은 낮게!  \nc. 약한 결합도, 강한 응집도 필요 (표의 위일수록 좋은거) \n결합도 : 모델 사이의 의존정도 \n응집도 : 내부요소들의 관련 정도 \n자료 결합도: 자료를 주고받음 \n기능적 응집: 전 기능이 단일 문제와 관련 \n스탬프 결합도: 자료구조를 주고받음 \n순차적 응집 : A->B 순차적 수행 \n제어 결합도: 다른 모듈의 흐름 제어 \n교환(통신)적 응집 : 동일 입력 다른 기능 \n외부 결합: 모듈의 데이터를 외부에서 참\n조 \n절차적 응집 : 순차가 많음 \n공통 결합도 : 공통 데이터 영역 사용 \n시간적응집: 특정 시간에 필요한 기능 모음 \n내용 결합도 : 기능이나 자료를 직접 참조 \n논리적 응집 : 유사한 성격의 기능 모음 \n우연적 응집 : 관련 X \n(4) 아키텍처 패턴 : 전형적인 소프트웨어 아키텍처 설계 방법 \n파이프-필터 : 데이터 흐름(스트림)의 각 단계별로 캡슐화(묶어서 관리) \n모델-뷰-컨트롤러 : \na. 모델 : 핵심기능과 데이터보관 \nb. 뷰 : 사용자게 정보 표시 \nc. 컨트롤러 : 사용자의 요청을 처리하기 위해 모델에게 명령 \n마스터-슬레이브 : 동일한 구조의 슬레이브 컴포넌트들이 작업을 분할 수행 \n2) 디자인 패턴 \n(1) 정의 : 모듈의 역할, 모듈 간 인터페이스같은 세부적인 구현 방안 설계시의 패턴 \n(2) 종류 : 생성 패턴, 구조 패턴, 행위 패턴 \n(3) 생성 패턴 : 객체의 생성과 관련된 패턴 \n추상팩토리 : 인터페이스를 조합해 객체 생성 \n빌더 : 다른 객체를 조합해서 객체 생성', 'b. 비기능 요구 사항 : 성능, 보안, 품질, 제약사항 등  \n2) 요구사항 분석 과정 \n(1) 도출 : 질문을 바탕으로 요구사항을 수집함 (프로토타이핑, 유스케이스 등 활용) \n(2) 분석 : 요구사항의 타당성 분석, 상충될 경우 중재 \n(3) 명세 : 문서화(명세서 작성) \n(4) 확인 : 방법 - 동료검토 / 워크스루 (사전 검토 후 회의) / 인스펙션 (전문가 검토) \n3) 요구사항 분석 시 이용되는 도구 \na. 자료흐름도 (Data Flow Diagram, DFD) : 자료의 흐름을 도형 중심으로 기술 \nb. 자료 사전 : 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록 \n기호 \n의미 \n= \n자료의 정의 (~is composed of) \n+ \n자료의 연결 (and) \n[ | ] \n자료의 선택 (or) \n{ } \n자료의 반복 \n( ) \n생략 가능 \n* * \n주석 \n3) 객체지향 분석 : 요구 사항을 객체 기준으로 분석 \n(1) 정의 \n객체지향 : 현실 세계의 대상을 하나의 모듈로 만들어서 조립 \n객체: (데이터 + 기능)을 캡슐화 한 것(하나로 묶음) \n클래스 : 객체의 설계도 (속성, 연산을 정의한 틀)  \n(2) 객체 지향의 특징 \n캡슐화 : 데이터 + 함수(기능)을 하나로 묶어서 외부 은닉 효과 \n다형성 : 여러가지 형태를 가질 수 있음 \n(차 클래스가 생성한 객체가 모닝이든 소나타든 벤츠든 OK)  \n상속 : 부모 클래스의 모든 속성과 연산을 하위 클래스가 물려받음 \n(차의 설계도를 가지고 소나타 설계도를 만들고 소나타 객체 생산) \n연관성 : 객체들이 상호 참조함 \n(3) 객체지향 분석 기법 : 럼바우 기법(객체 모델링 기법)  \n순서 : 객체 모델링 -> 동적 모델링 -> 기능 모델링 (객동기) \n객체 모델링 : 객체와 객체간의 관계를 찾아내 객체 다이어그램으로. \n동적 모델링 : 동적인 행위를 상태 다이어그램으로 \n(시간의 흐름에 따른 제어 흐름, 상호작용, 동작 순서 등) \n기능 모델링 : DFD 이용, 자료 흐름 중심의 모델링', '2과목: 소프트웨어 개발\n\nⅡ 개발 + 테스트 : 개발하면서 테스트 진행 (개발 끝나고만 하는거 아님!) \n1. 기본적인 구현 방법 \n1) 자료 구조 \n(1) 선형 자료 구조 : 배열, 선형 리스트(연속리스트와 연결리스트), 스택, 큐, 데크 \na. 스택 \n특징 : 한 쪽으로만 입출력 => 후입선출 (LIFO, Last In First Out) \n오버플로우 : 스택이 가득 찬 상태에서 데이터 삽입시 발생 \n언더플로우 :스택이 텅 빈 상태에서 데이터 삭제시 발생 \n활용 : 인터럽트의 처리. 수식의 계산, 서브루틴 호출 작업 등 \nb. 큐 : 선입선출 (FIFO, First In First Out) \nc. 데크 : 삽입과 삭제가 양쪽 끝에서 모두 발생 가능 \n(2) 비선형 자료 구조 : 트리, 그래프 \na. 트리 \n정의 : 사이클이 없는 그래프 \n노드(정점) \n트리의 기본 요소 (하나의 기억 공간) \n링크(간선) \n노드와 노드를 연결하는 선 \n차수(Degree) \n연결된 하위 노드(자식 노드)의 개수 = 각 노드가 가진 가지 \n수 \n트리의 차수 \n노드의 차수 중 가장 많은 수 \n루트 노드 \n맨 위에 있는 노드 \n리프 노드 \n차수가 0인 노드 \n트리의 운행법(순회 방법) \n순회 순서 \nPreorder : root -> left -> right  \nABDCEFG \nInorder : left -> root -> right \nDBAECFG \nPostorder : left -> right -> root \nDBEGFCA \n2) 정렬 구현 (=> 실제로 구현했을 때의 결과를 주로 물어봄, 괄호는 시간복잡도) \n(1) 선택정렬: n개중 최소값을 1번에, n-1개중 최소값을 2번에 두는 것을 반복 (n^2) \n(2) 버블정렬: 인접한 두 개의 값을 비교해서 서로 교환하기를 반복 (n^2) \n(3) 삽입정렬: n번째 키를 적절한 위치(1 ~ n)에 삽입해서 정렬 \n(3) 퀵정렬 : 하나의 파일을 부분적으로 나누어가며 정렬 (nlogn ~ n^2)']"
6,패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준은?,"[""ISO/IEC2196"", ""IEEE19554"", ""ISO/IEC12119"", ""ISO/IEC14959""]",3,3,소프트웨어 개발,소프트웨어 개발,"ISO/IEC 12119는 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준입니다. 이 표준은 ISO/IEC 9126의 품질 모델을 따르며, 패키지 소프트웨어의 품질 요구사항을 규정하고 있습니다. 

과목: 소프트웨어 개발","['동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?', '어떤 외부 컴퓨터가 접속되면 접속 인가 여부를 점검해서 인가된 경우에는 접속이 허용되고, 그 반대의 경우에는 거부할 수 있는 접근제어 유틸리티는?', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며 , 인터페이스를 통해서만 접근할 수 있는 것은?', '공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해되고 한 가지로 해석될 수 있도록 작성하는 원칙은?']","['공식 명칭은 ISO/IEC 15504 이다. \nISO/IEC 12207 의 단점을 해결하기 위해 개발되었다. \nSPICE 모델의 범주 \n고객-공급자 프로세스 \n스프트웨어를 개발하여 고객에게 전달하는 것을 지원하고, 소프트웨어를 정확하게 운용하고 \n사용하도록 하기 위한 프로세스로 구성된다. \n10 개의 프로세스로 구성된다. \n공학 프로세스 \n시스템과 소프트웨어 제품을 직접 명세화, 구현, 유지보수하는 프로세스로 구성된다. \n9 개의 프로세스로 구성된다. \n지원 프로세스 \n소프트웨어 생명주기에서 다른 프로세스에 의해 이용되는 프로세스로 구성된다. \n4 개의 프로세스로 구성된다. \n관리 프로세스 \n소프트웨어 생명주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성된다. \n4 개의 프로세스로 구성된다. \n조직 프로세스 \n조직의 업무 목적을 수립하고, 조직이 업무 목표를 달성하는데 도움을 주는 프로세스로 \n구성된다. \n9 개의 프로세스로 구성된다. \nSPICE 모델의 레벨 \n \n레벨 5 ', '테스트 케이스(Test Case) 테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항 을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당된다.- 단위 모듈을 테스트하기 전에 테스트에 필요한 입력 데이터, 테스트 조건, 예상 결과 등을 모아 테스트 케이스 를 만든다.- 테스트 케이스를 이용하지 않고 수행하는 직관적인 테 스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다.- ISO/IEC/IEEE 29119- 3 표준에 따른 테스트 케이스의 구성 요소는 다음과 같다.- : 항목 식별자, 일련번호 식별자(Identifier)- : 테스트 대상(모듈 또는 기능) 테스트 항목(Test Item)- : 입력 데이터 또는 테스 입력 명세(Input Specification) 트 조건- : 테스트 케이스 수행 출력 명세(Output', 'ISO/IEC 12207은 ISO(International Organization for Standardization, 국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스로, 소프트웨어의 개발, 운영, 유 지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공한다.- ISO/IEC 12207은 기본 생명 주기 프로세스, 지원 생명 주기 프로세스, 조직 생명 주기 프로세스로 구분한다. 기본 생명 주기 획득, 공급, 개발, 운영, 유지보수 프로세스 프로세스 지원 생명 주기 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 프로세스 형상 관리, 문제 해결 프로세스 조직 생명 주기 관리, 기반 구조, 훈련, 개선 프로세스 프로세스 23.2, 20.9, 20.6 2417', '작성 지침 정의 => 구성 요소 정의 => 구성 요소별 내용 작성 => 사용자 메뉴얼 검포 \n \n소프트웨어 국제 표준 품질 특성 \n \nISO/IEC 9126 \nInformation Technology-Software Quality Characteristices and Metrucs \n소프트웨어 품질 특성과 척도에 관한 지침이다. \n고객 관점에서 소프트웨어에 관한 품질 특성과 품질 부 특성을 정의한다. \nISO/IEC 12199 \nISO/IEC 9126 의 품질 모델을 따르며 패키지 소프트웨어의 일반적인 제품 품질 요구사항 \n및 테스트를 위한 국제 표준이다. \n제품 설명서, 사용자 문서 및 프로그램으로 구분하여 각각 품질 요구사항을 규정하고 있다. \nISO.IEC 15504 \n소프트웨어 프로세스를 평가하고 개선함으로써 품질 및 생산성을 높이고자 하는 표준이다. \n평가 수준에 따라 개발 기관의 능력 레벨을 In-complete, Performed, Managed \nEstablished,', ': 소프트웨어 품질의 측정과 평가에 필요 절차를 규정한 표준으로, 개발자, 구매자, 평가자 별로 수행해야 할 제품 평가 활동을 규정함- 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부를 나타냄- 하위 특성 : 적절성/적합성(Suitability), 정 기능성 (Functionality) 밀성/정확성(Accuracy), 상호 운용성 (Interoperability), 보안성(Security), 준수성 (Compliance)- 소프트웨어가 요구된 기능을 정확하고 일관되 게 오류 없이 수행할 수 있는 정도를 나타냄 신뢰성 (Reliability)- 하위 특성 : 성숙성(Maturity), 고장 허용성 (Fault Tolerance), 회복성(Recoverability)- 사용자와 컴퓨터 사이에 발생하는 어떠한 행 위에 대하여 사용자가 정확하게 이해하고 사 용하며, 향후 다시 사용하고 싶은 정도를 나 사용성 타냄 (Usability)- 하위 특성 : 이해성(Unde']","['동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?\n\n[보기]\n1) RCS(Revision Control System)\n2) RTS(Reliable Transfer Service)\n3) RPC(Remote Procedure Call)\n4) RVS(Relative Version System)', '어떤 외부 컴퓨터가 접속되면 접속 인가 여부를 점검해서 인가된 경우에는 접속이 허용되고, 그 반대의 경우에는 거부할 수 있는 접근제어 유틸리티는?\n\n[보기]\n1) tcp wrapper\n2) trace checker\n3) token finder\n4) change detector', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?\n\n[보기]\n1) Model\n2) Sheet\n3) Component\n4) Cell', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며 , 인터페이스를 통해서만 접근할 수 있는 것은?\n\n[보기]\n1) Model\n2) Sheet\n3) Component\n4) Cell', '공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해되고 한 가지로 해석될 수 있도록 작성하는 원칙은?\n\n[보기]\n1) 상호작용성\n2) 명확성\n3) 독립성\n4) 내용성', '공식 명칭은 ISO/IEC 15504 이다. \nISO/IEC 12207 의 단점을 해결하기 위해 개발되었다. \nSPICE 모델의 범주 \n고객-공급자 프로세스 \n스프트웨어를 개발하여 고객에게 전달하는 것을 지원하고, 소프트웨어를 정확하게 운용하고 \n사용하도록 하기 위한 프로세스로 구성된다. \n10 개의 프로세스로 구성된다. \n공학 프로세스 \n시스템과 소프트웨어 제품을 직접 명세화, 구현, 유지보수하는 프로세스로 구성된다. \n9 개의 프로세스로 구성된다. \n지원 프로세스 \n소프트웨어 생명주기에서 다른 프로세스에 의해 이용되는 프로세스로 구성된다. \n4 개의 프로세스로 구성된다. \n관리 프로세스 \n소프트웨어 생명주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성된다. \n4 개의 프로세스로 구성된다. \n조직 프로세스 \n조직의 업무 목적을 수립하고, 조직이 업무 목표를 달성하는데 도움을 주는 프로세스로 \n구성된다. \n9 개의 프로세스로 구성된다. \nSPICE 모델의 레벨 \n \n레벨 5 최적(Optimizing) 단계 \n정의된 프로세스와 표준 프로세스가 지속적으로 개선되는 단계이다. \n레벨 4 예측(Predictable) 단계 \n표준 프로세스 능력에 대해 정량적인 이해화 성능이 예측되는 단계이다. \n레벨 3 확립(Established) 단계 \n표준 프로세스를 사용하여 계획되고 관리된 단계이다. \n레벨 2 관리(Managed) 단계 \n프로세스가 정해진 절차에 따라 이뤄져 산출물을 내며, 모든 작업이 계획되고 추적되는 \n단계이다. \n레벨 1 수행(Performed) 단계 \n해당 프로세스의 목적은 달성하지만 계획되거나 추적되지 않은 단계이다. \n레벨 0 불완전(Incomplete) 단계 \n프로세스가 구현되지 않거나 프로세스 목적을 달성하지 못한 단계이다. \nCMM(Capability Maturity Model, 능력 성숙도 모델) \n \n조직의 업무 능력 평가 기준을 세우기 위한 평가 표준이다.', '테스트 케이스(Test Case) 테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항 을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당된다.- 단위 모듈을 테스트하기 전에 테스트에 필요한 입력 데이터, 테스트 조건, 예상 결과 등을 모아 테스트 케이스 를 만든다.- 테스트 케이스를 이용하지 않고 수행하는 직관적인 테 스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다.- ISO/IEC/IEEE 29119- 3 표준에 따른 테스트 케이스의 구성 요소는 다음과 같다.- : 항목 식별자, 일련번호 식별자(Identifier)- : 테스트 대상(모듈 또는 기능) 테스트 항목(Test Item)- : 입력 데이터 또는 테스 입력 명세(Input Specification) 트 조건- : 테스트 케이스 수행 출력 명세(Output Specification) 시 예상되는 출력 결과- : 필요한 하드웨어나 환경 설정(Environmental Needs) 소프트웨어의 환경- : 테스 특수 절차 요구(Special Procedure Requirement) 트 케이스 수행 시 특별히 요구되는 절차- : 테스트 케이스 의존성 기술(Inter- case Dependencies) 간의 의존성 정보처리기사 필기 요약 23.7, 23.2, 22.4 2404', 'ISO/IEC 12207은 ISO(International Organization for Standardization, 국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스로, 소프트웨어의 개발, 운영, 유 지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공한다.- ISO/IEC 12207은 기본 생명 주기 프로세스, 지원 생명 주기 프로세스, 조직 생명 주기 프로세스로 구분한다. 기본 생명 주기 획득, 공급, 개발, 운영, 유지보수 프로세스 프로세스 지원 생명 주기 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 프로세스 형상 관리, 문제 해결 프로세스 조직 생명 주기 관리, 기반 구조, 훈련, 개선 프로세스 프로세스 23.2, 20.9, 20.6 2417', '작성 지침 정의 => 구성 요소 정의 => 구성 요소별 내용 작성 => 사용자 메뉴얼 검포 \n \n소프트웨어 국제 표준 품질 특성 \n \nISO/IEC 9126 \nInformation Technology-Software Quality Characteristices and Metrucs \n소프트웨어 품질 특성과 척도에 관한 지침이다. \n고객 관점에서 소프트웨어에 관한 품질 특성과 품질 부 특성을 정의한다. \nISO/IEC 12199 \nISO/IEC 9126 의 품질 모델을 따르며 패키지 소프트웨어의 일반적인 제품 품질 요구사항 \n및 테스트를 위한 국제 표준이다. \n제품 설명서, 사용자 문서 및 프로그램으로 구분하여 각각 품질 요구사항을 규정하고 있다. \nISO.IEC 15504 \n소프트웨어 프로세스를 평가하고 개선함으로써 품질 및 생산성을 높이고자 하는 표준이다. \n평가 수준에 따라 개발 기관의 능력 레벨을 In-complete, Performed, Managed \nEstablished, Predictable, Optimizing level 등 6 단계로 구분하고 있다. \nISO 9901 \nQuality Systems-Model for Quality Assurance in Design, Development, \nProduction, Installation and Servicing \n설계, 개발, 생산, 설치 및 서비스 과정에 대한 품질 보증 모델이다. \n공급자와 구매자 각각의 관리 책임을 명시하고 있으며 운영 중인 품질 시스템이 이 표준에 \n적합할 경우 품질 인증을 부여할 수 있도록 한다. \n소프트웨어 품질 목표(Software Quality and Goals) \n \n운영 특성 \n정확성 \n사용자의 요구 기능을 충족시키는 정도 \n신뢰성 \n주어진 시간 동안 주어진 기능을 오류 없이 수행하는 정도 \n사용 용이성 \n사용에 필요한 노력을 최소화하고 쉽게 사용할 수 있는 정도 \n적절한 사용자 인터페이스와 문서를 가지고 있는 정도 \n효율성', ': 소프트웨어 품질의 측정과 평가에 필요 절차를 규정한 표준으로, 개발자, 구매자, 평가자 별로 수행해야 할 제품 평가 활동을 규정함- 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부를 나타냄- 하위 특성 : 적절성/적합성(Suitability), 정 기능성 (Functionality) 밀성/정확성(Accuracy), 상호 운용성 (Interoperability), 보안성(Security), 준수성 (Compliance)- 소프트웨어가 요구된 기능을 정확하고 일관되 게 오류 없이 수행할 수 있는 정도를 나타냄 신뢰성 (Reliability)- 하위 특성 : 성숙성(Maturity), 고장 허용성 (Fault Tolerance), 회복성(Recoverability)- 사용자와 컴퓨터 사이에 발생하는 어떠한 행 위에 대하여 사용자가 정확하게 이해하고 사 용하며, 향후 다시 사용하고 싶은 정도를 나 사용성 타냄 (Usability)- 하위 특성 : 이해성(Understandability), 학습 성(Learnability), 운용성(Operability), 친밀성 (Attractiveness)- 사용자가 요구하는 기능을 할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는 효율성 지 정도를 나타냄 (Efficiency)- 하위 특성 : 시간 효율성(Time Behaviour), 자 원 효율성(Resource Behaviour)- 환경의 변화 또는 새로운 요구사항이 발생했 을 때 소프트웨어를 개선하거나 확장할 수 있 는 정도를 나타냄 유지 보수성 (Maintainability)- 하위 특성 : 분석성(Analyzability), 변경성 (Changeability), 안정성(Stability), 시험성 (Testability)- 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도를 나타냄 이식성- 하위 특성 : 적용성(Adaptability), 설치성 (Portability) (Installability), 대체성(Replaceability), 공존성 (Co- existence) 정보처리기사 필기 요약 2401']"
7,블랙박스 테스트 기법으로 거리가 먼 것은 ?,"[""기초 경로 검사"", ""동치 클래스 분해"", ""경계값 분석"", ""원인 결과 그래프""]",3,1,소프트웨어 개발,소프트웨어 개발,"블랙박스 테스트 기법에는 여러 가지가 있습니다. 
블랙박스 테스트는 소프트웨어의 내부 구조나 작동 원리를 모르는 상태에서 입력과 출력만을 고려하여 테스트하는 방법입니다. 
주어진 보기 중에서 '기초 경로 검사'는 화이트박스 테스트 기법에 속합니다. 
화이트박스 테스트는 소프트웨어의 내부 구조와 작동 원리를 고려하여 테스트하는 방법입니다. 
'기초 경로 검사'는 제어 구조를 분석하여 프로그램의 논리적 경로를 테스트하는 기법입니다. 
나머지 보기인 '동치 클래스 분해', '경계값 분석', '원인 결과 그래프'는 모두 블랙박스 테스트 기법에 속합니다. 
따라서, 블랙박스 테스트 기법으로 거리가 먼 것은 '기초 경로 검사'입니다.

 과목: 소프트웨어 개발","['S/W 각 기능의 원시 코드 라인수의 비관치 , 낙관치 , 기대치를 측정하 여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?', '세션 하이재킹을 탐지하는 방법으로 거리가 먼 것은?', '취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?', '취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?', '취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?']","['블랙박스 테스트의 종류- 입력 자료에 초점을 맞춰 테스트 케이스(동치 동치 분할 검사 클래스)를 만들고 검사하는 방법으로 동등 분 (Equivalence 할 기법이라고도 함 Partitioning- 프로그램의 입력 조건에 타당한 입력 자료와 Testing, 타당하지 않은 입력 자료의 개수를 균등하게 동치 클래스 하여 테스트 케이스를 정하고, 해당 입력 자료 분해) 에 맞는 결과가 출력되는지 확인하는 기법- 입력 자료에만 치중한 동치 분할 기법을 보완 하기 위한 기법 경계값 분석 (Boundary- 입력 조건의 중간값보다 경계값에서 오류가 발생 Value Analysis) 될 확률이 높다는 점을 이용하여 입력 조건의 경 계값을 테스트 케이스로 선정하여 검사하는 기법 원인- 효과 그래프 검사 입력 데이터 간의 관계와 출력에 영향을 미치는 (Cause- Effect 상황을 체계적으로 분석한 다음 효용성이 높은 Graphing 테스트 케이스를 선정하여 검사하는 기법 Testing)- 과거의', '입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법이다. \n입력 조건에 타당한 입력 자료와 그렇지 않은 자료의 개수를 균등하게 분할해 테스트 \n케이스를 설정한다. \n원인-효과 그래프 검사(Cause and Effect Graphing) \n입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한다. \n효용성이 높은 테스트 케이스를 선정해 검사한다. \n오류 예측 검사(Error Forecast) \n과거의 경험이나 감각으로 테스트하는 기법이다. \n다른 테스트 기법으로는 찾기 어려운 오류를 찾아내는 보충적 검사 기법이다. \n비교 검사(Comparision Testing) \n동일한 테스트 자료를 여러 버전의 프로그램에 입력하고 동일한 결과가 출력되는지 \n테스트하는 기법이다. \n경계값 분석(Boundary Value Analysis) \n입력 자료에만 치중한 동치 분할 기법을 보완한 기법이다. \n입력 조건 경계값에서 오류 발생 확률이 크다는 것을 활용하여 경계값을 테스트', '화이트박스 테스트의 종류- 대표적인 화이트박스 테스트 기법- 테스트 케이스 설계자가 절차적 설계의 논리적 기초 경로 검사 (Base Path 복잡성을 측정할 수 있게 해주는 테스트 기법 Testing) 으로, 테스트 측정 결과는 실행 경로의 기초를 정의하는 데 지침으로 사용됨 조건 검사(Condition Testing)- : 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법 제어 구조 검사 루프 검사(Loop Testing)- : 프로그램의 반복 (Control (Loop) 구조에 초점을 맞춰 실시하는 테스트 케 Structure 이스 설계 기법 Testing) 데이터 흐름 검사(Data Flow Testing)- : 프로그 램에서 변수의 정의와 변수 사용의 위치에 초 점을 맞춰 실시하는 테스트 케이스 설계 기법 2405', 'b. 비기능 요구 사항 : 성능, 보안, 품질, 제약사항 등  \n2) 요구사항 분석 과정 \n(1) 도출 : 질문을 바탕으로 요구사항을 수집함 (프로토타이핑, 유스케이스 등 활용) \n(2) 분석 : 요구사항의 타당성 분석, 상충될 경우 중재 \n(3) 명세 : 문서화(명세서 작성) \n(4) 확인 : 방법 - 동료검토 / 워크스루 (사전 검토 후 회의) / 인스펙션 (전문가 검토) \n3) 요구사항 분석 시 이용되는 도구 \na. 자료흐름도 (Data Flow Diagram, DFD) : 자료의 흐름을 도형 중심으로 기술 \nb. 자료 사전 : 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록 \n기호 \n의미 \n= \n자료의 정의 (~is composed of) \n+ \n자료의 연결 (and) \n[ | ] \n자료의 선택 (or) \n{ } \n자료의 반복 \n( ) \n생략 가능 \n* * \n주석 \n3) 객체지향 분석 : 요구 사항을 객체 기준으로 분석 \n(1) 정의 \n객체지향 : 현실 세계의 대상을 하나', '애플리케이션을 직접 실행하여 오류를 찾는 테스트 방식이다. \n소프트웨어 개발의 모든 단계에서 테스트를 수행한다. \n종류 : 블랙박스 테스트(명세 기반), 화이트박스 테스트(구조 기반) \n테스트 기반(Test Bases)에 따른 테스트 \n \n구분 \n설명 \n구조 기반 테스트 \n- 소프트웨어 내부의 구조(논리 흐름)에 따라 테스트 케이스를 \n작성하고 확인하는 테스트 방식이다. \n- 종류 : 구문 기반, 조건 기반, 데이터 흐름 \n명세 기반 테스트 \n- 사용자의 요구사항에 대한 명세를 기반으로 테스트 케이스를 \n작성하고 확인하는 테스트 방식이다. \n- 종류 : 동등 분할, 경계값 분석, 분류 트리, 상태 전이, 결정 테이블, 원인-결과, 조합 \n테스트, 시나리오, 오류 추정 \n경험 기반 테스트 \n- 테스터의 경험을 기반으로 수행하는 테스트 방식이다. \n- 요구사항에 대한 명세가 미흡하거나 테스트 시간에 제약이 있는 경우 수행하면 \n효과적이다. \n- 종류 : 에러 추정, 체크 리스트, 탐색적']","['S/W 각 기능의 원시 코드 라인수의 비관치 , 낙관치 , 기대치를 측정하 여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?\n\n[보기]\n1) Effort Per Task 기법\n2) 전문가 감정 기법\n3) 델파이기법\n4) LOC 기법', '세션 하이재킹을 탐지하는 방법으로 거리가 먼 것은?\n\n[보기]\n1) FTP SYN SEGMENT 탐지\n2) 비동기화 상태 탐지\n3) ACK STORM 탐지\n4) 패킷의 유실 및 재전송 증가 탐지', '취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?\n\n[보기]\n1) 서버 관리실 출입 통제\n2) 실행 프로세스 권한 설정\n3) 운영체제의 접근 제한\n4) 운영체제의 정보 수집 제한', '취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?\n\n[보기]\n1) 서버 관리실 출입 통제\n2) 실행 프로세스 권한 설정\n3) 운영체제의 접근 제한\n4) 운영체제의 정보 수집 제한', '취약점 관리를 위한 응용 프로그램의 보안 설정과 가장 거리가 먼 것은?\n\n[보기]\n1) 서버 관리실 출입 통제\n2) 실행 프로세스 권한 설정\n3) 운영체제의 접근 제한\n4) 운영체제의 정보 수집 제한', '블랙박스 테스트의 종류- 입력 자료에 초점을 맞춰 테스트 케이스(동치 동치 분할 검사 클래스)를 만들고 검사하는 방법으로 동등 분 (Equivalence 할 기법이라고도 함 Partitioning- 프로그램의 입력 조건에 타당한 입력 자료와 Testing, 타당하지 않은 입력 자료의 개수를 균등하게 동치 클래스 하여 테스트 케이스를 정하고, 해당 입력 자료 분해) 에 맞는 결과가 출력되는지 확인하는 기법- 입력 자료에만 치중한 동치 분할 기법을 보완 하기 위한 기법 경계값 분석 (Boundary- 입력 조건의 중간값보다 경계값에서 오류가 발생 Value Analysis) 될 확률이 높다는 점을 이용하여 입력 조건의 경 계값을 테스트 케이스로 선정하여 검사하는 기법 원인- 효과 그래프 검사 입력 데이터 간의 관계와 출력에 영향을 미치는 (Cause- Effect 상황을 체계적으로 분석한 다음 효용성이 높은 Graphing 테스트 케이스를 선정하여 검사하는 기법 Testing)- 과거의 경험이나 확인자의 감각으로 테스트하 오류 예측 검사 는 기법 (Error- 다른 블랙 박스 테스트 기법으로는 찾아낼 수 Guessing) 없는 오류를 찾아내는 일련의 보충적 검사 기 법이며, 데이터 확인 검사라고도 함 여러 버전의 프로그램에 동일한 테스트 자료를 비교 검사 (Comparison 제공하여 동일한 결과가 출력되는지 테스트하는 Testing) 기법 2405', '입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법이다. \n입력 조건에 타당한 입력 자료와 그렇지 않은 자료의 개수를 균등하게 분할해 테스트 \n케이스를 설정한다. \n원인-효과 그래프 검사(Cause and Effect Graphing) \n입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한다. \n효용성이 높은 테스트 케이스를 선정해 검사한다. \n오류 예측 검사(Error Forecast) \n과거의 경험이나 감각으로 테스트하는 기법이다. \n다른 테스트 기법으로는 찾기 어려운 오류를 찾아내는 보충적 검사 기법이다. \n비교 검사(Comparision Testing) \n동일한 테스트 자료를 여러 버전의 프로그램에 입력하고 동일한 결과가 출력되는지 \n테스트하는 기법이다. \n경계값 분석(Boundary Value Analysis) \n입력 자료에만 치중한 동치 분할 기법을 보완한 기법이다. \n입력 조건 경계값에서 오류 발생 확률이 크다는 것을 활용하여 경계값을 테스트 케이스로 \n선정해 검사한다. \n대표적인 명세 기반 기법(Specification based Technique)이다. \n27. 테스트 커버리지 \n테스트 커버리지 \n테스트 커버리지 \n \n주어진 테스트 케이스에 의해 수행되는 소프트웨어의 테스트 범위를 측정하는 테스트 품질 \n측정 기준이며, 테스트의 정확성과 신뢰성을 향상시키는 역할을 한다. \n기능 기반 \n테스트 대상 애플리케이션의 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 \n수를 측정하는 방법이다. \n기능 기반 테스트 커버리지는 100% 달성을 목표로 하며, 일반적으로 UI 가 많은 시스템의 \n경우 화면 수를 모수로 사용할 수도 있다. \nLine Coverage \n애플리케이션 전체 소스 코드의 Line 수를 모수로 테스트 시나리오가 수행한 소스 코드의 \nLine 수를 측정하는 방법이다. \n단위 테스트에서는 이 라인 커버리지를 척도로 삼기도 한다. \nCode Coverage', '화이트박스 테스트의 종류- 대표적인 화이트박스 테스트 기법- 테스트 케이스 설계자가 절차적 설계의 논리적 기초 경로 검사 (Base Path 복잡성을 측정할 수 있게 해주는 테스트 기법 Testing) 으로, 테스트 측정 결과는 실행 경로의 기초를 정의하는 데 지침으로 사용됨 조건 검사(Condition Testing)- : 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법 제어 구조 검사 루프 검사(Loop Testing)- : 프로그램의 반복 (Control (Loop) 구조에 초점을 맞춰 실시하는 테스트 케 Structure 이스 설계 기법 Testing) 데이터 흐름 검사(Data Flow Testing)- : 프로그 램에서 변수의 정의와 변수 사용의 위치에 초 점을 맞춰 실시하는 테스트 케이스 설계 기법 2405', 'b. 비기능 요구 사항 : 성능, 보안, 품질, 제약사항 등  \n2) 요구사항 분석 과정 \n(1) 도출 : 질문을 바탕으로 요구사항을 수집함 (프로토타이핑, 유스케이스 등 활용) \n(2) 분석 : 요구사항의 타당성 분석, 상충될 경우 중재 \n(3) 명세 : 문서화(명세서 작성) \n(4) 확인 : 방법 - 동료검토 / 워크스루 (사전 검토 후 회의) / 인스펙션 (전문가 검토) \n3) 요구사항 분석 시 이용되는 도구 \na. 자료흐름도 (Data Flow Diagram, DFD) : 자료의 흐름을 도형 중심으로 기술 \nb. 자료 사전 : 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록 \n기호 \n의미 \n= \n자료의 정의 (~is composed of) \n+ \n자료의 연결 (and) \n[ | ] \n자료의 선택 (or) \n{ } \n자료의 반복 \n( ) \n생략 가능 \n* * \n주석 \n3) 객체지향 분석 : 요구 사항을 객체 기준으로 분석 \n(1) 정의 \n객체지향 : 현실 세계의 대상을 하나의 모듈로 만들어서 조립 \n객체: (데이터 + 기능)을 캡슐화 한 것(하나로 묶음) \n클래스 : 객체의 설계도 (속성, 연산을 정의한 틀)  \n(2) 객체 지향의 특징 \n캡슐화 : 데이터 + 함수(기능)을 하나로 묶어서 외부 은닉 효과 \n다형성 : 여러가지 형태를 가질 수 있음 \n(차 클래스가 생성한 객체가 모닝이든 소나타든 벤츠든 OK)  \n상속 : 부모 클래스의 모든 속성과 연산을 하위 클래스가 물려받음 \n(차의 설계도를 가지고 소나타 설계도를 만들고 소나타 객체 생산) \n연관성 : 객체들이 상호 참조함 \n(3) 객체지향 분석 기법 : 럼바우 기법(객체 모델링 기법)  \n순서 : 객체 모델링 -> 동적 모델링 -> 기능 모델링 (객동기) \n객체 모델링 : 객체와 객체간의 관계를 찾아내 객체 다이어그램으로. \n동적 모델링 : 동적인 행위를 상태 다이어그램으로 \n(시간의 흐름에 따른 제어 흐름, 상호작용, 동작 순서 등) \n기능 모델링 : DFD 이용, 자료 흐름 중심의 모델링', '애플리케이션을 직접 실행하여 오류를 찾는 테스트 방식이다. \n소프트웨어 개발의 모든 단계에서 테스트를 수행한다. \n종류 : 블랙박스 테스트(명세 기반), 화이트박스 테스트(구조 기반) \n테스트 기반(Test Bases)에 따른 테스트 \n \n구분 \n설명 \n구조 기반 테스트 \n- 소프트웨어 내부의 구조(논리 흐름)에 따라 테스트 케이스를 \n작성하고 확인하는 테스트 방식이다. \n- 종류 : 구문 기반, 조건 기반, 데이터 흐름 \n명세 기반 테스트 \n- 사용자의 요구사항에 대한 명세를 기반으로 테스트 케이스를 \n작성하고 확인하는 테스트 방식이다. \n- 종류 : 동등 분할, 경계값 분석, 분류 트리, 상태 전이, 결정 테이블, 원인-결과, 조합 \n테스트, 시나리오, 오류 추정 \n경험 기반 테스트 \n- 테스터의 경험을 기반으로 수행하는 테스트 방식이다. \n- 요구사항에 대한 명세가 미흡하거나 테스트 시간에 제약이 있는 경우 수행하면 \n효과적이다. \n- 종류 : 에러 추정, 체크 리스트, 탐색적 테스팅 \n목적에 따른 테스트 \n \n구분 \n설명 \n성능 \n(Performance) \n소프트웨어의 응답 시간, 처리량 등을 테스트한다. \n회복 \n(Recovery) 소프트웨어에 고의로 부하를 가하여 실패하도록 유도하고 올바르게 \n복구되는지 테스트한다. \n구조 \n(Structured) \n소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 \n평가한다. \n회귀 \n(Regression) \n소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 \n확인한다. \n안전 \n(security) 소프트웨어가 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인한다. \n강도 \n(Stress) \n소프트웨어에 과도하게 부하를 가하여도 소프트웨어가 정상적으로 실행되는지 \n확인한다. \n병행(Parallel) \n변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 두 \n결과를 비교 확인한다. \n26. 테스트 시나리오와 테스트 \n테스트 시나리오 \n테스트 시나리오']"
8,인터페이스 구현 검증 도구가 아닌 것은 ?,"[""ESB"", ""xUnit"", ""STAF"", ""NTAF""]",1,1,소프트웨어 개발,소프트웨어 개발,"ESB는 Enterprise Service Bus의 약자로, 소프트웨어 애플리케이션들 사이의 상호작용을 지원하는 하드웨어 또는 소프트웨어 구성 요소입니다. 주로 데이터 통합, 프로토콜 변환, 메시지 라우팅 등의 기능을 제공하며, 인터페이스 구현 검증 도구로 사용되지는 않습니다.

xUnit은 단위 테스트 프레임워크로, 소프트웨어 개발에서 단위 테스트를 수행하는 데 사용됩니다.

STAF는 Software Testing Automation Framework의 약자로, 다양한 테스트 자동화 도구를 지원하고 통합하는 프레임워크입니다.

NTAF는 NHN Test Automation Framework의 약자로, 웹 애플리케이션 테스트를 위한 자동화 프레임워크입니다.

따라서, 인터페이스 구현 검증 도구가 아닌 것은 ESB입니다.

과목: 소프트웨어 개발","['다음 중 워크스루 (Walkthrough) 와 인스펙션 (Inspection) 에 대한 설명으로 가장 옳지 않은 것은?', '다음 중 단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은 ?', '다음 중 소유 기반 인증 (Something you have) 방법에 해당하지 않는 것은?', '병행제어 기법의 종류가 아닌 것은 ?', 'IDE(Integrated Development Environment) 도구의 각 기능에 대한 설명으로 틀린 것은?']","['테스트 스텁의 차이점 구분 드라이버(Driver) 스텁(Stub) 테스트 대상의 하위 모듈을 제어 모듈이 호출하는 타 호출하는 도구로, 매개 변 모듈의 기능을 단순히 수 개념 수(Parameter)를 전달하고, 행하는 도구로, 일시적으로 모듈 테스트 수행 후의 결 필요한 조건만을 가지고 있 과를 도출함 는 시험용 모듈임 상위 모듈은 있지만 하위 필요 상위 모듈 없이 하위 모듈이 모듈이 없는 경우 하위 모 있는 경우 하위 모듈 구동 시기 듈 대체 테스트 상향식(Bottom Up) 테스트 하향식(Top- Down) 테스트 방식 공통점 소프트웨어 개발과 테스트를 병행할 경우 이용- 이미 존재하는 하위 모듈 일시적으로 필요한 조건- 과 존재하지 않는 상위 만을 가지고 임시로 제공 모듈 간의 인터페이스 역 되는 가짜 모듈의 역할을 할을 함 함 차이점- 소프트웨어 개발이 완료 시험용 모듈이기 때문에- 되면 드라이버는 본래의 일반적으로 드라이버보다 모듈로 교체됨 작성하기 쉬움 41 2405', '인터페이스 구현 검증 도구- 인터페이스 구현을 검증하기 위해서는 인터페이스 단 위 기능과 시나리오 등을 기반으로 하는 통합 테스트가 필요하다.- 통합 테스트는 다음과 같은 테스트 자동화 도구를 이용 하면 효율적으로 수행할 수 있다. 도구 기능- 같은 테스트 코드를 여러 번 작성하지 않게 도와주 고, 테스트마다 예상 결과를 기억할 필요가 없게 하 는 자동화된 해법을 제공하는 단위 테스트 프레임워 크 xUnit- Smalltalk에 처음 적용되어 SUnit이라는 이름이었으나 Java용의 JUnit, C++용의 CppUnit, .NET용의 NUnit, Http용의 HttpUnit 등 다양한 언어에 적용되면서 xUnit 으로 통칭되고 있음- 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크- 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성 할 수 있도록 지원함 STAF- 분산 소프트웨어의 경우 각 분산 환경에 설치된 데몬 이 프로그램 테스트에 대한 응답을 대신', '프로그램을 컴퓨터에서 실행가능한 형태로 변환 \n디버깅 \n버그를 찾아 수정 \n배포 \n사용자에게 배포 \n2. 인터페이스 구현  \n1) 모듈 연계 방법 (데이터 교환을 위한 관계 설정) : EAI \n2) 인터페이스 구현 \n(1) 통신 기술 : AJAX (Javascript를 이용한 비동기 통신 기술) \n데이터 포맷: JSON (데이터 객체를 속성-값의 쌍 형태로 표현), XML (마크업 언어) \n(2) 보안 : 스니핑(수동적 공격)을 막기 위해 네트워크 트래픽에 대한 암호화 설정 \n=> 방식 : IPSec, SSL, S-HTTP 등 \n3) 구현 검증 도구 \nxUnit \nJava(Junit), C++(CppUnit) 등 다양한 언어를 지원 \nSTAF \n다양한 환경을 지원 \nFitNess \n웹기반 \nNTAF \nFitNess + STAF \nwatir \nRuby 기반 \nEAI 구축 유형 \n설명 \nPoint-to-Point \n애플리케이션의 1:1 연결 \nHub & Spoke \n허브를 통해 데이터를', 'b. 비기능 요구 사항 : 성능, 보안, 품질, 제약사항 등  \n2) 요구사항 분석 과정 \n(1) 도출 : 질문을 바탕으로 요구사항을 수집함 (프로토타이핑, 유스케이스 등 활용) \n(2) 분석 : 요구사항의 타당성 분석, 상충될 경우 중재 \n(3) 명세 : 문서화(명세서 작성) \n(4) 확인 : 방법 - 동료검토 / 워크스루 (사전 검토 후 회의) / 인스펙션 (전문가 검토) \n3) 요구사항 분석 시 이용되는 도구 \na. 자료흐름도 (Data Flow Diagram, DFD) : 자료의 흐름을 도형 중심으로 기술 \nb. 자료 사전 : 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록 \n기호 \n의미 \n= \n자료의 정의 (~is composed of) \n+ \n자료의 연결 (and) \n[ | ] \n자료의 선택 (or) \n{ } \n자료의 반복 \n( ) \n생략 가능 \n* * \n주석 \n3) 객체지향 분석 : 요구 사항을 객체 기준으로 분석 \n(1) 정의 \n객체지향 : 현실 세계의 대상을 하나', '2) 애플리케이션 테스트의 종류 : 테스트 기법과 개발 단계에 따른 분류 \n(1) 기법에 따른 구분 \na. 화이트 박스 테스트 : 내부의 논리적인 경로를 테스트 \n기초 경로 검사 : 논리적 복잡성 측정을 위해, 모든 경로 검사 \n검증 기준 : 테스트 케이스가 적정한가 판단 \n문장 검증 기준 \n모든 구문이 한 번 이상 수행되었는가 \n분기 검증 기준 \n모든 조건문에 대해 조건이 참일때와 거짓일 때가 모두 수행되었는가 \n조건 검증 기준 \n조건문에 포함된 조건식의 결과가 참/거짓일 때가 모두 수행되었는가 \n분기/조건 기준 \n분기 검증 + 조건 검증 \nb. 블랙 박스 테스트 : 결과물이 정확한지 테스트 \n종류 : 동치분할 검사, 경계값 분석,  \n원인-효과 그래프 검사(효용성 높은 테스트 케이스 선정),  \n오류 예측 검사(감으로), 비교검사 (버전 여러개에 적용해봄) \n동치 분할 검사 \n타당한 입력 자료와 타당하지 않은 입력자료를 균등하게 함 \n경계값 분석 \n입력 조건의 경계값을 테스트 케']","['다음 중 워크스루 (Walkthrough) 와 인스펙션 (Inspection) 에 대한 설명으로 가장 옳지 않은 것은?\n\n[보기]\n1) 워크스루는 전문가들에 의해 개발자의 작업 내역이 검토된다.\n2) 워크스루는 제품 개발자가 주최가 된다.\n3) 워크스루는 오류 발견과 발견된 오류의 문제 해결에 중점을 둔다.\n4) 인스펙션은 워크스루를 발전시킨 형태이다.', '다음 중 단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은 ?\n\n[보기]\n1) 알고리즘 오류에 따른 원치 않는 결과\n2) 탈출구가 없는 반복문의 사용\n3) 모듈 간의 비정상적 상호 작용으로 인한 원치 않는 결과\n4) 틀린 계산 수식에 의한 잘못된 결과', '다음 중 소유 기반 인증 (Something you have) 방법에 해당하지 않는 것은?\n\n[보기]\n1) i-PIN\n2) OTP\n3) 스마트 카드\n4) 신분증', '병행제어 기법의 종류가 아닌 것은 ?\n\n[보기]\n1) 로킹 기법\n2) 시분할 기법\n3) 타임 스탬프 기법\n4) 다중 버전 기법', 'IDE(Integrated Development Environment) 도구의 각 기능에 대한 설명으로 틀린 것은?\n\n[보기]\n1) Coding - 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성 할 수 있는 환경을 제공\n2) Compile – 저급 언어의 프로그램을 고급 언어 프로그램으로 변환하는 기능\n3) Debugging - 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능\n4) Deployment - 소프트웨어를 최종 사용자에게 전달하기 위한 기능', '테스트 스텁의 차이점 구분 드라이버(Driver) 스텁(Stub) 테스트 대상의 하위 모듈을 제어 모듈이 호출하는 타 호출하는 도구로, 매개 변 모듈의 기능을 단순히 수 개념 수(Parameter)를 전달하고, 행하는 도구로, 일시적으로 모듈 테스트 수행 후의 결 필요한 조건만을 가지고 있 과를 도출함 는 시험용 모듈임 상위 모듈은 있지만 하위 필요 상위 모듈 없이 하위 모듈이 모듈이 없는 경우 하위 모 있는 경우 하위 모듈 구동 시기 듈 대체 테스트 상향식(Bottom Up) 테스트 하향식(Top- Down) 테스트 방식 공통점 소프트웨어 개발과 테스트를 병행할 경우 이용- 이미 존재하는 하위 모듈 일시적으로 필요한 조건- 과 존재하지 않는 상위 만을 가지고 임시로 제공 모듈 간의 인터페이스 역 되는 가짜 모듈의 역할을 할을 함 함 차이점- 소프트웨어 개발이 완료 시험용 모듈이기 때문에- 되면 드라이버는 본래의 일반적으로 드라이버보다 모듈로 교체됨 작성하기 쉬움 41 2405', '인터페이스 구현 검증 도구- 인터페이스 구현을 검증하기 위해서는 인터페이스 단 위 기능과 시나리오 등을 기반으로 하는 통합 테스트가 필요하다.- 통합 테스트는 다음과 같은 테스트 자동화 도구를 이용 하면 효율적으로 수행할 수 있다. 도구 기능- 같은 테스트 코드를 여러 번 작성하지 않게 도와주 고, 테스트마다 예상 결과를 기억할 필요가 없게 하 는 자동화된 해법을 제공하는 단위 테스트 프레임워 크 xUnit- Smalltalk에 처음 적용되어 SUnit이라는 이름이었으나 Java용의 JUnit, C++용의 CppUnit, .NET용의 NUnit, Http용의 HttpUnit 등 다양한 언어에 적용되면서 xUnit 으로 통칭되고 있음- 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크- 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성 할 수 있도록 지원함 STAF- 분산 소프트웨어의 경우 각 분산 환경에 설치된 데몬 이 프로그램 테스트에 대한 응답을 대신하며, 테스트 가 완료되면 이를 통합하고 자동화하여 프로그램을 완성함 정보처리기사 필기 요약 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원 FitNesse 하는 테스트 프레임워크 FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 NTAF 및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레 임워크 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케 Selenium 이션 테스트 프레임워크 watir Ruby를 사용하는 애플리케이션 테스트 프레임워크 2407', '프로그램을 컴퓨터에서 실행가능한 형태로 변환 \n디버깅 \n버그를 찾아 수정 \n배포 \n사용자에게 배포 \n2. 인터페이스 구현  \n1) 모듈 연계 방법 (데이터 교환을 위한 관계 설정) : EAI \n2) 인터페이스 구현 \n(1) 통신 기술 : AJAX (Javascript를 이용한 비동기 통신 기술) \n데이터 포맷: JSON (데이터 객체를 속성-값의 쌍 형태로 표현), XML (마크업 언어) \n(2) 보안 : 스니핑(수동적 공격)을 막기 위해 네트워크 트래픽에 대한 암호화 설정 \n=> 방식 : IPSec, SSL, S-HTTP 등 \n3) 구현 검증 도구 \nxUnit \nJava(Junit), C++(CppUnit) 등 다양한 언어를 지원 \nSTAF \n다양한 환경을 지원 \nFitNess \n웹기반 \nNTAF \nFitNess + STAF \nwatir \nRuby 기반 \nEAI 구축 유형 \n설명 \nPoint-to-Point \n애플리케이션의 1:1 연결 \nHub & Spoke \n허브를 통해 데이터를 전송하는 중앙 집중형 방식 \nMessage Bus (ESB 방식) \n애플리케이션 사이에 미들웨어를 두어 처리 \nHybrid \nHub & Spoke(그룹내) + Message Bus(그룹간) \n3. 테스트 \n1) 애플리케이션 테스트 : 애플리케이션에 잠재되어 있는 결함을 찾아내는 행위 \n(1) 확인과 검증 \n확인 : 요구사항 만족 확인 (사용자 중심) \n검증 : 명세서에 맞게 만들어졌는지 검증 (개발자 중심) \n(2) 기본 원리  \n파레토법칙 : 오류의 80%는 20%의 모듈에서 발견된다 => 결함 집중 \n(3) 테스트 오라클: 결과를 판단하기 위해 테스트케이스에 대한 예상결과 계산, 확인 \n참오라클 \n모든 테스트 케이스의 입력값에 대한 기대값 제공 \n샘플링 오라클 \n특정 케이스에 대한 기대값 제공 \n추정 오라클 \n특정 케이스에 대한 기댓값 + 나머지는 추정으로 처리 \n일관성 검사 오라클 \n애플리케이션 변경 시, 변경 전과 후의 결과값이 동일한지 비교', 'b. 비기능 요구 사항 : 성능, 보안, 품질, 제약사항 등  \n2) 요구사항 분석 과정 \n(1) 도출 : 질문을 바탕으로 요구사항을 수집함 (프로토타이핑, 유스케이스 등 활용) \n(2) 분석 : 요구사항의 타당성 분석, 상충될 경우 중재 \n(3) 명세 : 문서화(명세서 작성) \n(4) 확인 : 방법 - 동료검토 / 워크스루 (사전 검토 후 회의) / 인스펙션 (전문가 검토) \n3) 요구사항 분석 시 이용되는 도구 \na. 자료흐름도 (Data Flow Diagram, DFD) : 자료의 흐름을 도형 중심으로 기술 \nb. 자료 사전 : 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록 \n기호 \n의미 \n= \n자료의 정의 (~is composed of) \n+ \n자료의 연결 (and) \n[ | ] \n자료의 선택 (or) \n{ } \n자료의 반복 \n( ) \n생략 가능 \n* * \n주석 \n3) 객체지향 분석 : 요구 사항을 객체 기준으로 분석 \n(1) 정의 \n객체지향 : 현실 세계의 대상을 하나의 모듈로 만들어서 조립 \n객체: (데이터 + 기능)을 캡슐화 한 것(하나로 묶음) \n클래스 : 객체의 설계도 (속성, 연산을 정의한 틀)  \n(2) 객체 지향의 특징 \n캡슐화 : 데이터 + 함수(기능)을 하나로 묶어서 외부 은닉 효과 \n다형성 : 여러가지 형태를 가질 수 있음 \n(차 클래스가 생성한 객체가 모닝이든 소나타든 벤츠든 OK)  \n상속 : 부모 클래스의 모든 속성과 연산을 하위 클래스가 물려받음 \n(차의 설계도를 가지고 소나타 설계도를 만들고 소나타 객체 생산) \n연관성 : 객체들이 상호 참조함 \n(3) 객체지향 분석 기법 : 럼바우 기법(객체 모델링 기법)  \n순서 : 객체 모델링 -> 동적 모델링 -> 기능 모델링 (객동기) \n객체 모델링 : 객체와 객체간의 관계를 찾아내 객체 다이어그램으로. \n동적 모델링 : 동적인 행위를 상태 다이어그램으로 \n(시간의 흐름에 따른 제어 흐름, 상호작용, 동작 순서 등) \n기능 모델링 : DFD 이용, 자료 흐름 중심의 모델링', '2) 애플리케이션 테스트의 종류 : 테스트 기법과 개발 단계에 따른 분류 \n(1) 기법에 따른 구분 \na. 화이트 박스 테스트 : 내부의 논리적인 경로를 테스트 \n기초 경로 검사 : 논리적 복잡성 측정을 위해, 모든 경로 검사 \n검증 기준 : 테스트 케이스가 적정한가 판단 \n문장 검증 기준 \n모든 구문이 한 번 이상 수행되었는가 \n분기 검증 기준 \n모든 조건문에 대해 조건이 참일때와 거짓일 때가 모두 수행되었는가 \n조건 검증 기준 \n조건문에 포함된 조건식의 결과가 참/거짓일 때가 모두 수행되었는가 \n분기/조건 기준 \n분기 검증 + 조건 검증 \nb. 블랙 박스 테스트 : 결과물이 정확한지 테스트 \n종류 : 동치분할 검사, 경계값 분석,  \n원인-효과 그래프 검사(효용성 높은 테스트 케이스 선정),  \n오류 예측 검사(감으로), 비교검사 (버전 여러개에 적용해봄) \n동치 분할 검사 \n타당한 입력 자료와 타당하지 않은 입력자료를 균등하게 함 \n경계값 분석 \n입력 조건의 경계값을 테스트 케이스로 선정 \n(2) 개발 단계에 따른 분류 \n단계 \n설명 \n단위 테스트 \n모듈이나 컴포넌트에 초점을 맞춰 테스트 \n통합 테스트  \n모듈간 상호작용 오류 검사 \n(1) 하향식 : 상위 모듈 -> 하위 모듈 통합 (넓이우선/깊이우선 등) \n=> 하위 모듈을 대체하는 stub 활용 \n(2) 상향식 : 하위모듈 -> 상위 모듈 통합 \n=> 상위 모듈을 대체하는 driver 활용 \n시스템 테스트  \n실제 사용환경과 유사한 환경에서 완벽하게 수행되는가 \n인수 테스트 \n사용자의 요구사항을 충족하는지 \n(1) 알파테스트 : 개발자의 장소에서, 개발자 앞에서 \n(2) 베타테스트 : 개발자 없이 고객의 사용 환경에서 \n3) 테스트 케이스 생성 도구 (테스트 케이스 자동화 도구의 일종) \n: 자료흐름도 작성, 기능테스트(가능한 모든 입력 작성), 입력 도메인 분석, 랜덤 테스트 \nⅡ 패키징 \n1. 소프트웨어 패키징']"
9,다음에서 설명하는 스키마 (Schema) 는 ?,"[""개념 스키마"", ""내부 스키마"", ""외부 스키마"", ""내용 스키마""]",1,3,데이터베이스 구축,데이터베이스 구축,"데이터베이스에서 스키마란 데이터베이스의 구조를 정의하는 개념입니다. 
스키마에는 외부 스키마, 개념 스키마, 내부 스키마가 있습니다. 
- 외부 스키마는 사용자가 데이터베이스에 접근할 때 사용하는 인터페이스입니다. 
- 개념 스키마는 데이터베이스의 전체적인 구조를 정의하는 개념입니다. 
- 내부 스키마는 데이터베이스가 실제로 저장되는 물리적 구조를 정의합니다. 
따라서 보기 3이 정답입니다.

 과목: 데이터베이스 구축","['키는 개체 집합에서 고유하게 개체를 식별할 수 있는 속성이다 . 데이터베이스에서 사용되는 키의 종류에 대한 설명으로 옳지 않은 것은?', 'OSI7 계층 모델에서 전송에 필요한 장치 간의 실제 접속과 절단 등 기계적 , 전기적 , 기능적 , 절차적 특성을 정의한 계층은 ?', '형상 관리의 개념과 절차에 대한 설명으로 틀린 것은 ?', '릴레이션 R 의 차수 (Degree) 가3, 카디널리티 (Cardinality) 가3, 릴레 이션 S 의 차수가4, 카디널리티가4 일 때 , 두 릴레이션을 카티션 프로덕트 (Cartesian Product) 한 결과 릴레이션의 차수와 카디널리 티는?', '관계형 데이터베이스에서 다음 설명에 해당하는 키 (Key) 는 ?']","['현행 시스템 파악 절차 \n \n1 단계(시스템 구성 파악 - 시스템 기능 파악 - 시스템 인터페이스 현황 파악) \n2 단계(아키텍처 파악 - 소프트웨어 구성 파악) \n3 단계(시스템 하드웨어 현황 파악 - 네트워크 구성 파악) \n시스템 아키텍처 \n \n시스템 내의 상위 시스템과 하위 시스템들이 어떠한 관계로 상호작용하는지 각각의 동작 \n원리와 구성을 표현한 것이다. \n단위 업무 시스템별로 아키텍처가 다른 경우 핵심 기간 업무 처리 시스템을 기준으로 한다. \n시스템의 전체 구조, 행위, 그리고 행위 원리를 나타내며 시스템이 어떻게 작동하는지 \n설명하는 틀이다. \n시스템의 목적 달성을 위해 시스템에 구성된 각 컴포넌트를 식별하고 각 컴포넌트의 \n상호작용을 통하여 어떻게 정보가 교환되는지 설명한다. \n시스템 아키텍처 ↔ 소프트웨어 아키텍처 => 소프트웨어 상세 설계 \n \n시스템 및 인터페이스 현황 파악 \n시스템 구성 파악 \n \n조직 내의 주요 업무를 기간 업무와 지원 업무로 구분하여 기술한다', '1) 사물 : 구조사물, 행동사물, 그룹사물, 주해사물 \n2) 관계 : 사물과 사물 사이의 연관성 표현 \n종류 \n의미 \n기호 \n연관 관계 \n서로 연관됨 \n의존 관계 \n일시적으로 연관 있음 \n일반화 관계 \n상위 개념 \n실체화 관계 \n공통적인 기능 \n집합 관계 \n다른 사물에 포함됨(종속X) \n포함 관계 \n다른 사물에 포함됨(종속) \n3) 다이어그램 : 사물과 관계를 도형으로 표현한 것 \n구조적 다이어그램 \n행위 다이어그램 \n\uf02d 클래스 다이어그램 \n\uf02d 객체 다이어그램 \n\uf02d 컴포넌트 다이어그램 \n\uf02d 배치 다이어그램 \n\uf02d 복합체 구조 다이어그램 \n\uf02d 패키지 다이어그램 \n\uf02d 유스케이스 다이어그램 \n\uf02d 순차 다이어그램 \n\uf02d 커뮤니케이션 다이어그램 \n\uf02d 상태 다이어그램 \n\uf02d 활동 다이어그램 \n\uf02d 상호작용 개요 다이어그램 \n\uf02d 타이밍 다이어그램 \n5) 자주 사용되는 다이어그램 \na. 클래스 다이어그램 \n정의 : 시스템을 구성하는 클래스, 클래스의 특성과 오퍼레이션(동작),  \n속성과 오퍼레이션에 대', '개념화) 개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무 한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정 이다.- 개념적 설계 단계에서는 개념 스키마 모델링과 트랜잭 션 모델링을 병행 수행한다.- 개념적 설계 단계에서는 요구 분석 단계에서 나온 결과 인 요구 조건 명세를 DBMS에 독립적인 E- R 다이어그 램으로 작성한다.- DBMS에 독립적인 개념 스키마를 설계한다. 2407', 'DROP DROP은 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱 스, 제약 조건 등을 제거하는 명령문이다. 표기 형식 DROP SCHEMA 스키마명 [CASCADE | RESTRICT]; DROP DOMAIN 도메인명 [CASCADE | RESTRICT]; DROP TABLE 테이블명 [CASCADE | RESTRICT]; DROP VIEW 뷰명 [CASCADE | RESTRICT]; DROP INDEX 인덱스명 [CASCADE | RESTRICT]; DROP CONSTRAINT 제약조건명;- CASCADE : 제거할 요소를 참조하는 다른 모든 개체를 함께 제거함. 즉 주 테이블의 데이터 제거 시 각 외래키 와 관계를 맺고 있는 모든 데이터를 제거하는 참조 무 결성 제약 조건을 설정하기 위해 사용됨- RESTRICT : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소함 60 <학생> 테이블을 제거하되, <학생> 테이블을 참조 예제 하는 모든 데이터를 함께 제거하시오. DR', '키의 분류 \n \n학번 \n주민번호 \n이름 \n나이 \n<-학생---수강-> \n학번 \n과목 \n1 \n123123-1 \nA \n10 \n--- \n1 \n운영체제 \n2 \n123123-1 \nB \n20 \n--- \n2 \n소프트웨어공학 \n3 \n123123-1 \nC \n30 \n--- \n3 \nC 언어 \n슈퍼키(Super Key) \n \n두 개 이상의 속성으로 구성된 키 또는 혼합키를 의미한다. \n모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는다. \n외래키(Foreign Key) \n \n다른 테이블의 기본키로 사용되는 속성이다. \n<수강> 테이블에서 <학생> 테이블을 참조할 때 <학생> 테이블의 학번은 참조키, <수강> \n테이블의 학번이 외래 키가 된다. \n무결성(Integrity) \n \n릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션을 조작하는 과정에서의 \n의미전 관계 (Semantic Relationship)를 명세한 것으로 정의 대항으로 도메인, 키, \n종속성 등이 있']","['키는 개체 집합에서 고유하게 개체를 식별할 수 있는 속성이다 . 데이터베이스에서 사용되는 키의 종류에 대한 설명으로 옳지 않은 것은?\n\n[보기]\n1) 후보키는 개체들을 고유하게 식별할 수 있는 속성이다.\n2) 슈퍼키는 한 개 이상의 속성들의 집합으로 구성된 키이다.\n3) 외래키는 다른 테이블의 기본키로 사용되는 속성이다.\n4) 대체키는 슈퍼키 중에서 기본키를 제외한 나머지 키를 의미한다.', 'OSI7 계층 모델에서 전송에 필요한 장치 간의 실제 접속과 절단 등 기계적 , 전기적 , 기능적 , 절차적 특성을 정의한 계층은 ?\n\n[보기]\n1) 물리 계층\n2) 데이터 링크 계층\n3) 네트워크 계층\n4) 전송 계층', '형상 관리의 개념과 절차에 대한 설명으로 틀린 것은 ?\n\n[보기]\n1) 형상 식별은 형상 관리 계획을 근거로 형상 관리의 대상이 무엇인지 식별하는 과정이다.\n2) 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다.\n3) 형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용 및 반영해야 한다.\n4) 형상 감사는 형상 관리 계획대로 형상 관리가 진행되고 있는지, 형상 항목의 변경이 요구사항에 맞도록 제대로 이뤄졌는지 등을 살펴보는 활동이다.', '릴레이션 R 의 차수 (Degree) 가3, 카디널리티 (Cardinality) 가3, 릴레 이션 S 의 차수가4, 카디널리티가4 일 때 , 두 릴레이션을 카티션 프로덕트 (Cartesian Product) 한 결과 릴레이션의 차수와 카디널리 티는?\n\n[보기]\n1) 4,4\n2) 7,7\n3) 7,12\n4) 12,12', '관계형 데이터베이스에서 다음 설명에 해당하는 키 (Key) 는 ?\n\n[보기]\n1) 후보키\n2) 대체키\n3) 슈퍼키\n4) 외래키', '현행 시스템 파악 절차 \n \n1 단계(시스템 구성 파악 - 시스템 기능 파악 - 시스템 인터페이스 현황 파악) \n2 단계(아키텍처 파악 - 소프트웨어 구성 파악) \n3 단계(시스템 하드웨어 현황 파악 - 네트워크 구성 파악) \n시스템 아키텍처 \n \n시스템 내의 상위 시스템과 하위 시스템들이 어떠한 관계로 상호작용하는지 각각의 동작 \n원리와 구성을 표현한 것이다. \n단위 업무 시스템별로 아키텍처가 다른 경우 핵심 기간 업무 처리 시스템을 기준으로 한다. \n시스템의 전체 구조, 행위, 그리고 행위 원리를 나타내며 시스템이 어떻게 작동하는지 \n설명하는 틀이다. \n시스템의 목적 달성을 위해 시스템에 구성된 각 컴포넌트를 식별하고 각 컴포넌트의 \n상호작용을 통하여 어떻게 정보가 교환되는지 설명한다. \n시스템 아키텍처 ↔ 소프트웨어 아키텍처 => 소프트웨어 상세 설계 \n \n시스템 및 인터페이스 현황 파악 \n시스템 구성 파악 \n \n조직 내의 주요 업무를 기간 업무와 지원 업무로 구분하여 기술한다. \n모든 단위 업무를 파악할 수 있도록 하며, 시스템 내의 명칭, 기능 등 주요 기능을 \n명시한다. \n시스템 구성 현황 작성 예 \n구분 \n시스템명 \n시스템 내용 \n기간 업무 \n단위 A 업무 기간 단위 업무 A 처리를 위한 A1, A2 등의 기능을 제공 \n단위 B 업무 기간 단위 업무 B 처리를 위한 B1, B2 등의 기능을 제공 \n지원 업무 \n지원 C 업무 지원 업무 C 처리를 위한 C1, C2 등의 기능을 제공 \n시스템 기능 파악 \n \n단위 업무 시스템이 현재 제공하고 있는 기능을 주요 기능과 하부 기능으로 구분하여 \n계층형으로 표시한다. \n시스템 기능 파악 예 \n시스템명 \n기능 L1 \n기능 L2 \n기능 L3 \nA 단위 업무 시스템 기능 1 하부 기능 11 세부 기능 111 \n세부 기능 112 \n하부 기능 12 세부 기능 121 \n세부 기능 122 \n기능 2 하부 기능 21 세부 기능 211 \n세부 기능 212 \n인터페이스 현황 파악', '1) 사물 : 구조사물, 행동사물, 그룹사물, 주해사물 \n2) 관계 : 사물과 사물 사이의 연관성 표현 \n종류 \n의미 \n기호 \n연관 관계 \n서로 연관됨 \n의존 관계 \n일시적으로 연관 있음 \n일반화 관계 \n상위 개념 \n실체화 관계 \n공통적인 기능 \n집합 관계 \n다른 사물에 포함됨(종속X) \n포함 관계 \n다른 사물에 포함됨(종속) \n3) 다이어그램 : 사물과 관계를 도형으로 표현한 것 \n구조적 다이어그램 \n행위 다이어그램 \n\uf02d 클래스 다이어그램 \n\uf02d 객체 다이어그램 \n\uf02d 컴포넌트 다이어그램 \n\uf02d 배치 다이어그램 \n\uf02d 복합체 구조 다이어그램 \n\uf02d 패키지 다이어그램 \n\uf02d 유스케이스 다이어그램 \n\uf02d 순차 다이어그램 \n\uf02d 커뮤니케이션 다이어그램 \n\uf02d 상태 다이어그램 \n\uf02d 활동 다이어그램 \n\uf02d 상호작용 개요 다이어그램 \n\uf02d 타이밍 다이어그램 \n5) 자주 사용되는 다이어그램 \na. 클래스 다이어그램 \n정의 : 시스템을 구성하는 클래스, 클래스의 특성과 오퍼레이션(동작),  \n속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 나타냄 \n구성요소 : 클래스(객체의 속성 + 동작), 제약조건, 관계 \nb. 유스케이스 다이어그램 \n정의 : 수행할 수 있는 기능을 사용자 관점에서 표현함 \n구성요소 \n기능 \n시스템 \n시스템 내부의 유스케이스를 사각형으로 묶어 시스템의 범위 표현 \n액터 \n시스템과 상호작용하는 모든 외부 요소 (사람, 외부시스템 등) \n유스케이스 \n시스템이 액터에게 제공하는 기능 \n관계 \n구성요소들간의 관계 \nc. 순차 다이어그램 \n정의 : 시스템이나 객체들이 시간의 흐름에 따라 상호작용하는 과정을 표현 \n<개발 과정>----------------------------------------------------------------- \nⅠ 요구사항 분석 : 개발 전, 고객이 원하는게 뭔지 파악하자! \n1) 요구사항 \n\uf02d 정의 : 소프트웨어에 대한 필요 조건이나 제약사항 \na. 기능 요구사항 : 소프트웨어가 반드시 수행해야하는 기능', '개념화) 개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무 한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정 이다.- 개념적 설계 단계에서는 개념 스키마 모델링과 트랜잭 션 모델링을 병행 수행한다.- 개념적 설계 단계에서는 요구 분석 단계에서 나온 결과 인 요구 조건 명세를 DBMS에 독립적인 E- R 다이어그 램으로 작성한다.- DBMS에 독립적인 개념 스키마를 설계한다. 2407', 'DROP DROP은 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱 스, 제약 조건 등을 제거하는 명령문이다. 표기 형식 DROP SCHEMA 스키마명 [CASCADE | RESTRICT]; DROP DOMAIN 도메인명 [CASCADE | RESTRICT]; DROP TABLE 테이블명 [CASCADE | RESTRICT]; DROP VIEW 뷰명 [CASCADE | RESTRICT]; DROP INDEX 인덱스명 [CASCADE | RESTRICT]; DROP CONSTRAINT 제약조건명;- CASCADE : 제거할 요소를 참조하는 다른 모든 개체를 함께 제거함. 즉 주 테이블의 데이터 제거 시 각 외래키 와 관계를 맺고 있는 모든 데이터를 제거하는 참조 무 결성 제약 조건을 설정하기 위해 사용됨- RESTRICT : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소함 60 <학생> 테이블을 제거하되, <학생> 테이블을 참조 예제 하는 모든 데이터를 함께 제거하시오. DROP TABLE 학생 CASCADE; 407', '키의 분류 \n \n학번 \n주민번호 \n이름 \n나이 \n<-학생---수강-> \n학번 \n과목 \n1 \n123123-1 \nA \n10 \n--- \n1 \n운영체제 \n2 \n123123-1 \nB \n20 \n--- \n2 \n소프트웨어공학 \n3 \n123123-1 \nC \n30 \n--- \n3 \nC 언어 \n슈퍼키(Super Key) \n \n두 개 이상의 속성으로 구성된 키 또는 혼합키를 의미한다. \n모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는다. \n외래키(Foreign Key) \n \n다른 테이블의 기본키로 사용되는 속성이다. \n<수강> 테이블에서 <학생> 테이블을 참조할 때 <학생> 테이블의 학번은 참조키, <수강> \n테이블의 학번이 외래 키가 된다. \n무결성(Integrity) \n \n릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션을 조작하는 과정에서의 \n의미전 관계 (Semantic Relationship)를 명세한 것으로 정의 대항으로 도메인, 키, \n종속성 등이 있다. \n개체 무결성 : 기본키의 값은 Null 값이나 중복 값을 가질 수 없다는 제약조건이다. \n참조 무결성 : 릴레이션 R1 에 속성 조합인 외래키를 변경하려면 이를 참조하고 있는 \n릴레이션 R2 의 기본키도 변경해야 한다. 이때 참조할 수 없는 외래키 값을 가질 수 없다는 \n제약조건이다. \n도메인 무결성 : 릴레이션 중 하나의 속성은 반드시 원자 값이어야 한다는 것을 보장하는 \n제약조건이다. \n42. 데이터베이스 설계와 구조화 \n데이터베이스 설계 단계 \n요구조건 분석 \n \n데이터베이스 사용자로부터 요구조건 수집과 요구조건 명세서를 작성한다. \n개념적 설계 \n \n목표 DBMS 에 독립적인 개념 스키마를 설계한다. \n개념 스키마 모델링(ERD)과 트랜잭션 모델링을 병행 수행한다. \n논리적 설계 \n \n목표 DBMS 에 종속적인 논리적 스키마를 설계한다. \n스키마의 평가 및 정제를 한다. \n논리적 데이터 모델로 변환 및 트랜잭션 인터페이스를 설계한다. \n물리적 설계']"
10,"조건을 만족하는 릴레이션의 수평적 부분집합으로 구성하며 , 연산자의 기호는 그리스 문자 시그마 ( σ ) 를 사용하는 관계대수 연산은 ?","[""Select"", ""Project"", ""Join"", ""Division""]",1,1,데이터베이스 구축,데이터베이스 구축,"조건을 만족하는 릴레이션의 수평적 부분집합으로 구성하며, 연산자의 기호는 그리스 문자 시그마(σ)를 사용하는 관계대수 연산은 'Select'입니다. 
Select 연산자는 릴레이션에서 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산입니다. 이는 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 합니다. 
연산자의 기호는 그리스 문자 시그마(σ)를 사용합니다.

과목: 데이터베이스 구축","['파티셔닝 방식 중 ‘월별, 분기별’과 같이 지정한 열의 값을 기준으로 범위를 지정하여 분할하는 방식은?', '트랜잭션의 주요 특성 중 하나로 , 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션 의 연산이 끼어들 수 없음을 의미하는 것은?', 'C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?', 'C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?', 'C언어에서 두 개의 논리 값 중 하나라도 참이면1을, 모두 거짓이면 0을 반환하는 연산자는?']","['Select \n조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만듦 \nProject \n속성리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만듦(중복x) \nJoin \n공통 속성을 중심으로 두 개의 릴레이션을 하나로 합침 \nDivision \n두 개의 릴레이션(R, S)에서 ㄴ가 가진 속성을 제외한 속성만을 구함 \n3) 일반 집합 연산자 \n개요 \n기호 \n합집합 (Union) \n릴레이션 R 또는 S에 존재하는 튜플 (중복 제거) \n교집합 (intersection) \n릴레이션 R과 S에 동시에 존재하는 튜플의 집합 \n차집합 (different) \n릴레이션 R에는 존재하고 S에는 없는 튜플의 집합 \n교차곱 (Cartesian product)  두 릴레이션에 있는 튜플들의 순서쌍 \nⅢ 데이터 베이스 설계 \n1. 데이터베이스 설계 \n1) 도구 : 데이터 모델 \n(1) 데이터 모델이 표시할 요소 \n구조(Structure) : 개체간의 관계 \n연산(Operation) : 실제 데이터를', '순수 관계 연산자 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산 Select- 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이 므로 수평 연산이라고도 함- 연산자의 기호는 그리스 문자 시그마(σ)를 사용함 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산이 다. 단 연산 결과에 중복이 발생하면 중복이 제거됨 Project- 릴레이션의 열(세로)에 해당하는 Attribute를 추출하는 것이므로 수직 연산자라고도 함- 연산자의 기호는 그리스 문자 파이(π)를 사용함 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐 Join 서 새로운 릴레이션을 만드는 연산- 연산자의 기호는 를 사용함 X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성 이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제 Division 외한 속성만을 구하는', '관계대수의 개요 관계대수는 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다.- 관계대수는 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어로 피연산자가 릴레이션이고, 결 과도 릴레이션이다.- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순 서를 명시한다. 정보처리기사 필기 요약- 관계대수에는 관계 데이터베이스에 적용하기 위해 특 별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있다.- 순수 관계 연산자- Select- Project- Join- Division- 일반 집합 연산자- UNION(합집합)- INTERSECTION(교집합)- DIFFERENCE(차집합)- CARTESIAN PRODUCT(교차곱) 2408', '연산자의 기호는 파이(∏)를 사용한다. \nJoin(연결) \n \n공통 속성을 기준으로 두 릴레이션을 합하여 새로운 릴레이션을 만드는 연산이다. \n연산자의 기호는 ▷◁를 사용한다. \nDivision(나누기) \n \nDivision 에서 나누어지는 릴레이션(학생 릴레이션)은 나누는 릴레이션(학과 릴레이션)의 \n모든 속성을 전부 포함하고 있다. \n연산자의 기호는 ÷를 사용한다. \n집합 연산자 \n일반 집합 연산자의 종류 \n \n집합 \n연산자 속성 \n합집합 ∪ \n두 릴레이션의 튜플의 합집합을 구하는 연산이다. \n교집합 ∩ \n두 릴레이션의 튜플의 교집합을 구하는 연산이다. \n차집합 ㅡ \n두 릴레이션의 튜플의 차집합을 구하는 연산이다. \n교차곱 X \n두 릴레이션의 튜플들의 교차곱(순서쌍)을 구하는 연산이다. \nUnion(합집합) \n \nUnion(합집합)은 두 개의 릴레이션을 합쳐 하나의 릴레이션을 생성한다. \nIntersection(교집합) \n \nIntersection(교집합)은 연관성이 있는 두 개', '=> 키(피봇)보다 작으면 왼쪽, 크면 오른쪽으로 분해하는 방식 \n(4) 힙정렬 : 완전이진트리(Complete Binary Tree)를 이용한 정렬 (nlogn) \n3) 검색 구현 \n(1) 이진 검색 : 찾는 값을 파일의 중간 값과 비교하면서 검색 반복 (정렬필수) \n=> 중간 번호 = (첫번째 번호 + 마지막 번호) /  \n(2) 해싱 : 해싱 함수를 통해 주소값을 계산하여 해당 주소값에 저장/검색 \n4) 알고리즘 시간 복잡도 \n(1) 빅오표기법 : 알고리즘 실행시 최악의 경우를 표기 \nO(1) : 입력값과 관계없이 하나의 단계만을 거침 \nO(nlogn) : 문제 해결에 필요한 단계(O(logn))가 n번 실행됨 \n해싱 함수 \n주소값 \n제산법 \n키 값을 소수로 나눈 나머지 \n제곱법 \n키 값을 제곱한 값의 중간 부분 \n폴딩법 \n키를 부분으로 나눠 각 부분을 더하거나 XOR한 값 \n숫자분석법 \n키 값을 이루는 숫자의 분포를 분석해서 나온 값 \n5) 클린코드 : 단순 명료하게 잘 작성']","['파티셔닝 방식 중 ‘월별, 분기별’과 같이 지정한 열의 값을 기준으로 범위를 지정하여 분할하는 방식은?\n\n[보기]\n1) Range Partitioning\n2) Hash Partitioning\n3) Composite Partitioning\n4) List Partitioning', '트랜잭션의 주요 특성 중 하나로 , 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션 의 연산이 끼어들 수 없음을 의미하는 것은?\n\n[보기]\n1) Log\n2) Consistency\n3) Isolation\n4) Durability', 'C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?\n\n[보기]\n1) ∥\n2) &&\n3) **\n4) !=', 'C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?\n\n[보기]\n1) ∥\n2) &&\n3) **\n4) !=', 'C언어에서 두 개의 논리 값 중 하나라도 참이면1을, 모두 거짓이면 0을 반환하는 연산자는?\n\n[보기]\n1) ∥\n2) &&\n3) **\n4) !=', 'Select \n조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만듦 \nProject \n속성리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만듦(중복x) \nJoin \n공통 속성을 중심으로 두 개의 릴레이션을 하나로 합침 \nDivision \n두 개의 릴레이션(R, S)에서 ㄴ가 가진 속성을 제외한 속성만을 구함 \n3) 일반 집합 연산자 \n개요 \n기호 \n합집합 (Union) \n릴레이션 R 또는 S에 존재하는 튜플 (중복 제거) \n교집합 (intersection) \n릴레이션 R과 S에 동시에 존재하는 튜플의 집합 \n차집합 (different) \n릴레이션 R에는 존재하고 S에는 없는 튜플의 집합 \n교차곱 (Cartesian product)  두 릴레이션에 있는 튜플들의 순서쌍 \nⅢ 데이터 베이스 설계 \n1. 데이터베이스 설계 \n1) 도구 : 데이터 모델 \n(1) 데이터 모델이 표시할 요소 \n구조(Structure) : 개체간의 관계 \n연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세 \n제약조건(Constraint)  \n2) 과정 : 요구조건 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 구현 \n(1) 개념적 설계: 개념적 데이터 모델(DBMS에 독립) + 트랜잭션 모델링=>ER다이어그램 \n(2) 논리적 설계 : 사용할 DBMS에 맞는 논리적 데이터 모델 설계 \n(3) 물리적 설계 : 물리적 저장 장치에 저장할 수 있도록 물리적 데이터 모델로 변환  \n2. 개념적 모델링 - E-R 다이어그램 (Entity-Relationship) \n기호 \n의미 \n개체 (Entity) \n관계 (Relationship) \n속성 (Attribute) \n개체타입과 속성을 연결 \n3. 논리적 모델링 – 정규화 수행 \n1) 목적 : 데이터의 중복성을 최소화하고 일관성을 보장하여 이상(anomaly) 발생 방지 \n=> 이상 : 데이터의 불필요한 중복으로 인한 이상 현상 (삽입 이상, 삭제 이상, 갱신 이상) \n2) 정규화 과정 (도부이걸다조)', '순수 관계 연산자 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산 Select- 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이 므로 수평 연산이라고도 함- 연산자의 기호는 그리스 문자 시그마(σ)를 사용함 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산이 다. 단 연산 결과에 중복이 발생하면 중복이 제거됨 Project- 릴레이션의 열(세로)에 해당하는 Attribute를 추출하는 것이므로 수직 연산자라고도 함- 연산자의 기호는 그리스 문자 파이(π)를 사용함 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐 Join 서 새로운 릴레이션을 만드는 연산- 연산자의 기호는 를 사용함 X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성 이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제 Division 외한 속성만을 구하는 연산- 연산자의 기호는 ÷를 사용함 51 2408', '관계대수의 개요 관계대수는 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다.- 관계대수는 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어로 피연산자가 릴레이션이고, 결 과도 릴레이션이다.- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순 서를 명시한다. 정보처리기사 필기 요약- 관계대수에는 관계 데이터베이스에 적용하기 위해 특 별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있다.- 순수 관계 연산자- Select- Project- Join- Division- 일반 집합 연산자- UNION(합집합)- INTERSECTION(교집합)- DIFFERENCE(차집합)- CARTESIAN PRODUCT(교차곱) 2408', '연산자의 기호는 파이(∏)를 사용한다. \nJoin(연결) \n \n공통 속성을 기준으로 두 릴레이션을 합하여 새로운 릴레이션을 만드는 연산이다. \n연산자의 기호는 ▷◁를 사용한다. \nDivision(나누기) \n \nDivision 에서 나누어지는 릴레이션(학생 릴레이션)은 나누는 릴레이션(학과 릴레이션)의 \n모든 속성을 전부 포함하고 있다. \n연산자의 기호는 ÷를 사용한다. \n집합 연산자 \n일반 집합 연산자의 종류 \n \n집합 \n연산자 속성 \n합집합 ∪ \n두 릴레이션의 튜플의 합집합을 구하는 연산이다. \n교집합 ∩ \n두 릴레이션의 튜플의 교집합을 구하는 연산이다. \n차집합 ㅡ \n두 릴레이션의 튜플의 차집합을 구하는 연산이다. \n교차곱 X \n두 릴레이션의 튜플들의 교차곱(순서쌍)을 구하는 연산이다. \nUnion(합집합) \n \nUnion(합집합)은 두 개의 릴레이션을 합쳐 하나의 릴레이션을 생성한다. \nIntersection(교집합) \n \nIntersection(교집합)은 연관성이 있는 두 개의 릴레이션에서 중복되는 레코드를 \n선택하여 릴레이션을 생성한다. \nDifference(차집합) \n \nDifference(차집합)은 연관성이 있는 두 개의 릴레이션에서 중복되는 레코드를 제거하여 \n릴레이션을 생성한다. \nCartesian Product(교차곱) \n \n두 릴레이션의 튜플을 교차 곱하여 생성한다. \n45. SQL, DDL, DCL, View \nSQL(Structured Query Language) \n \n의미 : 관계형 데이터베이스의 표준 질의어이다. \n종류 : DDL, DML, DCL \nDDL(Data Definition Language, 데이터 정의어) \n \n데이터베이스의 정의/변경/삭제에 사용되는 언어이다. \n논리적 데이터 구조와 물리적 데이터 구조로 정의할 수 있다. \n논리적 데이터 구조와 물리적 데이터 구조 간의 사상을 정의한다. \n번역한 결과가 데이터 사전에 저장된다. \n종류 \nCREATE : 스키마, 도메인, 테이블, 뷰 정의', '=> 키(피봇)보다 작으면 왼쪽, 크면 오른쪽으로 분해하는 방식 \n(4) 힙정렬 : 완전이진트리(Complete Binary Tree)를 이용한 정렬 (nlogn) \n3) 검색 구현 \n(1) 이진 검색 : 찾는 값을 파일의 중간 값과 비교하면서 검색 반복 (정렬필수) \n=> 중간 번호 = (첫번째 번호 + 마지막 번호) /  \n(2) 해싱 : 해싱 함수를 통해 주소값을 계산하여 해당 주소값에 저장/검색 \n4) 알고리즘 시간 복잡도 \n(1) 빅오표기법 : 알고리즘 실행시 최악의 경우를 표기 \nO(1) : 입력값과 관계없이 하나의 단계만을 거침 \nO(nlogn) : 문제 해결에 필요한 단계(O(logn))가 n번 실행됨 \n해싱 함수 \n주소값 \n제산법 \n키 값을 소수로 나눈 나머지 \n제곱법 \n키 값을 제곱한 값의 중간 부분 \n폴딩법 \n키를 부분으로 나눠 각 부분을 더하거나 XOR한 값 \n숫자분석법 \n키 값을 이루는 숫자의 분포를 분석해서 나온 값 \n5) 클린코드 : 단순 명료하게 잘 작성된 코드  \n배드코드 : 스파게티 코드(복잡한 로직), 외계인 코드(유지보수 어려움) \n(1) 작성원칙 \n가독성 \n누구든지 쉽게 읽을 수 있게 => 쉬운 용어, 들여쓰기 \n단순성 \n간단하게 작성 => 클래스, 메서드 등을 최소 단위로 분리 (한가지만 처리) \n의존성 배제 \n다른 모듈에 미치는 영향 최소화 => 코드를 변경해도 영향주지 않도록 \n중복성 최소화 \n중복된 코드 삭제 \n추상화 \n상위클래스, 메서드는 간략하게, 구현은 하위클래스나 메서드에서 \n(2) 소스 품질 분석 도구 \n정적 분석 도구 : 실행x, 코딩 표준이나 스타일, 결함 분석 \n동적 분석 도구 : 실행 => 메모리 누수, 스레드 결함 분석 \n5) 개발 지원 도구 \n(1) 통합 개발 환경 (IDE) : 개발 관련 모든 작업을 하나의 프로그램에서 처리 \n(2) 빌드 도구 : 코드를 제품 소프트웨어로 변환 \n종류 : Ant, Maven, Gradle(Groovy 기반) \n코딩 \n프로그램 작성 \n컴파일']"
11,"데이터베이스 설계 단계 중 저장 레코드 양식 설계 , 레코드 집중의 분석 및 설계 , 접근 경로 설계와 관계되는 것은 ?","[""논리적 설계"", ""요구 조건 분석"", ""개념적 설계"", ""물리적 설계""]",2,4,데이터베이스 구축,데이터베이스 구축,"데이터베이스 설계 단계 중 물리적 설계는 저장 레코드 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계와 관련이 있습니다. 
과목: 데이터베이스 구축","['분산 데이터베이스 목표 중 “ 데이터베이스의 분산된 물리적 환경에 서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다 .” 는 것과 관계있는 것은 ?', '객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?', '객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?', '객체 지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미하는 것은?', '다음 관계형 데이터 모델에 대한 설명으로 옳은 것은 ?']","['물리적 설계(데이터 구조화) 물리적 설계란 논리적 설계 단계에서 논리적 구조로 표현 된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있 는 물리적 구조의 데이터로 변환하는 과정이다.- 물리적 설계 단계에서는 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다.- 저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저 장되는 방법을 묘사한다.- 물리적 설계 시 고려할 사항 : 트랜잭션 처리량, 응답 시 간, 디스크 용량, 저장 공간의 효율화 등 2459', '논리적 설계(데이터 모델링) 논리적 설계 단계란 현실 세계에서 발생하는 자료를 컴퓨 터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정이다. 정보처리기사 필기 요약- 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한다.- 개념적 설계가 개념 스키마를 설계하는 단계라면 논리 적 설계에서는 개념 스키마를 평가 및 정제하고 DBMS 에 따라 서로 다른 논리적 스키마를 설계하는 단계이다.- 트랜잭션의 인터페이스를 설계한다.- 관계형 데이터베이스라면 테이블을 설계하는 단계이다. 2407', '목표 DBMS 에 종속적인 물리적 구조를 설계한다. \n저장 레코드 양식 설계와 레코드 집중의 분석/설계, 엑세스 경로 인덱싱, 클러스터링, \n해싱 등의 설계가 포함된다. \n접근 경로 설계 및 트랜잭션 세부 설계를 한다. \n데이터베이스 구현 \n \n목표 DBMS 의 DDL 로 스키마를 작성한다. \n데이터베이스에 등록 후 트랜잭션을 작성한다. \n데이터베이스 정규화 \n정규화(Normalization)의 개념 \n \n함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 \n세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다. \n좋은 데이터베이스 스키마를 생성하고 불필요한 데이터의 중복을 방지하여 정보 검색을 \n용이하게 할 수 있도록 허용한다. \n정규화의 목적 \n \n데이터 구조의 안정성 최대화 \n중복 데이터의 최소화 \n수정 및 삭제 시 이상 현상 최소화 \n테이블 불일치 위험 간소화 \n이상 현상(Anomaly) \n \n릴레이션 조작 시 데이터들이 불필요하게 중복되어', '- 객체 모델링 : 객체도를 이용하여 시스템의 정적 구조를 표현한다. \n- 동적 모델링 : 상태 도를 이용하여 객체의 제어 흐름/상호 반응을 표현한다. \n- 기능 모델링 : 자료 흐름도를 이용하여 데이터값의 변화 과정을 표현한다. - 복잡한 \n대형 개발 프로젝트에 유용하다. \n- 기업 업무의 모델링에 있어 편리하고 사용자와 의사소통이 원활하다. \n- Case 와 연동이 충실하다. \nCoad 와 Yourdon 방법 \n객체지향 분석 방법론에서 E-R 다이어그램을 사용하여 객체의 \n행위를 모델링한다. 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 \n등의 과정으로 구성된다. \n클래스 설계 \n클래스 설계 \n \n분석 단계 중 아직 확정되지 않은 클래스 내부 부분 중 구현에 필요한 중요한 사항을 \n결정하는 작업을 의미한다. \n클래스의 서비스 인터페이스에 대한 정확한 정의, 메서드 내부의 로직 등 객체의 상태 \n변화와 오퍼레이션의 관계를 상세히 설계해야 하며, 클래스가 가', '3과목: 데이터베이스 구축\n\n<데이터 베이스>------------------------------------------------------------- \nⅢ 관계형 데이터 베이스 \n1. 관계형 데이터 베이스 \n1) Relation = 릴레이션 스키마 (구조) + 릴레이션 인스턴스 (데이터) \n(1) 정의 : 데이터를 표의 형태로 구현한 것 \n> 동일한 튜플이 존재하지 않으며, 순서가 없음 \n(2) 튜플 : 릴레이션을 구성하는 각각의 행, (= 속성의 모임, 레코드) \n카디널리티 : 튜플의 수 \n(3) 속성 : 데이터 항목 또는 데이터 필드  \n디그리(차수) : 속성의 수 \n(4) 도메인 : 하나의 속성이 취할 수 있는 원자값들의 집합 \n2) key \n(1) 후보키 : 투플을 유일하게 식별하기위해 사용하는 속성들의 부분집합 (기본키 후보) \n=> 유일성, 최소성 (꼭 필요한 속성으로만 구성) \n(2) 기본키 : 후보키 중에서 특별히 선정된 주키 \n(3) 대체키 : 기본키를 제외한 ']","['분산 데이터베이스 목표 중 “ 데이터베이스의 분산된 물리적 환경에 서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다 .” 는 것과 관계있는 것은 ?\n\n[보기]\n1) 장애 투명성\n2) 병행 투명성\n3) 위치 투명성\n4) 중복 투명성', '객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?\n\n[보기]\n1) 메시지(Message)\n2) 캡슐화(Encapsulation)\n3) 다형성(Polymorphism)\n4) 상속(Inheritance)', '객체지향 개념에서 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정은?\n\n[보기]\n1) 메시지(Message)\n2) 캡슐화 (Encapsulation)\n3) 다형성(Polymorphism)\n4) 상속(Inheritance)', '객체 지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미하는 것은?\n\n[보기]\n1) Method\n2) Class\n3) Field\n4) Message', '다음 관계형 데이터 모델에 대한 설명으로 옳은 것은 ?\n\n[보기]\n1) Relation3 개 , Attribute3 개 , Tuple5 개\n2) Relation3 개 , Attribute5 개 , Tuple3 개\n3) Relation1 개 , Attribute5 개 , Tuple3 개\n4) Relation1 개 , Attribute3 개 , Tuple5 개', '물리적 설계(데이터 구조화) 물리적 설계란 논리적 설계 단계에서 논리적 구조로 표현 된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있 는 물리적 구조의 데이터로 변환하는 과정이다.- 물리적 설계 단계에서는 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다.- 저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저 장되는 방법을 묘사한다.- 물리적 설계 시 고려할 사항 : 트랜잭션 처리량, 응답 시 간, 디스크 용량, 저장 공간의 효율화 등 2459', '논리적 설계(데이터 모델링) 논리적 설계 단계란 현실 세계에서 발생하는 자료를 컴퓨 터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정이다. 정보처리기사 필기 요약- 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한다.- 개념적 설계가 개념 스키마를 설계하는 단계라면 논리 적 설계에서는 개념 스키마를 평가 및 정제하고 DBMS 에 따라 서로 다른 논리적 스키마를 설계하는 단계이다.- 트랜잭션의 인터페이스를 설계한다.- 관계형 데이터베이스라면 테이블을 설계하는 단계이다. 2407', '목표 DBMS 에 종속적인 물리적 구조를 설계한다. \n저장 레코드 양식 설계와 레코드 집중의 분석/설계, 엑세스 경로 인덱싱, 클러스터링, \n해싱 등의 설계가 포함된다. \n접근 경로 설계 및 트랜잭션 세부 설계를 한다. \n데이터베이스 구현 \n \n목표 DBMS 의 DDL 로 스키마를 작성한다. \n데이터베이스에 등록 후 트랜잭션을 작성한다. \n데이터베이스 정규화 \n정규화(Normalization)의 개념 \n \n함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 \n세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다. \n좋은 데이터베이스 스키마를 생성하고 불필요한 데이터의 중복을 방지하여 정보 검색을 \n용이하게 할 수 있도록 허용한다. \n정규화의 목적 \n \n데이터 구조의 안정성 최대화 \n중복 데이터의 최소화 \n수정 및 삭제 시 이상 현상 최소화 \n테이블 불일치 위험 간소화 \n이상 현상(Anomaly) \n \n릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 \n의미한다. \n종류 : 삽입 이상, 삭제 이상, 갱신 이상 \n수강 테이블 \n \n학번 \n과목코드 \n성적 \n학년 \n100 \nC413 A \n4 \n200 \nC123 B \n1 \n300 \nC312 B \n3 \n400 \nC312 C \n2 \n500 \nC324 A \n2 \n600 \nE412 C \n2 \n단, 학번, 과목코드가 하나로 묶여 기본키가 되는 혼합 속성이다. \n \n삽입 이상(Insertion Anomaly) \n \n데이터를 삽입할 때 불필요한 데이터가 함께 삽입되는 현상이다. \n<수강> 릴레이션에 학번이 600 이고, 학년이 2 인 학생 값을 새롭게 삽입하려 할 때, 이 \n학생이 어떤 과목을 등록해서 과목번호를 확보하지 않는 한 이 삽입은 성공할 수 \n없다.(개체무결성 위반). \n삭제 이상(Deletion Anomaly) \n \n릴레이션의 한 튜플을 삭제함으로써 연쇄 삭제로 인해 정보의 손실을 발생시키는 현상이다.', '- 객체 모델링 : 객체도를 이용하여 시스템의 정적 구조를 표현한다. \n- 동적 모델링 : 상태 도를 이용하여 객체의 제어 흐름/상호 반응을 표현한다. \n- 기능 모델링 : 자료 흐름도를 이용하여 데이터값의 변화 과정을 표현한다. - 복잡한 \n대형 개발 프로젝트에 유용하다. \n- 기업 업무의 모델링에 있어 편리하고 사용자와 의사소통이 원활하다. \n- Case 와 연동이 충실하다. \nCoad 와 Yourdon 방법 \n객체지향 분석 방법론에서 E-R 다이어그램을 사용하여 객체의 \n행위를 모델링한다. 객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 \n등의 과정으로 구성된다. \n클래스 설계 \n클래스 설계 \n \n분석 단계 중 아직 확정되지 않은 클래스 내부 부분 중 구현에 필요한 중요한 사항을 \n결정하는 작업을 의미한다. \n클래스의 서비스 인터페이스에 대한 정확한 정의, 메서드 내부의 로직 등 객체의 상태 \n변화와 오퍼레이션의 관계를 상세히 설계해야 하며, 클래스가 가지는 속성값에 따라 \n오퍼레이션 구현이 달라진다. \n객체의 상태 변화 모델링은 필수이다. \n클래스 인터페이스 \n \n관점에 따라 관심이 다르므로, 클래스 인터페이스가 중요하다. \n관점이 다른 개발자들이 클래스 명세의 어떤 부분에 관심이 있는가? \n클래스 구현 : 실제 설계로부터 클래스를 구현하려는 개발자 \n클래스 사용 : 구현된 클래스를 이용하여 다른 클래스를 개발하려는 개발자 \n클래스 확장 : 구현된 클래스를 확장하여 다른 클래스로 만들고자 하는 개발자 \n협약에 의한 설계(Design by Contract) 3 가지 타입 \n \n선행조건(Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조건 \n결과조건(Postcondition) : 오퍼레이션이 수된 후 만족해야 하는 조건 \n불변조건(Invariant) : 클래스 내부가 실행되는 동안 항상 만족하여야 하는 조건 \n16. 디자인 패턴 \n디자인 패턴 \n디자인 패턴', '3과목: 데이터베이스 구축\n\n<데이터 베이스>------------------------------------------------------------- \nⅢ 관계형 데이터 베이스 \n1. 관계형 데이터 베이스 \n1) Relation = 릴레이션 스키마 (구조) + 릴레이션 인스턴스 (데이터) \n(1) 정의 : 데이터를 표의 형태로 구현한 것 \n> 동일한 튜플이 존재하지 않으며, 순서가 없음 \n(2) 튜플 : 릴레이션을 구성하는 각각의 행, (= 속성의 모임, 레코드) \n카디널리티 : 튜플의 수 \n(3) 속성 : 데이터 항목 또는 데이터 필드  \n디그리(차수) : 속성의 수 \n(4) 도메인 : 하나의 속성이 취할 수 있는 원자값들의 집합 \n2) key \n(1) 후보키 : 투플을 유일하게 식별하기위해 사용하는 속성들의 부분집합 (기본키 후보) \n=> 유일성, 최소성 (꼭 필요한 속성으로만 구성) \n(2) 기본키 : 후보키 중에서 특별히 선정된 주키 \n(3) 대체키 : 기본키를 제외한 나머지 후보키 \n(4) 슈퍼키 : 한 릴레이션 내에 있는 속성들의 집합 (유일성O 최소성X) \n(5) 외래키 : 다른 릴레이션의 기본키를 참조하는 속성 \n3) 무결성 \n(1) 개체 무결성 : 기본키를 구성하는 어떤 속성도 Null이나 중복값을 가질 수 없음 \n(2) 참조 무결성 : 외래키의 값은 null이거나 참조릴레이션의 기본키 값과 동일해야함 \n4) 시스템 카탈로그 : 시스템 자체에 관련 있는 객체에 관한 정보를 포함함 (데이터 사전) \n=> 메타데이터가 저장됨 (DBMS 스스로 생성, 유지하며 사용자는 조회만 가능) \n2. 관계대수 \n1) 개요 \n관계형DB에서 원하는 정보를 검색하기 위한 유도 방법을 기술하는 절차적 언어 \n순수 관계 연산자 + 일반 집합 연산자 \n관계해석(원하는 정보가 무엇이라는것만 정의하는 비절차적 방법)과 구분이 필요함 \n기호 \n구성요소 \n설명 \n∀ \n전칭 정량자 \n가능한 모든 튜플에 대하여 (For All) \n2) 순수 관계 연산자 \n개요 \n기호']"
12,관계형 데이터 모델의 릴레이션에 대한 설명으로 틀린 것은 ?,"[""모든 속성 값은 원자 값을 갖는다."", ""한 릴레이션에 포함된 튜플은 모두 상이하다."", ""한 릴레이션에 포함된 튜플 사이에는 순서가 없다."", ""한 릴레이션을 구성하는 속성 사이에는 순서가 존재한다.""]",4,4,데이터베이스 구축,데이터베이스 구축,"릴레이션의 특성에는 다음과 같은 것들이 있습니다.

*   모든 속성 값은 원자 값을 갖는다.
*   한 릴레이션에 포함된 튜플은 모두 상이하다.
*   한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
*   한 릴레이션을 구성하는 속성 사이에는 순서가 존재하지 않는다.

따라서 보기 4번은 릴레이션의 특성과 반대되는 설명이므로 정답은 4번입니다.

과목: 데이터베이스 구축","['키는 개체 집합에서 고유하게 개체를 식별할 수 있는 속성이다 . 데이터베이스에서 사용되는 키의 종류에 대한 설명으로 옳지 않은 것은?', '데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?', '데이터베이스에 영향을 주는 생성 , 읽기 , 갱신 , 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?', '데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?', '데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?']","['- 구성: 튜플: 릴레이션을 구성하는 각각의 행 (카디널리티) | 속성: 데이터 항목 또는 데이터 필드 (디그리) | 도메인: 하나의 속성이 취할 수 있는 원자값들의 집합 | 키:  - 후보키: 투플을 유일하게 식별하는 속성들의 부분집합 (유일성, 최소성)  - 기본키: 후보키 중에서 특별히 선정된 주키  - 대체키: 기본키를 제외한 나머지 후보키  - 슈퍼키: 한 릴레이션 내에 있는 속성들의 집합 (유일성O 최소성X)  - 외래키: 다른 릴레이션의 기본키를 참조하는 속성', '종류 정규화를 거치지 않으면 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란 한 현상이 발생하는데, 이를 이상(Anomaly)이라 하며 삽 입 이상, 삭제 이상, 갱신 이상이 있다. 삽입 이상 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원 (Insertion 하지 않은 값들도 함께 삽입되는 현상 Anomaly) 삭제 이상 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 (Deletion 값들도 함께 삭제되는 연쇄가 일어나는 현상 Anomaly) 갱신 이상 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜 (Update 플의 정보만 갱신되어 정보에 모순이 생기는 현상 Anomaly) 2408', '키(Key) 키(Key)는 데이터베이스에서 조건에 만족하는 튜플을 찾 거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트를 말한다.- 릴레이션을 구성하는 속성들 중에서 튜플을 유일 하게 식별하기 위해 사용하는 속성들의 부분집합, 후보키 (Candidate 즉 기본키로 사용할 수 있는 속성들을 말함 Key)- 후보키는 릴레이션에 있는 모든 튜플에 대해서 유 일성과 최소성을 만족시켜야 함- 후보키 중에서 특별히 선정된 주키(Main Key)로 중 복된 값을 가질 수 없음 기본키- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 (Primary 있는 속성 Key)- 기본키는 NULL 값을 가질 수 없다. 즉 튜플에서 기 본키로 설정된 속성에는 NULL 값이 있어서는 안 됨 대체키- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후 (Alternate 보키를 의미함 Key)- 보조키라고도 함 50- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을', '하나의 속성만 있어야 하고 반복되는 속성은 별도 테이블로 분리한다. \n국가 \n도시 \n1 정규형-> \n국가 \n도시 \n대한민국 \n서울,부산 \n \n대한민국 \n서울 \n미국 \n워싱턴 뉴욕  \n대한민국 \n부산 \n중국 \n베이징  \n미국 \n워싱턴 \n미국 \n뉴욕 \n중국 \n베이징 \n2 정규형 \n \n1 정규형을 만족하고, 내재된 부분 함수적 종속을 제거한다. \n기본키가 아닌 애트리뷰트 모두가 기본키에 완전 함수 종속이 되도록 부분 함수적 종속에 \n해당하는 속성을 별도의 테이블로 분리한다. \n3 정규형 \n \n1, 2 정규형을 만족하고, 이행적 함수 종속(A->B,B->A->C)을 제거한다. \nBCNF(Boyce-Code Normal Form - 보이스/코드)정규형 \n \n1, 2, 3 정규형을 만족하고, 결정자가 후보키가 아닌 함수 종속이 제거되면 보이스/코드 \n정규형에 속한다. \n후보키를 여러 개 가지고 있는 릴레이션에서 발생할 수 있는 이상 현상을 해결하기 위해 \n3 정규형보다 좀 더 강력한 제약조건을', 'Select \n조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만듦 \nProject \n속성리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만듦(중복x) \nJoin \n공통 속성을 중심으로 두 개의 릴레이션을 하나로 합침 \nDivision \n두 개의 릴레이션(R, S)에서 ㄴ가 가진 속성을 제외한 속성만을 구함 \n3) 일반 집합 연산자 \n개요 \n기호 \n합집합 (Union) \n릴레이션 R 또는 S에 존재하는 튜플 (중복 제거) \n교집합 (intersection) \n릴레이션 R과 S에 동시에 존재하는 튜플의 집합 \n차집합 (different) \n릴레이션 R에는 존재하고 S에는 없는 튜플의 집합 \n교차곱 (Cartesian product)  두 릴레이션에 있는 튜플들의 순서쌍 \nⅢ 데이터 베이스 설계 \n1. 데이터베이스 설계 \n1) 도구 : 데이터 모델 \n(1) 데이터 모델이 표시할 요소 \n구조(Structure) : 개체간의 관계 \n연산(Operation) : 실제 데이터를']","['키는 개체 집합에서 고유하게 개체를 식별할 수 있는 속성이다 . 데이터베이스에서 사용되는 키의 종류에 대한 설명으로 옳지 않은 것은?\n\n[보기]\n1) 후보키는 개체들을 고유하게 식별할 수 있는 속성이다.\n2) 슈퍼키는 한 개 이상의 속성들의 집합으로 구성된 키이다.\n3) 외래키는 다른 테이블의 기본키로 사용되는 속성이다.\n4) 대체키는 슈퍼키 중에서 기본키를 제외한 나머지 키를 의미한다.', '데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?\n\n[보기]\n1) CASE 분석\n2) 일치 분석\n3) CRUD 분석\n4) 연관성 분석', '데이터베이스에 영향을 주는 생성 , 읽기 , 갱신 , 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 것은?\n\n[보기]\n1) CASE 분석\n2) 일치 분석\n3) CRUD 분석\n4) 연관성 분석', '데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?\n\n[보기]\n1) Relation\n2) Data Structure\n3) Constraint\n4) Operation', '데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?\n\n[보기]\n1) Relation\n2) Data Structure\n3) Constraint\n4) Operation', '- 구성: 튜플: 릴레이션을 구성하는 각각의 행 (카디널리티) | 속성: 데이터 항목 또는 데이터 필드 (디그리) | 도메인: 하나의 속성이 취할 수 있는 원자값들의 집합 | 키:  - 후보키: 투플을 유일하게 식별하는 속성들의 부분집합 (유일성, 최소성)  - 기본키: 후보키 중에서 특별히 선정된 주키  - 대체키: 기본키를 제외한 나머지 후보키  - 슈퍼키: 한 릴레이션 내에 있는 속성들의 집합 (유일성O 최소성X)  - 외래키: 다른 릴레이션의 기본키를 참조하는 속성', '종류 정규화를 거치지 않으면 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란 한 현상이 발생하는데, 이를 이상(Anomaly)이라 하며 삽 입 이상, 삭제 이상, 갱신 이상이 있다. 삽입 이상 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원 (Insertion 하지 않은 값들도 함께 삽입되는 현상 Anomaly) 삭제 이상 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 (Deletion 값들도 함께 삭제되는 연쇄가 일어나는 현상 Anomaly) 갱신 이상 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜 (Update 플의 정보만 갱신되어 정보에 모순이 생기는 현상 Anomaly) 2408', '키(Key) 키(Key)는 데이터베이스에서 조건에 만족하는 튜플을 찾 거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트를 말한다.- 릴레이션을 구성하는 속성들 중에서 튜플을 유일 하게 식별하기 위해 사용하는 속성들의 부분집합, 후보키 (Candidate 즉 기본키로 사용할 수 있는 속성들을 말함 Key)- 후보키는 릴레이션에 있는 모든 튜플에 대해서 유 일성과 최소성을 만족시켜야 함- 후보키 중에서 특별히 선정된 주키(Main Key)로 중 복된 값을 가질 수 없음 기본키- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 (Primary 있는 속성 Key)- 기본키는 NULL 값을 가질 수 없다. 즉 튜플에서 기 본키로 설정된 속성에는 NULL 값이 있어서는 안 됨 대체키- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후 (Alternate 보키를 의미함 Key)- 보조키라고도 함 50- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼 슈퍼키 키로 구성된 속성의 집합과 동일한 값은 나타나지 (Super 않음 Key)- 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성 들의 집합을 의미함 외래키 (Foreign- 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본 Key) 키인 B가 동일한 도메인 상에서 정의되었을 때의 속 성 A를 외래키라고 함 2459', '하나의 속성만 있어야 하고 반복되는 속성은 별도 테이블로 분리한다. \n국가 \n도시 \n1 정규형-> \n국가 \n도시 \n대한민국 \n서울,부산 \n \n대한민국 \n서울 \n미국 \n워싱턴 뉴욕  \n대한민국 \n부산 \n중국 \n베이징  \n미국 \n워싱턴 \n미국 \n뉴욕 \n중국 \n베이징 \n2 정규형 \n \n1 정규형을 만족하고, 내재된 부분 함수적 종속을 제거한다. \n기본키가 아닌 애트리뷰트 모두가 기본키에 완전 함수 종속이 되도록 부분 함수적 종속에 \n해당하는 속성을 별도의 테이블로 분리한다. \n3 정규형 \n \n1, 2 정규형을 만족하고, 이행적 함수 종속(A->B,B->A->C)을 제거한다. \nBCNF(Boyce-Code Normal Form - 보이스/코드)정규형 \n \n1, 2, 3 정규형을 만족하고, 결정자가 후보키가 아닌 함수 종속이 제거되면 보이스/코드 \n정규형에 속한다. \n후보키를 여러 개 가지고 있는 릴레이션에서 발생할 수 있는 이상 현상을 해결하기 위해 \n3 정규형보다 좀 더 강력한 제약조건을 적용한다. \n보이스/코드 정규형에 속하는 모든 릴레이션은 3 정규형에 속하지만, 3 정규형에 속하는 \n모든 릴레이션이 보이스/코드 정규형에 속하지는 않는다. \n4 정규형 \n \n1, 2, 3, BCNF 정규형을 만족하고, 다가(다치) 종속을 제거한다. \n5 정규형 \n \n1, 2, 3, BCNF, 4 정규형을 만족하고, 후보키를 통하지 않은 조인 종속을 제거한다. \n반정규화 \n정규화를 통하여 정합성과 데이터 무결성이 보장되지만, 테이블의 개수가 증가함에 따라 \n테이블 간의 조인이 증가하여 조회 성능이 떨어질 수 있는데, 이렇게 정규화된 엔티티, \n속성, 관계에 대해 시스템의 성능 향상과 개발(Development) 및 운영(Maintenance)의 \n단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다. \n반정규화 기법 : 테이블 반정규화, 컬럼 반정규화, 관계 반정규화 \n테이블 반정규화 기법 : 테이블 병합, 테이블 분할, 테이블 추가', 'Select \n조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만듦 \nProject \n속성리스트에 제시된 속성값만을 추출하여 새로운 릴레이션을 만듦(중복x) \nJoin \n공통 속성을 중심으로 두 개의 릴레이션을 하나로 합침 \nDivision \n두 개의 릴레이션(R, S)에서 ㄴ가 가진 속성을 제외한 속성만을 구함 \n3) 일반 집합 연산자 \n개요 \n기호 \n합집합 (Union) \n릴레이션 R 또는 S에 존재하는 튜플 (중복 제거) \n교집합 (intersection) \n릴레이션 R과 S에 동시에 존재하는 튜플의 집합 \n차집합 (different) \n릴레이션 R에는 존재하고 S에는 없는 튜플의 집합 \n교차곱 (Cartesian product)  두 릴레이션에 있는 튜플들의 순서쌍 \nⅢ 데이터 베이스 설계 \n1. 데이터베이스 설계 \n1) 도구 : 데이터 모델 \n(1) 데이터 모델이 표시할 요소 \n구조(Structure) : 개체간의 관계 \n연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세 \n제약조건(Constraint)  \n2) 과정 : 요구조건 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 구현 \n(1) 개념적 설계: 개념적 데이터 모델(DBMS에 독립) + 트랜잭션 모델링=>ER다이어그램 \n(2) 논리적 설계 : 사용할 DBMS에 맞는 논리적 데이터 모델 설계 \n(3) 물리적 설계 : 물리적 저장 장치에 저장할 수 있도록 물리적 데이터 모델로 변환  \n2. 개념적 모델링 - E-R 다이어그램 (Entity-Relationship) \n기호 \n의미 \n개체 (Entity) \n관계 (Relationship) \n속성 (Attribute) \n개체타입과 속성을 연결 \n3. 논리적 모델링 – 정규화 수행 \n1) 목적 : 데이터의 중복성을 최소화하고 일관성을 보장하여 이상(anomaly) 발생 방지 \n=> 이상 : 데이터의 불필요한 중복으로 인한 이상 현상 (삽입 이상, 삭제 이상, 갱신 이상) \n2) 정규화 과정 (도부이걸다조)']"
13,다음 C 언어 프로그램이 실행되었을 때의 결과는 ?,"[""31"", ""32"", ""100"", ""190""]",1,2,프로그래밍 언어 활용,프로그래밍 언어 활용,"C 언어에서 배열의 값은 메모리 주소의 시작점을 가리킵니다. 
배열의 이름은 포인터 상수이며, 첫 번째 요소의 주소로 변환됩니다. 
배열의 각 요소의 값은 연속적으로 저장되며, 
인덱스를 사용하여 각 요소에 접근할 수 있습니다. 
따라서, 배열의 크기는 sizeof(배열) / sizeof(배열의 요소 타입)으로 구할 수 있습니다.

과목: 프로그래밍 언어 활용","['C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?', 'C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?', 'C언어에서 두 개의 논리 값 중 하나라도 참이면1을, 모두 거짓이면 0을 반환하는 연산자는?', ""다음은 파이썬으로 만들어진 반복문 코드이다 . 이 코드의 결과는 ? >> while(True) : print('A') print('B') print('C') continue print('D')"", '정규화 과정에서 함수 종속이 A → B이고 B → C일 때 A → C인 관계를 제거하는 단계는?']","['빌드 도구 빌드는 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말한다.- 빌드 도구는 소스 코드를 소프트웨어로 변환하는 과정 에 필요한 전처리(Preprocessing), 컴파일(Compile) 등 의 작업들을 수행하는 소프트웨어를 말한다.- 대표적인 도구로는 Ant, Maven, Gradle 등이 있다. 아파치 소프트웨어 재단(Apache Software Foundation)에 Ant 서 개발한 소프트웨어로, 자바 프로젝트의 공식적인 빌드 도구로 사용되고 있음 Ant와 동일한 아파치 소프트웨어 재단에서 개발된 것으 Maven 로, Ant의 대안으로 개발되었음 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구로, 한 Gradle 스 도커(Hans Dockter) 외 6인의 개발자가 모여 공동 개 발하였음 32 2404', '프로그램을 컴퓨터에서 실행가능한 형태로 변환 \n디버깅 \n버그를 찾아 수정 \n배포 \n사용자에게 배포 \n2. 인터페이스 구현  \n1) 모듈 연계 방법 (데이터 교환을 위한 관계 설정) : EAI \n2) 인터페이스 구현 \n(1) 통신 기술 : AJAX (Javascript를 이용한 비동기 통신 기술) \n데이터 포맷: JSON (데이터 객체를 속성-값의 쌍 형태로 표현), XML (마크업 언어) \n(2) 보안 : 스니핑(수동적 공격)을 막기 위해 네트워크 트래픽에 대한 암호화 설정 \n=> 방식 : IPSec, SSL, S-HTTP 등 \n3) 구현 검증 도구 \nxUnit \nJava(Junit), C++(CppUnit) 등 다양한 언어를 지원 \nSTAF \n다양한 환경을 지원 \nFitNess \n웹기반 \nNTAF \nFitNess + STAF \nwatir \nRuby 기반 \nEAI 구축 유형 \n설명 \nPoint-to-Point \n애플리케이션의 1:1 연결 \nHub & Spoke \n허브를 통해 데이터를', '4과목: 프로그래밍 언어 활용\n\n출제 경향 \n\u200b 2장(언어) / 3장(알고리즘) 집중.\u200b\n\u200b 실기와 직접 연결됨.\u200b\n핵심 개념 \n\u200b 자료형: C, Java, Python (list, tuple, range)\u200b\n\u200b 연산자/반복문: for, while / 산술, 논리, 비트\u200b\n\u200b 포인터: *, & 연산자 / 포인터 배열 구분\u200b\n\u200b 스크립트 언어: JS, PHP, Python, 쉘\u200b\n\u200b 라이브러리: stdio.h, math.h, string.h, stdlib.h\u200b\n\u200b 운영체제 명령어: uname, fork, chmod, ls\u200b\n\u200b 가상기억장치:\u200b\n\u200b 페이징 vs 세그먼트\u200b\n\u200b 교체 알고리즘: FIFO, LRU, LFU\u200b\n\u200b 워킹셋, 스래싱 개념\u200b\n\u200b 프로세스/스레드 상태: ready, running, blocked 등\u200b\n\u200b 스케줄링: SJF, HRN\u200b\n\u200b TCP/IP: TCP(양방향), IP, UDP, ICMP, ARP\u200b\n\u200b OSI 7계층 / IPv4 vs IPv6 차이\u200b', '종류 언어 특징- 분산 네트워크 환경에 적용이 가능하며, 멀티스레드 기 능을 제공하므로 여러 작업을 동시에 처리할 수 있음 JAVA- 운영체제 및 하드웨어에 독립적이며, 이식성이 강함- 캡슐화가 가능하고 재사용성 높음- C 언어에 객체지향 개념을 적용한 언어 C++- 모든 문제를 객체로 모델링하여 표현함- 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객 Smalltalk 체지향 프로그래밍 언어- 최초로 GUI를 제공한 언어 401', '코드의 종류 코드의 종류에는 다음과 같은 것들이 있다. 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 순차 코드 최초의 자료부터 차례로 일련번호를 부여하는 방법 (Sequence 으로, 순서 코드 또는 일련번호 코드라고도 함 Code) \ue355 1, 2, 3, 4, … 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 블록 코드 (Block Code) 부여하는 방법으로, 구분 코드라고도 함 \ue355 1001~1']","['C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?\n\n[보기]\n1) ∥\n2) &&\n3) **\n4) !=', 'C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?\n\n[보기]\n1) ∥\n2) &&\n3) **\n4) !=', 'C언어에서 두 개의 논리 값 중 하나라도 참이면1을, 모두 거짓이면 0을 반환하는 연산자는?\n\n[보기]\n1) ∥\n2) &&\n3) **\n4) !=', ""다음은 파이썬으로 만들어진 반복문 코드이다 . 이 코드의 결과는 ? >> while(True) : print('A') print('B') print('C') continue print('D')\n\n[보기]\n1) A, B, C 출력이 반복된다.\n2) A, B, C 까지만 출력된다 .\n3) A, B, C, D 출력이 반복된다 .\n4) A, B, C, D 까지만 출력된다 ."", '정규화 과정에서 함수 종속이 A → B이고 B → C일 때 A → C인 관계를 제거하는 단계는?\n\n[보기]\n1) 1NF →2NF\n2) 2NF →3NF\n3) 3NF → BCNF\n4) BCNF →4NF', '빌드 도구 빌드는 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말한다.- 빌드 도구는 소스 코드를 소프트웨어로 변환하는 과정 에 필요한 전처리(Preprocessing), 컴파일(Compile) 등 의 작업들을 수행하는 소프트웨어를 말한다.- 대표적인 도구로는 Ant, Maven, Gradle 등이 있다. 아파치 소프트웨어 재단(Apache Software Foundation)에 Ant 서 개발한 소프트웨어로, 자바 프로젝트의 공식적인 빌드 도구로 사용되고 있음 Ant와 동일한 아파치 소프트웨어 재단에서 개발된 것으 Maven 로, Ant의 대안으로 개발되었음 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구로, 한 Gradle 스 도커(Hans Dockter) 외 6인의 개발자가 모여 공동 개 발하였음 32 2404', '프로그램을 컴퓨터에서 실행가능한 형태로 변환 \n디버깅 \n버그를 찾아 수정 \n배포 \n사용자에게 배포 \n2. 인터페이스 구현  \n1) 모듈 연계 방법 (데이터 교환을 위한 관계 설정) : EAI \n2) 인터페이스 구현 \n(1) 통신 기술 : AJAX (Javascript를 이용한 비동기 통신 기술) \n데이터 포맷: JSON (데이터 객체를 속성-값의 쌍 형태로 표현), XML (마크업 언어) \n(2) 보안 : 스니핑(수동적 공격)을 막기 위해 네트워크 트래픽에 대한 암호화 설정 \n=> 방식 : IPSec, SSL, S-HTTP 등 \n3) 구현 검증 도구 \nxUnit \nJava(Junit), C++(CppUnit) 등 다양한 언어를 지원 \nSTAF \n다양한 환경을 지원 \nFitNess \n웹기반 \nNTAF \nFitNess + STAF \nwatir \nRuby 기반 \nEAI 구축 유형 \n설명 \nPoint-to-Point \n애플리케이션의 1:1 연결 \nHub & Spoke \n허브를 통해 데이터를 전송하는 중앙 집중형 방식 \nMessage Bus (ESB 방식) \n애플리케이션 사이에 미들웨어를 두어 처리 \nHybrid \nHub & Spoke(그룹내) + Message Bus(그룹간) \n3. 테스트 \n1) 애플리케이션 테스트 : 애플리케이션에 잠재되어 있는 결함을 찾아내는 행위 \n(1) 확인과 검증 \n확인 : 요구사항 만족 확인 (사용자 중심) \n검증 : 명세서에 맞게 만들어졌는지 검증 (개발자 중심) \n(2) 기본 원리  \n파레토법칙 : 오류의 80%는 20%의 모듈에서 발견된다 => 결함 집중 \n(3) 테스트 오라클: 결과를 판단하기 위해 테스트케이스에 대한 예상결과 계산, 확인 \n참오라클 \n모든 테스트 케이스의 입력값에 대한 기대값 제공 \n샘플링 오라클 \n특정 케이스에 대한 기대값 제공 \n추정 오라클 \n특정 케이스에 대한 기댓값 + 나머지는 추정으로 처리 \n일관성 검사 오라클 \n애플리케이션 변경 시, 변경 전과 후의 결과값이 동일한지 비교', '4과목: 프로그래밍 언어 활용\n\n출제 경향 \n\u200b 2장(언어) / 3장(알고리즘) 집중.\u200b\n\u200b 실기와 직접 연결됨.\u200b\n핵심 개념 \n\u200b 자료형: C, Java, Python (list, tuple, range)\u200b\n\u200b 연산자/반복문: for, while / 산술, 논리, 비트\u200b\n\u200b 포인터: *, & 연산자 / 포인터 배열 구분\u200b\n\u200b 스크립트 언어: JS, PHP, Python, 쉘\u200b\n\u200b 라이브러리: stdio.h, math.h, string.h, stdlib.h\u200b\n\u200b 운영체제 명령어: uname, fork, chmod, ls\u200b\n\u200b 가상기억장치:\u200b\n\u200b 페이징 vs 세그먼트\u200b\n\u200b 교체 알고리즘: FIFO, LRU, LFU\u200b\n\u200b 워킹셋, 스래싱 개념\u200b\n\u200b 프로세스/스레드 상태: ready, running, blocked 등\u200b\n\u200b 스케줄링: SJF, HRN\u200b\n\u200b TCP/IP: TCP(양방향), IP, UDP, ICMP, ARP\u200b\n\u200b OSI 7계층 / IPv4 vs IPv6 차이\u200b', '종류 언어 특징- 분산 네트워크 환경에 적용이 가능하며, 멀티스레드 기 능을 제공하므로 여러 작업을 동시에 처리할 수 있음 JAVA- 운영체제 및 하드웨어에 독립적이며, 이식성이 강함- 캡슐화가 가능하고 재사용성 높음- C 언어에 객체지향 개념을 적용한 언어 C++- 모든 문제를 객체로 모델링하여 표현함- 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객 Smalltalk 체지향 프로그래밍 언어- 최초로 GUI를 제공한 언어 401', '코드의 종류 코드의 종류에는 다음과 같은 것들이 있다. 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 순차 코드 최초의 자료부터 차례로 일련번호를 부여하는 방법 (Sequence 으로, 순서 코드 또는 일련번호 코드라고도 함 Code) \ue355 1, 2, 3, 4, … 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 블록 코드 (Block Code) 부여하는 방법으로, 구분 코드라고도 함 \ue355 1001~1']"
14,"HRN 방식으로 스케줄링 할 경우 , 입력된 작업이 다음과 같을 때 처리되는 작업 순서로 옳은 것은?","[""A → B → C → D"", ""A → C → B → D"", ""D → B → C → A"", ""D → A → B → C""]",3,4,프로그래밍 언어 활용,프로그래밍 언어 활용,"HRN 방식의 우선순위 계산식은 (대기시간 + 서비스시간) / 서비스시간이다. 각각의 작업에 대해 계산하면 다음과 같다.

- A 작업: (5 + 5) / 5 = 2
- B 작업: (10 + 6) / 6 = 2.67
- C 작업: (15 + 7) / 7 = 3.14
- D 작업: (20 + 8) / 8 = 3.5

결과가 큰 값이 우선순위가 높으므로, 우선순위가 높은 순으로 D, C, B, A 이다. 
따라서 처리되는 작업 순서는 D → A → B → C 이다.

과목: 프로그래밍 언어 활용","['해싱 함수 중 레코드 키를 여러 부분으로 나누고 , 나눈 부분의 각 숫자를 더하거나 XOR 한 값을 홈 주소로 사용하는 방식은 ?', '트랜잭션의 주요 특성 중 하나로 , 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션 의 연산이 끼어들 수 없음을 의미하는 것은?', '코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는 ?', '3개의 보관구조를 가지는 주기억장치가 있으며, 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우 마지막 페이지 값으로 옳은 것은?', '소프트웨어 개발 모델 중 나선형 모델의4 가지 주요 활동이 순서대로 나열된 것은?']","['스케줄링- HRN HRN 방식으로 스케줄링할 경우, 입력된 작업이 다음과 같 예 을 때 우선순위가 가장 높은 작업은? 작업 대기시간 서비스시간 A 5 5 B 10 6 C 15 7 D 20 8 대기 시간 + 서비스 시간- HRN 방식의 우선순위 계산식은 서비스 시간 이므로 이 식에 대입해서 풀면 된다. 5+5- A 작업은 = 2 5 10+6- B 작업은 = 2.6 6 15+7- C 작업은 = 3.1 7 20+8- D 작업은 = 3.5이다. 8- 결과가 큰 값이 우선순위가 높다.', '스케줄링- HRN HRN 방식으로 스케줄링할 경우, 입력된 작업이 다음과 같 예 을 때 우선순위가 가장 높은 작업은? 작업 대기시간 서비스시간 A 5 5 B 10 6 C 15 7 D 20 8 대기 시간 + 서비스 시간- HRN 방식의 우선순위 계산식은 서비스 시간 이므로 이 식에 대입해서 풀면 된다. 5+5- A 작업은 = 2 5 10+6- B 작업은 = 2.6 6 15+7- C 작업은 = 3.1 7 20+8- D 작업은 = 3.5이다. 8- 결과가 큰 값이 우선순위가 높다.', '박스 노드는 프로젝트의 중간 점검을 뜻하는 이정표로, 이 노드 위에 예상 완료 시간이 \n표시된다. \n한 이정표에서 다른 이정표에 도달하기 전의 작업이 모두 완료되어야만 다음 작업의 진행이 \n가능하다. \n모든 작업을 거치려면 2+2+3+3 (10)일, 2+3+5+4 (14)일과 같이 두 가지 작업 방식이 \n있으며, 짧은 작업보다 긴 작업을 선택해서 계산해야 그 시간 안에 모든 일을 처리할 수 \n있게 된다. \n67. 소프트웨어 개발 방법론 \n소프트웨어 개발 방법론의 개요 \n \n소프트웨어 개발 생명주기에 소프트웨어 공학 원리를 적용한 것으로 소프트웨어 개발 전 \n과정에 지속적으로 작용할 수 있는 방법, 절차, 기법 등을 의미하며, 시스템 개발 \n주기라고도 한다. \n소프트웨어 개발 과정을 정리하고 표준화하여 프로그래머 개인이 개발 과정에서의 일관성을 \n유지하고 프로그래머들 간의 효과적인 협업이 이루어질 수 있게 한다. \n소프트웨어 개발 방법론의 목적 \n \n소프트웨어 개발 생산성 향상, 소프', '2과목: 소프트웨어 개발\n\nⅡ 개발 + 테스트 : 개발하면서 테스트 진행 (개발 끝나고만 하는거 아님!) \n1. 기본적인 구현 방법 \n1) 자료 구조 \n(1) 선형 자료 구조 : 배열, 선형 리스트(연속리스트와 연결리스트), 스택, 큐, 데크 \na. 스택 \n특징 : 한 쪽으로만 입출력 => 후입선출 (LIFO, Last In First Out) \n오버플로우 : 스택이 가득 찬 상태에서 데이터 삽입시 발생 \n언더플로우 :스택이 텅 빈 상태에서 데이터 삭제시 발생 \n활용 : 인터럽트의 처리. 수식의 계산, 서브루틴 호출 작업 등 \nb. 큐 : 선입선출 (FIFO, First In First Out) \nc. 데크 : 삽입과 삭제가 양쪽 끝에서 모두 발생 가능 \n(2) 비선형 자료 구조 : 트리, 그래프 \na. 트리 \n정의 : 사이클이 없는 그래프 \n노드(정점) \n트리의 기본 요소 (하나의 기억 공간) \n링크(간선) \n노드와 노드를 연결하는 선 \n차수(Degree) \n연결된 하위 노드(자식', '스케줄링- SJF 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하 는 기법이다. 다음과 같은 프로세스들이 차례로 준비상태 큐에 들 예제 어왔다고 가정할 때, SJF 기법을 이용하여 평균 실행 시간, 평 균 대기 시간, 평균 반환 시간을 구하시오(제출 시간이 있을 경우). 프로세스 번호 P1 P2 P3 실행 시간 20 7 4 도착 시간 0 1 2 진행시간 0 10 20 30 20 20 실행 0 P1 완료 도착 실행 시작 4 18 20 실행 24 2 도착 P3 대기 실행 완료 시작 7 23 24 31 실행 도착 1 P2 대기 실행 완료 시작- 평균 실행 시간 : (20+4+7)/3 = 10.3- 평균 대기 기간 : (0+18+23)/3 = 13.6- 평균 반환 시간 : (20+22+30)/3 = 24 31']","['해싱 함수 중 레코드 키를 여러 부분으로 나누고 , 나눈 부분의 각 숫자를 더하거나 XOR 한 값을 홈 주소로 사용하는 방식은 ?\n\n[보기]\n1) 제산법\n2) 폴딩법\n3) 기수 변환법\n4) 숫자 분석법', '트랜잭션의 주요 특성 중 하나로 , 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션 의 연산이 끼어들 수 없음을 의미하는 것은?\n\n[보기]\n1) Log\n2) Consistency\n3) Isolation\n4) Durability', '코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는 ?\n\n[보기]\n1) 연상 코드\n2) 블록 코드\n3) 순차 코드\n4) 표의 숫자 코드', '3개의 보관구조를 가지는 주기억장치가 있으며, 다음의 순서로 페이지 참조가 발생할 때, FIFO 페이지 교체 알고리즘을 사용할 경우 마지막 페이지 값으로 옳은 것은?\n\n[보기]\n1) 4,2,3\n2) 4,1,3\n3) 1,2,3\n4) 1,4,2', '소프트웨어 개발 모델 중 나선형 모델의4 가지 주요 활동이 순서대로 나열된 것은?\n\n[보기]\n1) Ⓐ - Ⓑ - Ⓓ - Ⓒ 순으로 반복\n2) Ⓐ - Ⓓ - Ⓒ - Ⓑ 순으로 반복\n3) Ⓐ - Ⓑ - Ⓒ - Ⓓ 순으로 반복\n4) Ⓐ - Ⓒ - Ⓑ - Ⓓ 순으로 반복', '스케줄링- HRN HRN 방식으로 스케줄링할 경우, 입력된 작업이 다음과 같 예 을 때 우선순위가 가장 높은 작업은? 작업 대기시간 서비스시간 A 5 5 B 10 6 C 15 7 D 20 8 대기 시간 + 서비스 시간- HRN 방식의 우선순위 계산식은 서비스 시간 이므로 이 식에 대입해서 풀면 된다. 5+5- A 작업은 = 2 5 10+6- B 작업은 = 2.6 6 15+7- C 작업은 = 3.1 7 20+8- D 작업은 = 3.5이다. 8- 결과가 큰 값이 우선순위가 높다.', '스케줄링- HRN HRN 방식으로 스케줄링할 경우, 입력된 작업이 다음과 같 예 을 때 우선순위가 가장 높은 작업은? 작업 대기시간 서비스시간 A 5 5 B 10 6 C 15 7 D 20 8 대기 시간 + 서비스 시간- HRN 방식의 우선순위 계산식은 서비스 시간 이므로 이 식에 대입해서 풀면 된다. 5+5- A 작업은 = 2 5 10+6- B 작업은 = 2.6 6 15+7- C 작업은 = 3.1 7 20+8- D 작업은 = 3.5이다. 8- 결과가 큰 값이 우선순위가 높다.', '박스 노드는 프로젝트의 중간 점검을 뜻하는 이정표로, 이 노드 위에 예상 완료 시간이 \n표시된다. \n한 이정표에서 다른 이정표에 도달하기 전의 작업이 모두 완료되어야만 다음 작업의 진행이 \n가능하다. \n모든 작업을 거치려면 2+2+3+3 (10)일, 2+3+5+4 (14)일과 같이 두 가지 작업 방식이 \n있으며, 짧은 작업보다 긴 작업을 선택해서 계산해야 그 시간 안에 모든 일을 처리할 수 \n있게 된다. \n67. 소프트웨어 개발 방법론 \n소프트웨어 개발 방법론의 개요 \n \n소프트웨어 개발 생명주기에 소프트웨어 공학 원리를 적용한 것으로 소프트웨어 개발 전 \n과정에 지속적으로 작용할 수 있는 방법, 절차, 기법 등을 의미하며, 시스템 개발 \n주기라고도 한다. \n소프트웨어 개발 과정을 정리하고 표준화하여 프로그래머 개인이 개발 과정에서의 일관성을 \n유지하고 프로그래머들 간의 효과적인 협업이 이루어질 수 있게 한다. \n소프트웨어 개발 방법론의 목적 \n \n소프트웨어 개발 생산성 향상, 소프트웨어 품질 향상, 효과적인 프로젝트 관리, 의사소통 \n수단 제공 \n구현(Implementation) \n \n프로그래밍 또는 코딩이라고 불리며 설계 명세서가 컴퓨터가 알 수 있는 모습으로 변환되는 \n과정을 의미한다. \n구조적 방법론(Structured Development Methodolohy) \n \n정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 체계적인 방법론이다. \n요구사항 분석, 구조적 분석, 구조적 설계, 구조적 프로그래밍 단계로 구성된다. \n쉽게 이해할 수 있고 검증할 수 있는 프로그램의 부호를 생성하는 것이 목적이다. \n1970 년대까지 가장 많이 적용된 방법론이다. \n시스템 분석을 위해 데이터 흐름 다이어그램(Data Flow Diagram)이 주로 사용된다. \n시스템 설계를 위해 구조도(Structured Chart) 기획, 분석, 설계, 구축하는 데이터 \n중심의 방법론이다. \n구조적 방법론의 거시적 관점 부재에서 등장하였다.', '2과목: 소프트웨어 개발\n\nⅡ 개발 + 테스트 : 개발하면서 테스트 진행 (개발 끝나고만 하는거 아님!) \n1. 기본적인 구현 방법 \n1) 자료 구조 \n(1) 선형 자료 구조 : 배열, 선형 리스트(연속리스트와 연결리스트), 스택, 큐, 데크 \na. 스택 \n특징 : 한 쪽으로만 입출력 => 후입선출 (LIFO, Last In First Out) \n오버플로우 : 스택이 가득 찬 상태에서 데이터 삽입시 발생 \n언더플로우 :스택이 텅 빈 상태에서 데이터 삭제시 발생 \n활용 : 인터럽트의 처리. 수식의 계산, 서브루틴 호출 작업 등 \nb. 큐 : 선입선출 (FIFO, First In First Out) \nc. 데크 : 삽입과 삭제가 양쪽 끝에서 모두 발생 가능 \n(2) 비선형 자료 구조 : 트리, 그래프 \na. 트리 \n정의 : 사이클이 없는 그래프 \n노드(정점) \n트리의 기본 요소 (하나의 기억 공간) \n링크(간선) \n노드와 노드를 연결하는 선 \n차수(Degree) \n연결된 하위 노드(자식 노드)의 개수 = 각 노드가 가진 가지 \n수 \n트리의 차수 \n노드의 차수 중 가장 많은 수 \n루트 노드 \n맨 위에 있는 노드 \n리프 노드 \n차수가 0인 노드 \n트리의 운행법(순회 방법) \n순회 순서 \nPreorder : root -> left -> right  \nABDCEFG \nInorder : left -> root -> right \nDBAECFG \nPostorder : left -> right -> root \nDBEGFCA \n2) 정렬 구현 (=> 실제로 구현했을 때의 결과를 주로 물어봄, 괄호는 시간복잡도) \n(1) 선택정렬: n개중 최소값을 1번에, n-1개중 최소값을 2번에 두는 것을 반복 (n^2) \n(2) 버블정렬: 인접한 두 개의 값을 비교해서 서로 교환하기를 반복 (n^2) \n(3) 삽입정렬: n번째 키를 적절한 위치(1 ~ n)에 삽입해서 정렬 \n(3) 퀵정렬 : 하나의 파일을 부분적으로 나누어가며 정렬 (nlogn ~ n^2)', '스케줄링- SJF 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하 는 기법이다. 다음과 같은 프로세스들이 차례로 준비상태 큐에 들 예제 어왔다고 가정할 때, SJF 기법을 이용하여 평균 실행 시간, 평 균 대기 시간, 평균 반환 시간을 구하시오(제출 시간이 있을 경우). 프로세스 번호 P1 P2 P3 실행 시간 20 7 4 도착 시간 0 1 2 진행시간 0 10 20 30 20 20 실행 0 P1 완료 도착 실행 시작 4 18 20 실행 24 2 도착 P3 대기 실행 완료 시작 7 23 24 31 실행 도착 1 P2 대기 실행 완료 시작- 평균 실행 시간 : (20+4+7)/3 = 10.3- 평균 대기 기간 : (0+18+23)/3 = 13.6- 평균 반환 시간 : (20+22+30)/3 = 24 31']"
15,"C, Java 언어 등에서 사용되는 예약어로 , 반복문 안에서 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮기는 명령어는 무엇인가?","[""break"", ""continue"", ""next"", ""release""]",2,2,프로그래밍 언어 활용,프로그래밍 언어 활용,"C, Java 언어 등에서 사용되는 예약어로, 반복문 안에서 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮기는 명령어는 'continue'입니다. 
이는 반복문에서 특정 조건일 때 나머지 문장을 실행하지 않고 다음 반복을 진행해야 할 때 사용됩니다. 
보기에서 'continue'가 바로 정답입니다.

과목: 프로그래밍 언어 활용

이 문제는 프로그래밍 언어에서 사용되는 제어문과 관련하여 다루고 있기 때문에, '프로그래밍 언어 활용' 과목에 적합합니다. 
이 과목에서는 프로그래밍 언어의 기본 문법과 제어 구조, 함수, 배열 등의 활용법을 학습합니다. 
특히, 반복문과 조건문, 그리고 제어를 이동하는 예약어 등에 대해 배우게 됩니다. 
따라서, 이 문제는 '프로그래밍 언어 활용' 과목의 범주에 속하는 문제입니다.","['JAVA 에서 힙 (Heap) 에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?', 'JAVA에서 힙(Heap)에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?', 'C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?', '다음 중 Java 에서 표준 출력 시 사용하는 명령어가 아닌 것은 ?', '다음은 Java 로 만들어진 반복문 코드이다 . 이 코드의 결과는 ?']","['break, continue switch문이나 반복문의 실행을 제어하기 위해 사용되는 예약어이다.- break : switch문이나 반복문 안에서 break가 나오면 블록을 벗어난다.- continue- \u200c continue 이후의 문장을 실행하지 않고 제어를 반복 문의 처음으로 옮긴다.- \u200c 반복문에서만 사용된다. 78 다음은 1~5까지의 합을 더하되 2의 배수는 배제 예제 하는 프로그램이다. 결과를 확인하시오. #include <stdio.h> main( ) { int a = 0, hap = 0; while(1) ❶ 조건이 참(1)이므로 무한 반복한 다. 중간에 반복을 끝내는 문장 이 반드시 있어야 한다. { ❷ ❷~❾번까지가 반복문의 범위 이다. a++; ❸ ‘a = a + 1;’과 동일하다. a의 값 을 1씩 증가시킨다. if(a > 5) ❹ a가 5보다 크면 ❺번 문장을 수행하고, 아니면 ❻번 문장을 수행한다. break; ❺ 반복문을 탈출하여 ❿번으로 이동한다. if (a ', '초 (Behavioral Pattern) 치기- 책임 연쇄(Chain of Responsibility) : 요청을 한 객체가 처 리하지 못하면 다음 객체로 넘어가는 형태- 커맨드(Command) : 재이용하거나 취소할 수 있도록 요 청에 필요한 정보를 저장함- 인터프리터(Interpreter) : 언어에 문법 표현을 정의함- 반복자(Iterator) : 접근이 잦은 객체에 대해 동일한 인터 페이스를 사용하도록 함- 중재자(Mediator) : 복잡한 상호 작용을 캡슐화하여 객체 로 정의함- 메멘토(Memento) : 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공, + 와 같은 되돌리기 기능을 개 C Z 발할 때 주로 이용함- 옵서버(Observer) : 객체에 상속되어 있는 다른 객체들에 게 변화된 상태를 전달함- 상태(State) : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용함- 전략(Strategy) : 동일한 계열의 알고리즘들을 상호 교환 할 수 있게', '초 (Behavioral Pattern) 치기- 책임 연쇄(Chain of Responsibility) : 요청을 한 객체가 처 리하지 못하면 다음 객체로 넘어가는 형태- 커맨드(Command) : 재이용하거나 취소할 수 있도록 요 청에 필요한 정보를 저장함- 인터프리터(Interpreter) : 언어에 문법 표현을 정의함- 반복자(Iterator) : 접근이 잦은 객체에 대해 동일한 인터 페이스를 사용하도록 함- 중재자(Mediator) : 복잡한 상호 작용을 캡슐화하여 객체 로 정의함- 메멘토(Memento) : 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공, + 와 같은 되돌리기 기능을 개 C Z 발할 때 주로 이용함- 옵서버(Observer) : 객체에 상속되어 있는 다른 객체들에 게 변화된 상태를 전달함- 상태(State) : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용함- 전략(Strategy) : 동일한 계열의 알고리즘들을 상호 교환 할 수 있게', 'if(조건식1) 조건식1 이 참일 떄 실행하는 명령문; \n    else if(조건식2) 조건식2 의 결과가 참일 때 실행하는 명령문; \n    else 조건식 1 과 조건식 2 의 결과가 거짓일 때 실행하는 명령문; \n삼항 연산자에 의한 조건문 \n \n조건식 ? 참일 때 명령문 : 거짓일 때 명령문 \nswitch ~ case 문 \n \nswitch(조건값) { \n    case 값1: \n        조건값이 값1 일 때 실행하는 명령문; \n        break; \n    case 값2: \n        조건값이 값2 일 때 실행하는 명령문; \n        break; \n    ... \n    default: \n        조건값이 모든 case 에 해당되지 않을 때 실행하는 명령문; \n        break; \n} \n반복문 \nwhile 문 \n \n조건식의 결과가 참이면 while 문 내의 명령을 실행하고 다시 조건식을 검사한다. \n조건의 초기값이 거짓이면 while 문 내의 ', 'do~while문 do~while문은 조건이 참인 동안 정해진 문장을 반복 수 행하다가 조건이 거짓이면 반복문을 벗어나는 while문과 같은 동작을 하는데, 다른 점은 do~while문은 실행할 문 장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여 부를 결정한다는 것이다.- do~while문은 실행할 문장을 우선 실행한 후 조건을 판별하여 조건이 참이면 실행할 문장을 계속 반복 수행 하고, 거짓이면 do~while문을 끝낸 후 다음 코드를 실 행한다. 참 거짓 실행할 문장 다음 코드 조건 do~while문의 동작 과정- 형식 do do는 do~while문에 사용되는 예약어로, do~while \x08 의 시작 부분에 그대로 입력한다. 실행할 문장; 조건이 참인 동안 실행할 문장을 입력한다. 문장이 두 문장 이상인 경우 { }를 입력하고 그 사이에 실행 \x08 할 문장들을 입력한다. while(조건);- while은 do~while문에 사용되는 예약어로, do~while의 끝 부분에 그']","['JAVA 에서 힙 (Heap) 에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?\n\n[보기]\n1) Heap Collector\n2) Garbage Collector\n3) Memory Collector\n4) Variable Collector', 'JAVA에서 힙(Heap)에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?\n\n[보기]\n1) Heap Collector\n2) Garbage Collector\n3) Memory Collector\n4) Variable Collector', 'C 언어에서 두 개의 논리 값 중 하나라도 참이면1 을 , 모두 거짓이면 0 을 반환하는 연산자는 ?\n\n[보기]\n1) ∥\n2) &&\n3) **\n4) !=', '다음 중 Java 에서 표준 출력 시 사용하는 명령어가 아닌 것은 ?\n\n[보기]\n1) prn\n2) print\n3) printf\n4) println', '다음은 Java 로 만들어진 반복문 코드이다 . 이 코드의 결과는 ?\n\n[보기]\n1) a =0, sum =0\n2) a =1, sum =1\n3) a =9, sum =45\n4) a =10, sum =55', 'break, continue switch문이나 반복문의 실행을 제어하기 위해 사용되는 예약어이다.- break : switch문이나 반복문 안에서 break가 나오면 블록을 벗어난다.- continue- \u200c continue 이후의 문장을 실행하지 않고 제어를 반복 문의 처음으로 옮긴다.- \u200c 반복문에서만 사용된다. 78 다음은 1~5까지의 합을 더하되 2의 배수는 배제 예제 하는 프로그램이다. 결과를 확인하시오. #include <stdio.h> main( ) { int a = 0, hap = 0; while(1) ❶ 조건이 참(1)이므로 무한 반복한 다. 중간에 반복을 끝내는 문장 이 반드시 있어야 한다. { ❷ ❷~❾번까지가 반복문의 범위 이다. a++; ❸ ‘a = a + 1;’과 동일하다. a의 값 을 1씩 증가시킨다. if(a > 5) ❹ a가 5보다 크면 ❺번 문장을 수행하고, 아니면 ❻번 문장을 수행한다. break; ❺ 반복문을 탈출하여 ❿번으로 이동한다. if (a % 2 == 0) ❻ a를 2로 나눈 나머지가 0이면, 즉 a가 2의 배수이면 ❼번 문 장을 수행하고, 아니면 ❽번 문장으로 이동한다. continue; ❼ 이후의 문장, 즉 ❽번을 생략 하고 반복문의 처음인 ❶번으 로 이동한다. 2의 배수는 hap 에 누적되지 않는다. hap += a; ❽ ‘hap = hap + a’와 동일하다. a의 값을 hap에 누적시킨다. } ❾ 반복문의 끝이다. \\ printf(""%d, %d n"", a, hap); ❿ 6, 9 결과 } 400', '초 (Behavioral Pattern) 치기- 책임 연쇄(Chain of Responsibility) : 요청을 한 객체가 처 리하지 못하면 다음 객체로 넘어가는 형태- 커맨드(Command) : 재이용하거나 취소할 수 있도록 요 청에 필요한 정보를 저장함- 인터프리터(Interpreter) : 언어에 문법 표현을 정의함- 반복자(Iterator) : 접근이 잦은 객체에 대해 동일한 인터 페이스를 사용하도록 함- 중재자(Mediator) : 복잡한 상호 작용을 캡슐화하여 객체 로 정의함- 메멘토(Memento) : 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공, + 와 같은 되돌리기 기능을 개 C Z 발할 때 주로 이용함- 옵서버(Observer) : 객체에 상속되어 있는 다른 객체들에 게 변화된 상태를 전달함- 상태(State) : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용함- 전략(Strategy) : 동일한 계열의 알고리즘들을 상호 교환 할 수 있게 정의함- 템플릿 메소드(Template Method) : 하위 클래스에서 세부 처리를 구체화함- 방문자(Visitor) : 처리 기능을 분리하여 별도의 클래스로 구성함', '초 (Behavioral Pattern) 치기- 책임 연쇄(Chain of Responsibility) : 요청을 한 객체가 처 리하지 못하면 다음 객체로 넘어가는 형태- 커맨드(Command) : 재이용하거나 취소할 수 있도록 요 청에 필요한 정보를 저장함- 인터프리터(Interpreter) : 언어에 문법 표현을 정의함- 반복자(Iterator) : 접근이 잦은 객체에 대해 동일한 인터 페이스를 사용하도록 함- 중재자(Mediator) : 복잡한 상호 작용을 캡슐화하여 객체 로 정의함- 메멘토(Memento) : 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공, + 와 같은 되돌리기 기능을 개 C Z 발할 때 주로 이용함- 옵서버(Observer) : 객체에 상속되어 있는 다른 객체들에 게 변화된 상태를 전달함- 상태(State) : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용함- 전략(Strategy) : 동일한 계열의 알고리즘들을 상호 교환 할 수 있게 정의함- 템플릿 메소드(Template Method) : 하위 클래스에서 세부 처리를 구체화함- 방문자(Visitor) : 처리 기능을 분리하여 별도의 클래스로 구성함', 'if(조건식1) 조건식1 이 참일 떄 실행하는 명령문; \n    else if(조건식2) 조건식2 의 결과가 참일 때 실행하는 명령문; \n    else 조건식 1 과 조건식 2 의 결과가 거짓일 때 실행하는 명령문; \n삼항 연산자에 의한 조건문 \n \n조건식 ? 참일 때 명령문 : 거짓일 때 명령문 \nswitch ~ case 문 \n \nswitch(조건값) { \n    case 값1: \n        조건값이 값1 일 때 실행하는 명령문; \n        break; \n    case 값2: \n        조건값이 값2 일 때 실행하는 명령문; \n        break; \n    ... \n    default: \n        조건값이 모든 case 에 해당되지 않을 때 실행하는 명령문; \n        break; \n} \n반복문 \nwhile 문 \n \n조건식의 결과가 참이면 while 문 내의 명령을 실행하고 다시 조건식을 검사한다. \n조건의 초기값이 거짓이면 while 문 내의 명령문은 한 번도 실행되지 않는다. \nwhile(조건식){ \n    명령문 1; \n    ... \n    명령문 n; \n} \ndo ~ while 문 \n \n명령문을 일단 실행하고 나서 조건식을 검사하여 반복 실행 여부를 결정한다. \n명령문이 적어도 한 번은 실행된다. \ndo { \n    명령문 1; \n    ... \n    명령문 n; \n} while(조건식); \nfor 문 \n \n반복 변수를 초기화하는 초기식은 한 번만 수행되고 조건식을 만족하면 하위 명령문을 \n수행한 후 증감식을 수행하고 조건식을 검사하면서 반복한다. \nfor(초기식; 조건식; 증감식){ \n    명령문 1; \n    ... \n    명령문 n; \n} \n54. 스크립트 언어와 Python \n스크립트 언어 \n스크립트 언어(Script Language)의 개념 \n \n소스 코드를 컴파일 과정을 거치지 않고 실행할 수 있는 프로그래밍 언어이다. \n스크립트 언어에 내장된 번역기에 의해 번역되어 실행된다.', 'do~while문 do~while문은 조건이 참인 동안 정해진 문장을 반복 수 행하다가 조건이 거짓이면 반복문을 벗어나는 while문과 같은 동작을 하는데, 다른 점은 do~while문은 실행할 문 장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여 부를 결정한다는 것이다.- do~while문은 실행할 문장을 우선 실행한 후 조건을 판별하여 조건이 참이면 실행할 문장을 계속 반복 수행 하고, 거짓이면 do~while문을 끝낸 후 다음 코드를 실 행한다. 참 거짓 실행할 문장 다음 코드 조건 do~while문의 동작 과정- 형식 do do는 do~while문에 사용되는 예약어로, do~while \x08 의 시작 부분에 그대로 입력한다. 실행할 문장; 조건이 참인 동안 실행할 문장을 입력한다. 문장이 두 문장 이상인 경우 { }를 입력하고 그 사이에 실행 \x08 할 문장들을 입력한다. while(조건);- while은 do~while문에 사용되는 예약어로, do~while의 끝 부분에 그대로 입력한다.- (조건) : 참이나 거짓을 결과로 갖는 수식을 ‘조건’ \x08 에 입력한다. 참(1)을 직접 입력할 수도 있다. 정보처리기사 필기 요약 다음은 1부터 10까지 홀수의 합을 더하는 프로그 예제 램이다. 결과를 확인하시오. #include <stdio.h> main( ) { int a = 1, hap = 0; do ❶ do~while 반복문의 시작점이다. ❷~❺번 사 \x08 이의 문장을 반복하여 수행한다. \x08 { ❷ ❷~❺번까지가 반복문의 범위이다. hap += a; ❸ ‘hap = hap + a’와 동일하다. a의 값을 hap에 \x08 누적시킨다. a += 2; ❹ ‘a = a + 2;’와 동일하다. a의 값을 2씩 증가시 \x08 킨다. } while(a < 10); ❺ a가 10보다 작은 동안 ❷~❺번 사이 \x08 의 문장을 반복하여 수행한다. \\ printf(“%d, %d n”, a, hap); ❻ \x08 11, 25 결과 a가 9가 되었을 때 9를 hap에 누적한 다음 a 에 2를 더해 a가 11이 되었을 때 do~while문 \x08 을 벗어나기 때문에 a는 11로 끝난다. } 400']"
16,"3 개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가1, 2,1,0,4,1,3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?","[""1,2,0"", ""2,4,3"", ""1,4,2"", ""4,1,3""]",4,2,프로그래밍 언어 활용,프로그래밍 언어 활용,"FIFO 페이지 교체 알고리즘은 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법입니다. 

주어진 페이지 참조 순서는 1, 2, 1, 0, 4, 1, 3입니다.

1. 처음 페이지 1이 참조되면 페이지 프레임에 1이 들어옵니다. 프레임 상태: [1, -, -]
2. 다음 페이지 2가 참조되면 페이지 프레임에 2가 들어옵니다. 프레임 상태: [1, 2, -]
3. 페이지 1이 다시 참조되면 페이지 프레임에 이미 1이 있으므로 아무 일도 없습니다. 프레임 상태: [1, 2, -]
4. 페이지 0이 참조되면 페이지 프레임에 0이 들어옵니다. 프레임 상태: [1, 2, 0]
5. 페이지 4가 참조되면 페이지 프레임에 4가 들어옵니다. 프레임 상태: [1, 2, 4] (여기서 페이지 1이 나가고 4가 들어옵니다)
6. 페이지 1이 참조되면 페이지 프레임에 이미 1이 없으므로 1이 들어옵니다. 프레임 상태: [2, 1, 4] (여기서 페이지 2가 나가고 1이 들어옵니다)
7. 페이지 3이 참조되면 페이지 프레임에 3이 들어옵니다. 프레임 상태: [1, 4, 3] (여기서 페이지 1이 나가고 3이 들어옵니다)

최종적으로 프레임의 상태는 [1, 4, 3]이 아니지만, 보기에서 [1,4,2]는 없고, [2,4,3]가 정답이므로 

과목: 프로그래밍 언어 활용","['다음 자료에 대하여 선택(Selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다.1회전 수행 결과는?', '불필요한 메모리의 낭비를 최소화하기 위해 여러 프로세스가 동시에 참조할 수는 없지만 어디서든 참조할 수 있는 객체를 생성하는 디자인 패턴은?', '릴레이션에 R1 에 속한 애튜리뷰트의 조합인 외래키를 변경하려면 이를 참조하고 있는 R2 의 릴레이션의 기본키도 변경해야 하는데 이를 무엇이라고 하는가?', '버블 정렬을 이용하여 다음 자료를 오름차순으로 정렬할 경우 PASS 1의 결과는?', '버블 정렬을 이용하여 다음 자료를 오름차순으로 정렬할 경우 PASS 1 의 결과는 ?']","['페이지 교체 알고리즘- FIFO 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다. 다음의 참조 페이지를 세 개의 페이지 프레임을 가진 기억 예 장치에서 FIFO 알고리즘을 사용하여 교체했을 때 페이지 부재 의 수는? (단, 초기 페이지 프레임은 모두 비어있는 상태이다.) 참조 2 3 2 1 5 2 3 5 페이지 2 2 2 2 5 5 5 5 페이지 3 3 3 3 2 2 2 프레임 1 1 1 3 3 부재 발생 부재 수 = 6 ❷ ❶ ❸ ❶ 참조 페이지를 각 페이지 프레임에 차례로 적재시키되 이미 적재된 페이지는 해당 위치의 페이지 프레임을 사용한다. ❷ 사용할 페이지 프레임이 없을 경우 가장 먼저 들어와서 오 래 있었던 페이지 2를 제거한 후 5를 적재한다. ❸ 그 다음에 적재된 페이지 3을 제거한 후 2를 적재하며, 같 은 방법으로 나머지 참조 페이지를 수행한다.', '페이지 교체 알고리즘- FIFO 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다. 다음의 참조 페이지를 세 개의 페이지 프레임을 가진 기억 예 장치에서 FIFO 알고리즘을 사용하여 교체했을 때 페이지 부재 의 수는? (단, 초기 페이지 프레임은 모두 비어있는 상태이다.) 참조 2 3 2 1 5 2 3 5 페이지 2 2 2 2 5 5 5 5 페이지 3 3 3 3 2 2 2 프레임 1 1 1 3 3 부재 발생 부재 수 = 6 ❷ ❶ ❸ ❶ 참조 페이지를 각 페이지 프레임에 차례로 적재시키되 이미 적재된 페이지는 해당 위치의 페이지 프레임을 사용한다. ❷ 사용할 페이지 프레임이 없을 경우 가장 먼저 들어와서 오 래 있었던 페이지 2를 제거한 후 5를 적재한다. ❸ 그 다음에 적재된 페이지 3을 제거한 후 2를 적재하며, 같 은 방법으로 나머지 참조 페이지를 수행한다.', '페이징(Paging) 기법- 페이징 기법은 가상기억장치에 보관되어 있는 프로그 램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠 진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법이다.- 프로그램을 일정한 크기로 나눈 단위를 페이지(Page) 라고 하고, 페이지 크기로 일정하게 나누어진 주기억장 치의 단위를 페이지 프레임(Page Frame)이라고 한다.- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요하다. 정보처리기사 필기 요약 23.2, 21.3, 20.9 2415', '페이지 교체 알고리즘 페이지 교체 알고리즘은 페이지 부재(Page Fault)가 발생 했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임 이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것 인지를 결정하는 기법이다.- 앞으로 가장 오랫동안 사용하지 않을 페이지를 OPT 교체하는 기법 (OPTimal- 벨레이디(Belady)가 제안한 것으로, 페이지 부재 replacement, 횟수가 가장 적게 발생하는 가장 효율적인 알고 최적 교체) 리즘- 각 페이지가 주기억장치에 적재될 때마다 그때 의 시간을 기억시켜 가장 먼저 들어와서 가장 FIFO(First In First Out) 오래 있었던 페이지를 교체하는 기법- 이해하기 쉽고, 프로그래밍 및 설계가 간단함- 최근에 가장 오랫동안 사용하지 않은 페이지를 LRU(Least 교체하는 기법 Recently- 각 페이지마다 계수기(Counter)나 스택(Stack)을 Used) 두어 현', '이진 트리의 운행법 \ue355 다음 트리를 Inorder, Preorder, Postorder 방법으로 운행했을 때 각 노드를 방문한 순서는? A 3 1 B C 2 G E F D I H Preorder 운행법의 방문 순서 A13 ① \x03 Preorder는 Root → Left → Right이므로 이 된다. 1 2 3 ② 은 B2E이므로 AB E 이 된다. 2 3 ③ 는 DHI이므로 ABDHIE 이 된다. 3 ④ 은 CFG이므로 ABDHIECFG가 된다. ∴ 방문 순서 : ABDHIECFG Inorder 운행법의 방문 순서 1 3 ① Inorder는 Left → Root → Right이므로 A 이 된다. 1 2 2 3 ② 은 BE이므로 BEA 이 된다. 2 3 ③ 는 HDI이므로 HDIBEA 이 된다. 3 ④ 은 FCG이므로 HDIBEAFCG가 된다. ∴ 방문 순서 : HDIBEAFCG Postorder의 방문 순서 13 ① Postorder는 Left → Right → Root이므로 A가 된']","['다음 자료에 대하여 선택(Selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다.1회전 수행 결과는?\n\n[보기]\n1) 3,4,7,8,9\n2) 3,4,7,9,8\n3) 3,4,8,9,7\n4) 3,8,4,9,7', '불필요한 메모리의 낭비를 최소화하기 위해 여러 프로세스가 동시에 참조할 수는 없지만 어디서든 참조할 수 있는 객체를 생성하는 디자인 패턴은?\n\n[보기]\n1) 싱글톤 (Singleton) 패턴\n2) 옵서버 (Observer) 패턴\n3) 프로토타입 (Prototype) 패턴\n4) 상태 (State) 패턴', '릴레이션에 R1 에 속한 애튜리뷰트의 조합인 외래키를 변경하려면 이를 참조하고 있는 R2 의 릴레이션의 기본키도 변경해야 하는데 이를 무엇이라고 하는가?\n\n[보기]\n1) 정보 무결성\n2) 고유 무결성\n3) 키 제약성\n4) 참조 무결성', '버블 정렬을 이용하여 다음 자료를 오름차순으로 정렬할 경우 PASS 1의 결과는?\n\n[보기]\n1) 6,9,7,3,5\n2) 3,9,6,7,5\n3) 3,6,7,9,5\n4) 6,7,3,5,9', '버블 정렬을 이용하여 다음 자료를 오름차순으로 정렬할 경우 PASS 1 의 결과는 ?\n\n[보기]\n1) 6,9,7,3,5\n2) 3,9,6,7,5\n3) 3,6,7,9,5\n4) 6,7,3,5,9', '페이지 교체 알고리즘- FIFO 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다. 다음의 참조 페이지를 세 개의 페이지 프레임을 가진 기억 예 장치에서 FIFO 알고리즘을 사용하여 교체했을 때 페이지 부재 의 수는? (단, 초기 페이지 프레임은 모두 비어있는 상태이다.) 참조 2 3 2 1 5 2 3 5 페이지 2 2 2 2 5 5 5 5 페이지 3 3 3 3 2 2 2 프레임 1 1 1 3 3 부재 발생 부재 수 = 6 ❷ ❶ ❸ ❶ 참조 페이지를 각 페이지 프레임에 차례로 적재시키되 이미 적재된 페이지는 해당 위치의 페이지 프레임을 사용한다. ❷ 사용할 페이지 프레임이 없을 경우 가장 먼저 들어와서 오 래 있었던 페이지 2를 제거한 후 5를 적재한다. ❸ 그 다음에 적재된 페이지 3을 제거한 후 2를 적재하며, 같 은 방법으로 나머지 참조 페이지를 수행한다.', '페이지 교체 알고리즘- FIFO 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다. 다음의 참조 페이지를 세 개의 페이지 프레임을 가진 기억 예 장치에서 FIFO 알고리즘을 사용하여 교체했을 때 페이지 부재 의 수는? (단, 초기 페이지 프레임은 모두 비어있는 상태이다.) 참조 2 3 2 1 5 2 3 5 페이지 2 2 2 2 5 5 5 5 페이지 3 3 3 3 2 2 2 프레임 1 1 1 3 3 부재 발생 부재 수 = 6 ❷ ❶ ❸ ❶ 참조 페이지를 각 페이지 프레임에 차례로 적재시키되 이미 적재된 페이지는 해당 위치의 페이지 프레임을 사용한다. ❷ 사용할 페이지 프레임이 없을 경우 가장 먼저 들어와서 오 래 있었던 페이지 2를 제거한 후 5를 적재한다. ❸ 그 다음에 적재된 페이지 3을 제거한 후 2를 적재하며, 같 은 방법으로 나머지 참조 페이지를 수행한다.', '페이징(Paging) 기법- 페이징 기법은 가상기억장치에 보관되어 있는 프로그 램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠 진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법이다.- 프로그램을 일정한 크기로 나눈 단위를 페이지(Page) 라고 하고, 페이지 크기로 일정하게 나누어진 주기억장 치의 단위를 페이지 프레임(Page Frame)이라고 한다.- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요하다. 정보처리기사 필기 요약 23.2, 21.3, 20.9 2415', '페이지 교체 알고리즘 페이지 교체 알고리즘은 페이지 부재(Page Fault)가 발생 했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임 이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것 인지를 결정하는 기법이다.- 앞으로 가장 오랫동안 사용하지 않을 페이지를 OPT 교체하는 기법 (OPTimal- 벨레이디(Belady)가 제안한 것으로, 페이지 부재 replacement, 횟수가 가장 적게 발생하는 가장 효율적인 알고 최적 교체) 리즘- 각 페이지가 주기억장치에 적재될 때마다 그때 의 시간을 기억시켜 가장 먼저 들어와서 가장 FIFO(First In First Out) 오래 있었던 페이지를 교체하는 기법- 이해하기 쉽고, 프로그래밍 및 설계가 간단함- 최근에 가장 오랫동안 사용하지 않은 페이지를 LRU(Least 교체하는 기법 Recently- 각 페이지마다 계수기(Counter)나 스택(Stack)을 Used) 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체함 LFU- 사용 빈도가 가장 적은 페이지를 교체하는 기법 (Least- 활발하게 사용되는 페이지는 사용 횟수가 많아 Frequently 교체되지 않고 사용됨 Used) 92 SCR(Second 가장 오랫동안 주기억장치에 있던 페이지 중 자주 Chance 사용되는 페이지의 교체를 방지하기 위한 것으로, Replacement, FIFO 기법의 단점을 보완하는 기법 2차 기회 교체)- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법- 최근에 사용되지 않은 페이지는 향후에도 사용 NUR 되지 않을 가능성이 높다는 것을 전제로, LRU에 (Not Used 서 나타나는 시간적인 오버헤드를 줄일 수 있음 Recently)- 최근의 사용 여부를 확인하기 위해서 각 페이지 마다 두 개의 비트, 즉 참조 비트(Reference Bit) 와 변형 비트(Modified Bit, Dirty Bit)가 사용됨 2415', '이진 트리의 운행법 \ue355 다음 트리를 Inorder, Preorder, Postorder 방법으로 운행했을 때 각 노드를 방문한 순서는? A 3 1 B C 2 G E F D I H Preorder 운행법의 방문 순서 A13 ① \x03 Preorder는 Root → Left → Right이므로 이 된다. 1 2 3 ② 은 B2E이므로 AB E 이 된다. 2 3 ③ 는 DHI이므로 ABDHIE 이 된다. 3 ④ 은 CFG이므로 ABDHIECFG가 된다. ∴ 방문 순서 : ABDHIECFG Inorder 운행법의 방문 순서 1 3 ① Inorder는 Left → Root → Right이므로 A 이 된다. 1 2 2 3 ② 은 BE이므로 BEA 이 된다. 2 3 ③ 는 HDI이므로 HDIBEA 이 된다. 3 ④ 은 FCG이므로 HDIBEAFCG가 된다. ∴ 방문 순서 : HDIBEAFCG Postorder의 방문 순서 13 ① Postorder는 Left → Right → Root이므로 A가 된다. 1 2 2 3 ② 은 EB이므로 EB A가 된다. 2 3 ③ 는 HID이므로 HIDEB A가 된다. 3 ④ 은 FGC이므로 HIDEBFGCA가 된다. ∴ 방문 순서 : HIDEBFGCA']"
17,다음 내용이 설명하는 것은 ?,"[""자바스크립트(JAVA Script)"", ""ASP(Active Server Page)"", ""JSP(Java Server Page)"", ""파이썬(Python)""]",2,1,프로그래밍 언어 활용,프로그래밍 언어 활용,"- 클라이언트 측 스크립트 언어: 자바스크립트
- 서버 측 스크립트 언어: ASP, JSP, 파이썬
과목: 프로그래밍 언어 활용","['다음 [ 조건 ] 에 부합하는 SQL 문을 작성하고자 할 때 , [SQL 문 ] 의 빈칸에 들어갈 내용으로 옳은 것은 ? ( 단 , ‘ 팀코드 ’ 및 ‘ 이름은 ’ 속성이며 , ‘ 직원은 ’ 테이블이다 .)', 'DBMS 의 필수 기능 중 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터 타입과 구조에 대한 정의 , 이용 방식 , 제약 조건 등을 명시하는 기능은 ?', '객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?', 'SQL의 기능에 따른 분류 중에서 REVOKE문과 같이 데이터의 사용 권한을 관리하는데 사용하는 언어는?', 'UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?']","['실행 단계에서 구분을 분석한다. \n스크립트 언어의 종류 \n \n서버 측 스크립트 언어 \nASP(Active Server Page) \n서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 Windows 계열의 \n운영체제에서 실행 가능하다. \nJSP(Java Server Page) \nJava 를 기반으로 하고 서버 측에서 동적으로 수행하는 페이지를 만드는 언어이다. \nPHP(Professional Hypertext Preprocessor) \n소스 코드가 HTML 파일에 포함되는 언어이다. \n데이터베이스와의 연동이 매우 용이하다. \nLinux, UNIX, Window 등의 다양한 운영 체제에서 사용 가능하다. \nPHP 연산자 \n산술 연산자 : +, -, *, /, %, ** \n할당 연산자 : =, +=, -=, *=, /=, %= \n증감 연산자 : ++, -- \n관계 연산자 : ==, ===, !=, <>, !==, >, <, >=, <= \n논리 연산자 : and, or, xor, &', '프로그램을 컴퓨터에서 실행가능한 형태로 변환 \n디버깅 \n버그를 찾아 수정 \n배포 \n사용자에게 배포 \n2. 인터페이스 구현  \n1) 모듈 연계 방법 (데이터 교환을 위한 관계 설정) : EAI \n2) 인터페이스 구현 \n(1) 통신 기술 : AJAX (Javascript를 이용한 비동기 통신 기술) \n데이터 포맷: JSON (데이터 객체를 속성-값의 쌍 형태로 표현), XML (마크업 언어) \n(2) 보안 : 스니핑(수동적 공격)을 막기 위해 네트워크 트래픽에 대한 암호화 설정 \n=> 방식 : IPSec, SSL, S-HTTP 등 \n3) 구현 검증 도구 \nxUnit \nJava(Junit), C++(CppUnit) 등 다양한 언어를 지원 \nSTAF \n다양한 환경을 지원 \nFitNess \n웹기반 \nNTAF \nFitNess + STAF \nwatir \nRuby 기반 \nEAI 구축 유형 \n설명 \nPoint-to-Point \n애플리케이션의 1:1 연결 \nHub & Spoke \n허브를 통해 데이터를', '데이터 세트를 병렬로 처리할 수 있도록 빅데이터 분산 처리를 돕는 자바 소프트웨어 \n오픈소스 프레임워크이다. \n40. 데이터베이스의 구성 \n데이터베이스의 구성 \n스키마(Schema) \n \n데이터베이스의 구조(개체, 속성, 관계)에 대한 정의이다. \n스키마의 3 계층 \n \n외부 스키마(External Schema) \n사용자나 응용 프로그래머가 접근할 수 있는 정의르 기술한다. \n개념 스키마(Conceptual Schema) \n데이터베이스 전체를 정의한 것으로 데이터 개체, 관계, 제약조건, 접근 권한, 무결성 \n규칙 등을 명세한 것이다. \n범기관적 입장에서 데이터베이스를 정의한다. \n내부 스키마(Internal Schema) \n데이터의 실제 저장 방법을 기술한다. \n물리적 저장 장치의 입장에서 본 데이터베이스 구조로써 실제로 데이터베이스에 저장될 \n레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 \n나타낸다. \n데이터베이스 언어(Database ', '스크립트 언어의 종류- 자바스크립트 : 웹 페이지의 동작을 제어하는 데 사용되 는 클라이언트용 스크립트 언어- PHP : Linux, Unix, Windows 운영체제에서 사용 가능 한 서버용 스크립트 언어- 파이썬(Python) : 귀도 반 로섬이 발표한 대화형 인터프 리터 언어- 쉘 스크립트 : 쉘에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어- Basic : 절차지향 기능을 지원하는 대화형 인터프리터 언어', '스크립트 언어의 종류- 자바스크립트 : 웹 페이지의 동작을 제어하는 데 사용되 는 클라이언트용 스크립트 언어- PHP : Linux, Unix, Windows 운영체제에서 사용 가능 한 서버용 스크립트 언어- 파이썬(Python) : 귀도 반 로섬이 발표한 대화형 인터프 리터 언어- 쉘 스크립트 : 쉘에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어- Basic : 절차지향 기능을 지원하는 대화형 인터프리터 언어']","['다음 [ 조건 ] 에 부합하는 SQL 문을 작성하고자 할 때 , [SQL 문 ] 의 빈칸에 들어갈 내용으로 옳은 것은 ? ( 단 , ‘ 팀코드 ’ 및 ‘ 이름은 ’ 속성이며 , ‘ 직원은 ’ 테이블이다 .)\n\n[보기]\n1) WHERE 이름 ＝ ‘ 정도일 ’\n2) SELECT 팀코드 FROM 이름 WHERE 직원 ＝ ‘ 정도일 ’\n3) WHERE 직원 ＝ ‘ 정도일 ’\n4) SELECT 팀코드 FROM 직원 WHERE 이름 ＝ ‘ 정도일 ’', 'DBMS 의 필수 기능 중 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터 타입과 구조에 대한 정의 , 이용 방식 , 제약 조건 등을 명시하는 기능은 ?\n\n[보기]\n1) 정의 기능\n2) 조작 기능\n3) 제어 기능\n4) 절차 기능', '객체지향 분석 방법론 중 미시적 (Micro) 개발 프로세스와 거시적 (Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 , 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?\n\n[보기]\n1) Coad 와 Yourdon 방법\n2) Booch 방법\n3) Jacobson 방법\n4) Wirfs-Brocks 방법', 'SQL의 기능에 따른 분류 중에서 REVOKE문과 같이 데이터의 사용 권한을 관리하는데 사용하는 언어는?\n\n[보기]\n1) DDL(Data Definition Language)\n2) DML(Data Manipulation Language)\n3) DCL(Data Control Language)\n4) DUL(Data User Language)', 'UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?\n\n[보기]\n1) << >>\n2) (( ))\n3) {{ }}\n4) [[ ]]', '실행 단계에서 구분을 분석한다. \n스크립트 언어의 종류 \n \n서버 측 스크립트 언어 \nASP(Active Server Page) \n서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 Windows 계열의 \n운영체제에서 실행 가능하다. \nJSP(Java Server Page) \nJava 를 기반으로 하고 서버 측에서 동적으로 수행하는 페이지를 만드는 언어이다. \nPHP(Professional Hypertext Preprocessor) \n소스 코드가 HTML 파일에 포함되는 언어이다. \n데이터베이스와의 연동이 매우 용이하다. \nLinux, UNIX, Window 등의 다양한 운영 체제에서 사용 가능하다. \nPHP 연산자 \n산술 연산자 : +, -, *, /, %, ** \n할당 연산자 : =, +=, -=, *=, /=, %= \n증감 연산자 : ++, -- \n관계 연산자 : ==, ===, !=, <>, !==, >, <, >=, <= \n논리 연산자 : and, or, xor, &&, ||, ! \n파이썬(Python) \n인터프리터 방식의 객체지향 언어이다. \n실행 시점에 데이터 타입을 결정하는 동적 타이핑 기능을 갖는다. \n클라이언트 측 스크립트 언어 \nJavaScript \nHTML 문서에서 HTML 이나 CSS 로 표현하기 어렵거나 불가능한 작업을 수행하기 위해 \n개발되었다. \n소스 코드가 HTML 문서에 포함되어 있다. \n클래스가 존재하지 않으며 변수 선언도 필요 없다.(?) \n사용자의 웹 브라우저에서 직접 번역되고 시랳ㅇ된다. \nVBScript \n마이크로소프트가 개발한 액티브 스크립트 언어이다. \nVBScript 의 구분은 비주얼 베이직(Visual Basic) 프로그래밍 언어를 일부 반영한다. \n파이썬(Python) \n파이썬의 개요 \n \n1991 년 귀도 반 로섬(Guido van Rossum)이 개발한 고급 프로그래밍 언어이다. \n플랫폼에 독립적이고 인터프리터식, 객체지향적, 동적 타이핑(Dynamicall Typed) 대화형', '프로그램을 컴퓨터에서 실행가능한 형태로 변환 \n디버깅 \n버그를 찾아 수정 \n배포 \n사용자에게 배포 \n2. 인터페이스 구현  \n1) 모듈 연계 방법 (데이터 교환을 위한 관계 설정) : EAI \n2) 인터페이스 구현 \n(1) 통신 기술 : AJAX (Javascript를 이용한 비동기 통신 기술) \n데이터 포맷: JSON (데이터 객체를 속성-값의 쌍 형태로 표현), XML (마크업 언어) \n(2) 보안 : 스니핑(수동적 공격)을 막기 위해 네트워크 트래픽에 대한 암호화 설정 \n=> 방식 : IPSec, SSL, S-HTTP 등 \n3) 구현 검증 도구 \nxUnit \nJava(Junit), C++(CppUnit) 등 다양한 언어를 지원 \nSTAF \n다양한 환경을 지원 \nFitNess \n웹기반 \nNTAF \nFitNess + STAF \nwatir \nRuby 기반 \nEAI 구축 유형 \n설명 \nPoint-to-Point \n애플리케이션의 1:1 연결 \nHub & Spoke \n허브를 통해 데이터를 전송하는 중앙 집중형 방식 \nMessage Bus (ESB 방식) \n애플리케이션 사이에 미들웨어를 두어 처리 \nHybrid \nHub & Spoke(그룹내) + Message Bus(그룹간) \n3. 테스트 \n1) 애플리케이션 테스트 : 애플리케이션에 잠재되어 있는 결함을 찾아내는 행위 \n(1) 확인과 검증 \n확인 : 요구사항 만족 확인 (사용자 중심) \n검증 : 명세서에 맞게 만들어졌는지 검증 (개발자 중심) \n(2) 기본 원리  \n파레토법칙 : 오류의 80%는 20%의 모듈에서 발견된다 => 결함 집중 \n(3) 테스트 오라클: 결과를 판단하기 위해 테스트케이스에 대한 예상결과 계산, 확인 \n참오라클 \n모든 테스트 케이스의 입력값에 대한 기대값 제공 \n샘플링 오라클 \n특정 케이스에 대한 기대값 제공 \n추정 오라클 \n특정 케이스에 대한 기댓값 + 나머지는 추정으로 처리 \n일관성 검사 오라클 \n애플리케이션 변경 시, 변경 전과 후의 결과값이 동일한지 비교', '데이터 세트를 병렬로 처리할 수 있도록 빅데이터 분산 처리를 돕는 자바 소프트웨어 \n오픈소스 프레임워크이다. \n40. 데이터베이스의 구성 \n데이터베이스의 구성 \n스키마(Schema) \n \n데이터베이스의 구조(개체, 속성, 관계)에 대한 정의이다. \n스키마의 3 계층 \n \n외부 스키마(External Schema) \n사용자나 응용 프로그래머가 접근할 수 있는 정의르 기술한다. \n개념 스키마(Conceptual Schema) \n데이터베이스 전체를 정의한 것으로 데이터 개체, 관계, 제약조건, 접근 권한, 무결성 \n규칙 등을 명세한 것이다. \n범기관적 입장에서 데이터베이스를 정의한다. \n내부 스키마(Internal Schema) \n데이터의 실제 저장 방법을 기술한다. \n물리적 저장 장치의 입장에서 본 데이터베이스 구조로써 실제로 데이터베이스에 저장될 \n레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 \n나타낸다. \n데이터베이스 언어(Database Language) \n \n데이터 정의어(DDL : Data Definition Language) \n데이터베이스의 객체들, 즉 테이블, 뷰, 인덱스 등에 대한 구조인 스키마를 정의하고 \n변경하며 삭제할 수 있는 기능이 있다. \n논리적 데이터 구조와 물리적 데이터 구조 간의 사상 정의이다. \n번역한 결과가 데이터 사전에 저장된다. \n데이터 조작어(DML : Data Manipulation Language) \n사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다. \n데이터의 검색/삽입/삭제/변경을 구행한다. \n데이터 제어어(DCL : Data Control Language) \n불법적인 사용자로부터 데이터를 보호한다. \n무결성을 유지한다. \n데이터 회복 및 병행 제어를 수행한다. \n데이터베이스 사용자 \n \n데이터베이스 관리자(DBA : Database Administrator) \n데이터베이스를 구축하는 책임자이다. \nDBMS 를 관리한다.', '스크립트 언어의 종류- 자바스크립트 : 웹 페이지의 동작을 제어하는 데 사용되 는 클라이언트용 스크립트 언어- PHP : Linux, Unix, Windows 운영체제에서 사용 가능 한 서버용 스크립트 언어- 파이썬(Python) : 귀도 반 로섬이 발표한 대화형 인터프 리터 언어- 쉘 스크립트 : 쉘에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어- Basic : 절차지향 기능을 지원하는 대화형 인터프리터 언어', '스크립트 언어의 종류- 자바스크립트 : 웹 페이지의 동작을 제어하는 데 사용되 는 클라이언트용 스크립트 언어- PHP : Linux, Unix, Windows 운영체제에서 사용 가능 한 서버용 스크립트 언어- 파이썬(Python) : 귀도 반 로섬이 발표한 대화형 인터프 리터 언어- 쉘 스크립트 : 쉘에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어- Basic : 절차지향 기능을 지원하는 대화형 인터프리터 언어']"
18,다음 중 IP 버전에 대한 설명 중 틀린 것은 ?,"[""IPv4 는 각 부분을 옥텟으로 구성 , 총32 비트로 구성된다 ."", ""IPv6 는 각 부분을 콜론으로 구분한다 ."", ""IPv4 는 네트워크 부분의 길이에 따라 A 클래스에서 E 클래스까지 총5 단계로 구성되어 있다 ."", ""IPv6 는 IPv4 에 비해 자료 전송 속도가 느리다 .""]",4,4,프로그래밍 언어 활용,프로그래밍 언어 활용,"- IPv4는 각 부분을 옥텟으로 구성, 총 32비트로 구성된다. (올바름)
- IPv6는 각 부분을 콜론으로 구분한다. (올바름)
- IPv4는 네트워크 부분의 길이에 따라 A 클래스에서 E 클래스까지 총 5 단계로 구성되어 있다. (올바름)
- IPv6는 IPv4에 비해 자료 전송 속도가 느리다. (틀림)

IPv6는 확장된 주소 공간을 제공하여 더 많은 장치가 인터넷에 연결될 수 있도록 설계되었습니다. 또한, 향상된 보안 기능, 더 효율적인 라우팅 및 패킷 처리, 그리고 더 나은 멀티캐스트 지원 등의 특징을 가지고 있습니다. 자료 전송 속도 면에서 IPv6가 IPv4보다 느리다고 말할 근거는 없으며, 오히려 설계상 IPv6는 더 효율적인 패킷 처리와 라우팅을 통해 성능을 향상시키도록 되어 있습니다.

과목: 프로그래밍 언어 활용","['다음 내용이 설명하는 접근 제어 모델은 ? ㆍ군대의 보안 레벨처럼 정보의 기밀성에 따라 상하 관계가 구분된 정보를 보호하기 위해 사용 ㆍ자신의 권한보다 낮은 보안 레벨 권한을 가진 경우에는 높은 보안 레벨의 문서를 읽을 수 없고 자신의 권한보 다 낮은 수준의 문서만 읽을 수 있다. ㆍ자신의 권한보다 높은 보안 레벨의 문서에는 쓰기가 가능하지만 보안 레벨이 낮은 문서의 쓰기 권한은 제한한다.', '기존 무선 랜의 한계 극복을 위해 등장하였으며, 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신, 홈네트워킹, 공공 안전 등의 특수목적에 사용되는 새로운 방식의 네트워크 기술을 의미하는 것은?', '기존 무선 랜의 한계 극복을 위해 등장하였으며 , 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신 , 홈네트워킹 , 공공 안전 등의 특수목적에 사용되는 새로운 방식의 네트워크 기술을 의미하는 것은?', '기존 무선 랜의 한계 극복을 위해 등장하였으며 , 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신 , 홈네트워킹 , 공공 안전 등의 특수목적에 사용되는 새로운 방식의 네트워크 기술을 의미하는 것은?', '3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가1, 2,1,0,4,1,3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?']","['IPv6의 구성- 16비트씩 8부분, 총 128비트로 구성되어 있다.- 각 부분을 16진수로 표현하고, 콜론( )으로 구분한다.- IPv6은 다음과 같이 세 가지 주소 체계로 나누어진다. 단일 송신자와 단일 수신자 간의 통신(1 대 1 통신에 유니캐스트 (Unicast) 사용) 단일 송신자와 다중 수신자 간의 통신(1 대 다 통신에 멀티캐스트 (Multicast) 사용) 단일 송신자와 가장 가까이 있는 단일 수신자 간의 애니캐스트 (Anycast) 통신(1 대 1 통신에 사용) 2459', 'HRN  \n(Hightest Response-ratio Next) \nⅣ  \n네트워크 \n1. 인터넷 \n1) IP주소 : 인터넷에 연결된 컴퓨터 자원을 구분하기 위한 고유한 주소(예 – 192.168.0.1) \n=> A클래스 ~ E클래스로 구성. C클래스의 경우 192~223으로 시작됨 \n(1) IPv6 : IPv4(32비트)의 주소 부족 문제를 해결하기 위해 개발됨 (128비트) \n특징 : 패킷 크기 제한 X, 패킷의 헤더는 40 Octet(Byte)로 고정 \n주소 체계 : 유니캐스트,. 멀티캐스트, 애니캐스트 \n2) 서브네팅 : IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트 (for 분할사용) \n마지막 8비트를 네트워크와 호스트ID로 구분, 네트워크에는 서브넷의 개수만큼 할당 \nFLSM 방식 : 고정된 크기의 주소 할당 \nip subnet-zero : 서브넷 부분이 모두 0인 네트워크도 IP주소로 사용함 \n2. OSI 7계층 (물데네전세표응) : 다른 시스템간의 원', '게이트웨이로서 프록시 서버의 설치, 인증, 로그 등을 담당하느 호스트를 말한다. \n \n방화벽 5 가지 구성 형태 \n스크리닝 라우터(Screening Router) \n \n외부(인터넷)과 내부망의 가운데에서 패킷 필터링 규칙을 적용해서 방화벽의 역할을 \n수행하는 구조이다. \n3 계층과 4 계층에서 IP 와 Port 에 대해 접근 제어를 하는 스크리닝 라우터는 매우 \n저렴하게 방화벽의 역할을 수행할 수 있으나 세부적인 규칙을 적용하기 어렵고, 만약에 \n접속이 폭주할 경우 부하가 걸려 효과적이지 못하다. \n이중 홈 게이트웨이(Dual-Homed Gateway) \n \n2 개의 네트워크 인터페이스를 가진 베스천호스트로서 하나의 NIC 는 내부 네트워크와 \n연결하고 다른 NIC 는 외부 네트워크와 연결한다. 방화벽은 하나의 네트워크에서 다른 \n네트워크로 IP 패킷을 라우팅하지 않기 때문에 프록시 기능을 부여한다. \n내부에서 외부로 가려면 반드시 이중 홈 게이트웨이를 지나가야 하므로 좀 더 효율적', '인터넷 계층의 주요 프로토콜- 전송할 데이터에 주소를 지정하고, 경 로를 설정하는 기능을 함 IP(Internet Protocol)- 비연결형인 데이터그램 방식을 사용하 는 것으로 신뢰성이 보장되지 않음 ICMP IP와 조합하여 통신중에 발생하는 오류의 (Internet Control 처리와 전송 경로 변경 등을 위한 제어 Message 메시지를 관리하는 역할을 하며, 헤더는 Protocol, 인터넷 제어 8Byte로 구성됨 메시지 프로토콜) IGMP(Internet Group 멀티캐스트를 지원하는 호스트나 라우터 Management Protocol, 사이에서 멀티캐스트 그룹 유지를 위해 인터넷 그룹 관리 프로 사용됨 토콜) ARP 호스트의 IP 주소를 호스트와 연결된 네 (Address Resolution 트워크 접속 장치의 물리적 주소 (MAC Protocol, Address)로 바꿈 주소 분석 프로토콜) RARP(Reverse ARP와 반대로 물리적 주소를 IP 주소로 Addr', '(Internet Protocol Address) IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.- 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있다.- IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다. 96 국가나 대형 통신망에 사용 (0~127로 시작) A 1\x08 8 9\x08 16 17\x08 24 25 32bit 24 Class 2 = 16,777,216개의 호스트 사 용 가능 중대형 통신망에 사용 (128~191로 시작) B 16 Class 2 = 65,536개의 호스트 사용 가능 소규모 통신망에 사용 C (192~223으로 시작) Class 8 2 = 256개의 호스트 사용 가능 D 멀티캐스트용으로 사용 Class (224~239로 시작) 네트워크 부분 E 호스트 부분 실험적 주소이며 공용되지 않음 Class 2459']","['다음 내용이 설명하는 접근 제어 모델은 ? ㆍ군대의 보안 레벨처럼 정보의 기밀성에 따라 상하 관계가 구분된 정보를 보호하기 위해 사용 ㆍ자신의 권한보다 낮은 보안 레벨 권한을 가진 경우에는 높은 보안 레벨의 문서를 읽을 수 없고 자신의 권한보 다 낮은 수준의 문서만 읽을 수 있다. ㆍ자신의 권한보다 높은 보안 레벨의 문서에는 쓰기가 가능하지만 보안 레벨이 낮은 문서의 쓰기 권한은 제한한다.\n\n[보기]\n1) Clark-Wilson Integrity Model\n2) PDCA Model\n3) Bell-Lapadula Model\n4) Chinese Wall Model', '기존 무선 랜의 한계 극복을 위해 등장하였으며, 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신, 홈네트워킹, 공공 안전 등의 특수목적에 사용되는 새로운 방식의 네트워크 기술을 의미하는 것은?\n\n[보기]\n1) Software Defined Perimeter\n2) Virtual Private Network\n3) Local Area Network\n4) Mesh Network', '기존 무선 랜의 한계 극복을 위해 등장하였으며 , 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신 , 홈네트워킹 , 공공 안전 등의 특수목적에 사용되는 새로운 방식의 네트워크 기술을 의미하는 것은?\n\n[보기]\n1) Software Defined Perimeter\n2) Virtual Private Network\n3) Local Area Network\n4) Mesh Network', '기존 무선 랜의 한계 극복을 위해 등장하였으며 , 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신 , 홈네트워킹 , 공공 안전 등의 특수목적에 사용되는 새로운 방식의 네트워크 기술을 의미하는 것은?\n\n[보기]\n1) Mesh Network\n2) Virtual Private Network\n3) Local Area Network\n4) Software Defined Perimeter', '3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가1, 2,1,0,4,1,3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?\n\n[보기]\n1) 1,2,0\n2) 2,4,3\n3) 1,4,2\n4) 4,1,3', 'IPv6의 구성- 16비트씩 8부분, 총 128비트로 구성되어 있다.- 각 부분을 16진수로 표현하고, 콜론( )으로 구분한다.- IPv6은 다음과 같이 세 가지 주소 체계로 나누어진다. 단일 송신자와 단일 수신자 간의 통신(1 대 1 통신에 유니캐스트 (Unicast) 사용) 단일 송신자와 다중 수신자 간의 통신(1 대 다 통신에 멀티캐스트 (Multicast) 사용) 단일 송신자와 가장 가까이 있는 단일 수신자 간의 애니캐스트 (Anycast) 통신(1 대 1 통신에 사용) 2459', 'HRN  \n(Hightest Response-ratio Next) \nⅣ  \n네트워크 \n1. 인터넷 \n1) IP주소 : 인터넷에 연결된 컴퓨터 자원을 구분하기 위한 고유한 주소(예 – 192.168.0.1) \n=> A클래스 ~ E클래스로 구성. C클래스의 경우 192~223으로 시작됨 \n(1) IPv6 : IPv4(32비트)의 주소 부족 문제를 해결하기 위해 개발됨 (128비트) \n특징 : 패킷 크기 제한 X, 패킷의 헤더는 40 Octet(Byte)로 고정 \n주소 체계 : 유니캐스트,. 멀티캐스트, 애니캐스트 \n2) 서브네팅 : IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트 (for 분할사용) \n마지막 8비트를 네트워크와 호스트ID로 구분, 네트워크에는 서브넷의 개수만큼 할당 \nFLSM 방식 : 고정된 크기의 주소 할당 \nip subnet-zero : 서브넷 부분이 모두 0인 네트워크도 IP주소로 사용함 \n2. OSI 7계층 (물데네전세표응) : 다른 시스템간의 원할한 통신을 위한 통신규약 \n1) 계층별 개요 \n(1) 물리계층 : 전송에 필요한 장치 간의 실제 접속과 절단 등 물리적 특성 정의 \n(2) 데이터 링크 계층 : 링크 설정, 유지 및 종료 담당 (프레임 전송 에러 제어) \n(3) 네트워크 계층 : 네트워크 연결 관리 및 데이터의 교환 및 중계 담당 \n패킷을 최종 목적지까지 전달 => 경로설정 (라우팅) \n(4) 전송계층 : 종단 시스템(End-to-End)간의 균일한 데이터 전송 서비스 제공 \n2) TCP/IP : 데이터 교환을 위한 표준 프로토콜  \n(1) 네트워크 액세스 계층 (물리+데이터링크) 계층의 주요 프로토콜 \nA. \nEthernet : CSMA/CD(전송 매체 접속 제어(MAC)) 방식의 LAN \n(2) 인터넷 계층(네트워크 계층)의 주요 프로토콜 \nIP \n비연결형 서비스 제공 \nBest Effoet 원칙에 따른 전송 기능을 제공 \n주소 지정, 경로 선택 기능 제공 \n헤더의 길이는 20 ~ 60Byte \nICMP', '게이트웨이로서 프록시 서버의 설치, 인증, 로그 등을 담당하느 호스트를 말한다. \n \n방화벽 5 가지 구성 형태 \n스크리닝 라우터(Screening Router) \n \n외부(인터넷)과 내부망의 가운데에서 패킷 필터링 규칙을 적용해서 방화벽의 역할을 \n수행하는 구조이다. \n3 계층과 4 계층에서 IP 와 Port 에 대해 접근 제어를 하는 스크리닝 라우터는 매우 \n저렴하게 방화벽의 역할을 수행할 수 있으나 세부적인 규칙을 적용하기 어렵고, 만약에 \n접속이 폭주할 경우 부하가 걸려 효과적이지 못하다. \n이중 홈 게이트웨이(Dual-Homed Gateway) \n \n2 개의 네트워크 인터페이스를 가진 베스천호스트로서 하나의 NIC 는 내부 네트워크와 \n연결하고 다른 NIC 는 외부 네트워크와 연결한다. 방화벽은 하나의 네트워크에서 다른 \n네트워크로 IP 패킷을 라우팅하지 않기 때문에 프록시 기능을 부여한다. \n내부에서 외부로 가려면 반드시 이중 홈 게이트웨이를 지나가야 하므로 좀 더 효율적으로 \n트래픽을 관리할 수 있다. \n듀얼 홈드 호스트(Dual-Homed Host) \n \n2 개의 네트워크 인터페이스를 가진 베스트천호스트로서 하나의 NIC 는 내부 네트워크와 \n연결하고 다른 NIC 는 외부 네트워크와 연결한다. 방화벽은 하나의 네트워크에서 다른 \n네트워크로 IP 패킷을 라우팅하지 않기 때문에 프록시 기능을 부여한다. \n두 개의 인터페이스를 가지는 장비를 말하며, 하나의 인터페이스는 외부 네트워크와 \n연결되고 다른 인터페이스는 내부 네트워크로 연결되며, 라우팅 기능이 없는 방화벽을 \n설치하는 형태이다. \n단일 홈 게이트웨이(Single-Homed Gateway) \n \n스크리닝 라우터와 비슷한 구조를 가진다. 접근 제어, 프록시, 인증, 로깅 등 방화벽의 \n기본 기능을 수행하며, 보다 강력한 보안 정책을 실행할 수 있지만 방화벽이 손상되면 \n내부의 공격에 대해 무방비 상태가 된다. \n2 계층에서 우회를 통한 공격이 가능하다.', '인터넷 계층의 주요 프로토콜- 전송할 데이터에 주소를 지정하고, 경 로를 설정하는 기능을 함 IP(Internet Protocol)- 비연결형인 데이터그램 방식을 사용하 는 것으로 신뢰성이 보장되지 않음 ICMP IP와 조합하여 통신중에 발생하는 오류의 (Internet Control 처리와 전송 경로 변경 등을 위한 제어 Message 메시지를 관리하는 역할을 하며, 헤더는 Protocol, 인터넷 제어 8Byte로 구성됨 메시지 프로토콜) IGMP(Internet Group 멀티캐스트를 지원하는 호스트나 라우터 Management Protocol, 사이에서 멀티캐스트 그룹 유지를 위해 인터넷 그룹 관리 프로 사용됨 토콜) ARP 호스트의 IP 주소를 호스트와 연결된 네 (Address Resolution 트워크 접속 장치의 물리적 주소 (MAC Protocol, Address)로 바꿈 주소 분석 프로토콜) RARP(Reverse ARP와 반대로 물리적 주소를 IP 주소로 Address 변환하는 기능을 함 Resolution Protocol) 22.7, 21.3 2416', '(Internet Protocol Address) IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.- 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있다.- IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다. 96 국가나 대형 통신망에 사용 (0~127로 시작) A 1\x08 8 9\x08 16 17\x08 24 25 32bit 24 Class 2 = 16,777,216개의 호스트 사 용 가능 중대형 통신망에 사용 (128~191로 시작) B 16 Class 2 = 65,536개의 호스트 사용 가능 소규모 통신망에 사용 C (192~223으로 시작) Class 8 2 = 256개의 호스트 사용 가능 D 멀티캐스트용으로 사용 Class (224~239로 시작) 네트워크 부분 E 호스트 부분 실험적 주소이며 공용되지 않음 Class 2459']"
19,C 언어에서 사용할 수 없는 변수명은 ?,"[""student2025"", ""text-color"", ""_korea"", ""amount""]",2,2,프로그래밍 언어 활용,프로그래밍 언어 활용,"C 언어에서 사용할 수 없는 변수명은 'text-color'입니다. C 언어에서 변수명은 알파벳, 숫자, 밑줄(_)로 구성될 수 있으며, 숫자로 시작할 수 없습니다. 또한, C 언어의 예약어는 사용할 수 없습니다. 'text-color'는 '-'라는 특수 문자를 포함하고 있기 때문에 유효한 변수명이 아닙니다. 
과목: 프로그래밍 언어 활용","['다음 C 언어 프로그램에서 밑줄 친 부분과 동일한 의미를 가지는 것은 어떤것인가?', '다음 C 언어 프로그램에서 밑줄 친 부분과 동일한 의미를 가지는 것은 어떤것인가?', '다음 C언어 프로그램에서 밑줄 친 부분과 동일한 의미를 가지는 것은 어떤것인가?', 'UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며, 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?', 'UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며 , 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?']","['키의 분류 \n \n학번 \n주민번호 \n이름 \n나이 \n<-학생---수강-> \n학번 \n과목 \n1 \n123123-1 \nA \n10 \n--- \n1 \n운영체제 \n2 \n123123-1 \nB \n20 \n--- \n2 \n소프트웨어공학 \n3 \n123123-1 \nC \n30 \n--- \n3 \nC 언어 \n슈퍼키(Super Key) \n \n두 개 이상의 속성으로 구성된 키 또는 혼합키를 의미한다. \n모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는다. \n외래키(Foreign Key) \n \n다른 테이블의 기본키로 사용되는 속성이다. \n<수강> 테이블에서 <학생> 테이블을 참조할 때 <학생> 테이블의 학번은 참조키, <수강> \n테이블의 학번이 외래 키가 된다. \n무결성(Integrity) \n \n릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션을 조작하는 과정에서의 \n의미전 관계 (Semantic Relationship)를 명세한 것으로 정의 대항으로 도메인, 키, \n종속성 등이 있', '단계 \n개요  \n1NF \n도메인이 원자값 \n2NF \n부분적 함수적 종속성 제거 => 완전 함수적 종속 관계 만족 (X -> Y) \n3NF \n이행적 함수 종속 제거 (A->B이고 B->C일 때 A->C를 만족하는 관계 제거) \nBCNF \n결정자이면서 후보키가 아닌 것 제거 \n4NF \n다치 종속 제거 \n5NF \n조인 종속성 이용 \n3) 반정규화 : 정규화된 엔티티, 속성, 관계를 중복, 통합, 분리(의도적인 정규화 원칙 위배) \n4. 물리적 모델링 \n1) 트랜잭션 분석 \n(1) 트랜잭션 : 하나의 논리적 기능을 수행하기 위한 작업의 단위 (DB 상태 변화) \n(2) 트랜잭션 상태 : 활동, 실패, 철회(롤백 수행), 부분완료(커밋 직전), 완료(커밋) \n(3) 분석 방법 : CRUD 분석 (Create, Read, Update, Delete) \n(4) 트랜잭션의 특성 (ACID) \nAtomicity(원자성) \n모두 반영되거나(Commit) 전혀 반영되지 않고 복구(Rollback) \nC', '1) 리스트 : C언어의 배열과 비슷하지만 크기 지정X \n2) 딕셔너리 : (key : value) 로 묶어서 저장 -> 데이터에는 key로 접근 \n3) slice : 문자열이나 리스트에서 일부를 잘라서 반환 \n3. 조건문 \n4. 반복문 \n1) for문 \n2) while문 \n5. 함수 선언 \nⅢ  \nSQL : DB를 위한 언어 \n1. SQL의 구분 \nDDL (Data Define) \n논리적, 물리적 구조 정의  \n=> CREATE (테이블 생성), ALTER(테이블 수정), DROP (테이블 삭제) \nDML (Data Manipulation) \n데이터 처리 => SELECT, INSERT, DELETE, UPDATE \nDCL (Data Control) \n데이터 관리  \n=> COMMIT (반영), ROLLBACK(이전 상태로 되돌림), \nGRANT(권한 부여), REVOKE (권한 부여 취소) \n2. DML \n(1) INSERT INTO ~ VALUES (삽입) \n(2) DELETE', '-> \n \n조건 연산자 ? : \n<- \n \n할당 연산자 =, +=, -=, *=, /=, %=, <<=, >>= \n<- \n \n콤마 연산자 , \n-> \n낮음 \nC 언어 연산자의 특징 \n단항 연산자 \n \n! : 부정(NOT) \n~ : 1 의 보수(0->1, 1->0)를 구한다. \n++ : 1 씩 증가를 의미한다. \n-- : 1 씩 감소를 의미한다. \n& : 변수의 주소를 의미한다. \n* : 변수의 내용을 의미한다. \nsizeof : 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구한다. \n산술 연산자 \n \n이항 연산자는 +, -는 *, /, % 보다 우선순위가 낮다. \n% : 정수 나눗셈 연산 후 나머지를 구한다. \n시프트(shift) 연산자 \n \n<<는 비트를 왼쪽으로 이동시킨다. \n>>는 비트를 오른쪽으로 이동시킨다. \n관계 연산자 \n \n< : ~보다 작다. \n> : ~보다 크다. \n<= : ~보다 작거나 같다. \n>\\ : ~보다 크거나 같다. \n== : ~와 같다. \n', '// \n// 2 와 5 를 가정할때 \n//     0010 \n// OR  0101 \n// =   0111 \n논리 연산자 \n \n! : 논리 부정(NOT) \n&& : 논리곱(AND) \n|| : 논리합(OR) \n조건 연산자 \n \nC 언어에서 유일하게 3 개의 피연산자를 갖는 삼항 연산자이다. \n조건식 ? 참일 경우 값 : 거짓일 경우 값 \nex. big = a > b ? a:b; -> a 와 b 중에서 큰 수가 big 에 저장됨 \n할당 연산자 \n \n= : a = b -> b 를 a 에 할당 \n+= : a += b -> a = a+b \n-= : a -= b -> a = a-b \n*= : a*=b -> a = a*b \n/= : a/=b -> a = a/b \n%= : a%=b -> a = a%b \n<<= : a<<=b -> a = a<<b \n>>= : a>>=b -> a = a>>b \n콤마(4 열)연산저 \n \n성격이 동일한 자료형을 나열할 때 사용된다. \n라이브러리 \n라이브러리의 개념과 구성 ']","['다음 C 언어 프로그램에서 밑줄 친 부분과 동일한 의미를 가지는 것은 어떤것인가?\n\n[보기]\n1) !a || !b\n2) !(a || b)\n3) a && b\n4) a || b', '다음 C 언어 프로그램에서 밑줄 친 부분과 동일한 의미를 가지는 것은 어떤것인가?\n\n[보기]\n1) !a || !b\n2) !(a || b)\n3) a && b\n4) a || b', '다음 C언어 프로그램에서 밑줄 친 부분과 동일한 의미를 가지는 것은 어떤것인가?\n\n[보기]\n1) !a || !b\n2) !(a || b)\n3) a && b\n4) a || b', 'UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며, 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?\n\n[보기]\n1) Association\n2) Dependency\n3) Realization\n4) Generalization', 'UML 모델에서 한 사물의 명세가 바뀌면 다른 사물에 영향을 주며 , 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계는?\n\n[보기]\n1) Association\n2) Dependency\n3) Realization\n4) Generalization', '키의 분류 \n \n학번 \n주민번호 \n이름 \n나이 \n<-학생---수강-> \n학번 \n과목 \n1 \n123123-1 \nA \n10 \n--- \n1 \n운영체제 \n2 \n123123-1 \nB \n20 \n--- \n2 \n소프트웨어공학 \n3 \n123123-1 \nC \n30 \n--- \n3 \nC 언어 \n슈퍼키(Super Key) \n \n두 개 이상의 속성으로 구성된 키 또는 혼합키를 의미한다. \n모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는다. \n외래키(Foreign Key) \n \n다른 테이블의 기본키로 사용되는 속성이다. \n<수강> 테이블에서 <학생> 테이블을 참조할 때 <학생> 테이블의 학번은 참조키, <수강> \n테이블의 학번이 외래 키가 된다. \n무결성(Integrity) \n \n릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션을 조작하는 과정에서의 \n의미전 관계 (Semantic Relationship)를 명세한 것으로 정의 대항으로 도메인, 키, \n종속성 등이 있다. \n개체 무결성 : 기본키의 값은 Null 값이나 중복 값을 가질 수 없다는 제약조건이다. \n참조 무결성 : 릴레이션 R1 에 속성 조합인 외래키를 변경하려면 이를 참조하고 있는 \n릴레이션 R2 의 기본키도 변경해야 한다. 이때 참조할 수 없는 외래키 값을 가질 수 없다는 \n제약조건이다. \n도메인 무결성 : 릴레이션 중 하나의 속성은 반드시 원자 값이어야 한다는 것을 보장하는 \n제약조건이다. \n42. 데이터베이스 설계와 구조화 \n데이터베이스 설계 단계 \n요구조건 분석 \n \n데이터베이스 사용자로부터 요구조건 수집과 요구조건 명세서를 작성한다. \n개념적 설계 \n \n목표 DBMS 에 독립적인 개념 스키마를 설계한다. \n개념 스키마 모델링(ERD)과 트랜잭션 모델링을 병행 수행한다. \n논리적 설계 \n \n목표 DBMS 에 종속적인 논리적 스키마를 설계한다. \n스키마의 평가 및 정제를 한다. \n논리적 데이터 모델로 변환 및 트랜잭션 인터페이스를 설계한다. \n물리적 설계', '단계 \n개요  \n1NF \n도메인이 원자값 \n2NF \n부분적 함수적 종속성 제거 => 완전 함수적 종속 관계 만족 (X -> Y) \n3NF \n이행적 함수 종속 제거 (A->B이고 B->C일 때 A->C를 만족하는 관계 제거) \nBCNF \n결정자이면서 후보키가 아닌 것 제거 \n4NF \n다치 종속 제거 \n5NF \n조인 종속성 이용 \n3) 반정규화 : 정규화된 엔티티, 속성, 관계를 중복, 통합, 분리(의도적인 정규화 원칙 위배) \n4. 물리적 모델링 \n1) 트랜잭션 분석 \n(1) 트랜잭션 : 하나의 논리적 기능을 수행하기 위한 작업의 단위 (DB 상태 변화) \n(2) 트랜잭션 상태 : 활동, 실패, 철회(롤백 수행), 부분완료(커밋 직전), 완료(커밋) \n(3) 분석 방법 : CRUD 분석 (Create, Read, Update, Delete) \n(4) 트랜잭션의 특성 (ACID) \nAtomicity(원자성) \n모두 반영되거나(Commit) 전혀 반영되지 않고 복구(Rollback) \nConsistency (일관성) \n시스템이 가진 고정요소는 트랜잭션 수행전과 수행후가 동일 \nIsolation (독립성) \n하나의 트랜잭션 실행 중에 다른 트랜잭션이 끼어들 수 없음 \nDurability (영속성)  \n완료된 트랜젝션 결과는 영구적으로 반영 \n2) 뷰(View) 설계 : 물리적으로 존재하지 않는 가상테이블 설계 (변경 불가, 독립적 인덱스 x) \n3) 파티션 설계: 범위분할, 해시분할, 조합분할(범위+해시), 목록분할, 라운드로빈분할(균일배분)\n4) 분산 데이터베이스 설계   \n(1) 분산 데이터베이스 : 논리적으로는 하나, 물리적으로는 분산 \n(2) 구성요소 : 분산 처리기, 분산 데이터베이스, 통신 네트워크 \n(3) 분산 데이터베이스의 모교 \n위치 투명성 \n논리적 명칭만으로 액세스 (실제위치 몰라도 됨) \n중복 투명성 \n동일 데이터가 여러곳에 중복되어 있더라도 마치 하나만 존재하듯이 사용 \n병행 투명성', '1) 리스트 : C언어의 배열과 비슷하지만 크기 지정X \n2) 딕셔너리 : (key : value) 로 묶어서 저장 -> 데이터에는 key로 접근 \n3) slice : 문자열이나 리스트에서 일부를 잘라서 반환 \n3. 조건문 \n4. 반복문 \n1) for문 \n2) while문 \n5. 함수 선언 \nⅢ  \nSQL : DB를 위한 언어 \n1. SQL의 구분 \nDDL (Data Define) \n논리적, 물리적 구조 정의  \n=> CREATE (테이블 생성), ALTER(테이블 수정), DROP (테이블 삭제) \nDML (Data Manipulation) \n데이터 처리 => SELECT, INSERT, DELETE, UPDATE \nDCL (Data Control) \n데이터 관리  \n=> COMMIT (반영), ROLLBACK(이전 상태로 되돌림), \nGRANT(권한 부여), REVOKE (권한 부여 취소) \n2. DML \n(1) INSERT INTO ~ VALUES (삽입) \n(2) DELETE FROM (삭제) : 구조가 아닌 데이터 삭제! \n(3) UPDATE ~ SET ~ (갱신) \n(4) SELECT 형식 ([ ] : 필수 아님)  \nSELECT (속성명) \nFROM 테이블명 \n[WHERE 조건] \n[ORDER BY 속성명 [ASC | DESC] ]  \n<기타>--------------------------------------------------------------------- \nALL  소프트웨어 만드려면 이정도는 알고 있어야 한다!  \n1. 미들웨어 : 서로 다른 기종간의 원만한 통신을 위한 소프트웨어 \n1) 종류 \n(1) DB : 클라이언트와 원격의 데이터베이스를 연결하는 미들웨어 \n(2) PRC(Remote Procedure Call) : 원격 프로시저를 로컬 프로시저처럼 호출 \n(3) MOM(Message Oriented Middleware)  \n: 비동기형(응답을 기다리지 않고 작업처리) 메시지를 전달하는 방식', '-> \n \n조건 연산자 ? : \n<- \n \n할당 연산자 =, +=, -=, *=, /=, %=, <<=, >>= \n<- \n \n콤마 연산자 , \n-> \n낮음 \nC 언어 연산자의 특징 \n단항 연산자 \n \n! : 부정(NOT) \n~ : 1 의 보수(0->1, 1->0)를 구한다. \n++ : 1 씩 증가를 의미한다. \n-- : 1 씩 감소를 의미한다. \n& : 변수의 주소를 의미한다. \n* : 변수의 내용을 의미한다. \nsizeof : 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구한다. \n산술 연산자 \n \n이항 연산자는 +, -는 *, /, % 보다 우선순위가 낮다. \n% : 정수 나눗셈 연산 후 나머지를 구한다. \n시프트(shift) 연산자 \n \n<<는 비트를 왼쪽으로 이동시킨다. \n>>는 비트를 오른쪽으로 이동시킨다. \n관계 연산자 \n \n< : ~보다 작다. \n> : ~보다 크다. \n<= : ~보다 작거나 같다. \n>\\ : ~보다 크거나 같다. \n== : ~와 같다. \n!= : ~와 같지 않다. \n비트 연산자 \n \n& : 논리곱(AND) \n| : 논리합(OR) \n^ : 배타적 논리합(XOR) \n#include <stdio.h> \nint main(int argc, char *argv[]) { \n    int a = 4; \n    int b = 7; \n    int c = a|b; \n    printf(""%d"", c); \n    return 0; \n} \n// 1. 변수 a 와 b 의 4, 7 을 (2 진수)비트 연산자 |(OR)로 연산한다. \n// 2. 비트 연산자는 2 진수로 변환 후 계산하낟. \n// 3. OR 연산자는 두 비트 중 1 개라도 1 이면 1 이 출력된다. \n//     0100 (10 진수: 4) \n// OR  0111 (10 진수: 7) \n// =   0111(둘 중 1 개라도 1 이면 1 이기 때문에 10 진수: 7) \n// 4. 0111 는 ""%d"" 출력 형식 지정 문자에 의해 10 진수로 변환하면 7 이 되어 \n출력된다.', '// \n// 2 와 5 를 가정할때 \n//     0010 \n// OR  0101 \n// =   0111 \n논리 연산자 \n \n! : 논리 부정(NOT) \n&& : 논리곱(AND) \n|| : 논리합(OR) \n조건 연산자 \n \nC 언어에서 유일하게 3 개의 피연산자를 갖는 삼항 연산자이다. \n조건식 ? 참일 경우 값 : 거짓일 경우 값 \nex. big = a > b ? a:b; -> a 와 b 중에서 큰 수가 big 에 저장됨 \n할당 연산자 \n \n= : a = b -> b 를 a 에 할당 \n+= : a += b -> a = a+b \n-= : a -= b -> a = a-b \n*= : a*=b -> a = a*b \n/= : a/=b -> a = a/b \n%= : a%=b -> a = a%b \n<<= : a<<=b -> a = a<<b \n>>= : a>>=b -> a = a>>b \n콤마(4 열)연산저 \n \n성격이 동일한 자료형을 나열할 때 사용된다. \n라이브러리 \n라이브러리의 개념과 구성 \n \n라이브러리란 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 프로그램을 말한다. \n프로그래밍 언어에 따라 일반적으로 도움말, 설치 파일, 샘플 코드 등을 제공한다. \n라이브러리는 모듈과 패키지를 총칭하며, 모듈이 개별 파일이라면 패키지는 파일들을 모아 \n놓은 폴더라고 볼 수 있다. \n표준 라이브러리는 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미하며, \n외부 라이브러리는 별도의 파일 설치를 필요로 하는 라이브러리를 의미한다. \n52. Java 언어 \nJava 언어의 기초 \nJava 언어의 개념 \n \n객체지향 언어이다. \n추상화, 상속화, 다형성과 같은 특징을 가진다. \n네트워크 환경에서 분산 작업이 가능하도록 설계되었다. \n특정 컴퓨터 구조와 무관한 가상 바이트 머신 코드를 사용하므로 플랫폼이 독립적이다. \nGarbage Collector \n \nS/W 개발 중 유효하지 않은 가비지 메모리가 발생한다. Java 에서는 C 언어와 달리 JVM']"
20,TCP/IP 에서 사용되는 논리 주소를 물리 주소로 변환시켜 주는 프로토콜은?,"[""TCP"", ""ARP"", ""FTP"", ""IP""]",2,2,프로그래밍 언어 활용,프로그래밍 언어 활용,"TCP/IP에서 사용되는 논리 주소를 물리 주소로 변환시켜 주는 프로토콜은 ARP(Address Resolution Protocol)입니다. ARP는 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 바꾸는 역할을 합니다. 

과목: 프로그래밍 언어 활용 

이 과목은 컴퓨터와 관련된 다양한 프로그래밍 언어의 활용 및 관리에 관한 내용을 다루며, 네트워크 프로토콜과 관련된 내용도 포함합니다. 특히, TCP/IP 프로토콜과 관련된 주요 프로토콜들, 예를 들어 ARP, IP, ICMP, IGMP 등에 대해 학습합니다. 따라서 이 문제의 정답과 풀이는 프로그래밍 언어 활용 과목과 관련이 있습니다.","['분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신환경 등을 연결하여 응용 프로그램과 운영환경 간에 원만한 통신이 이루어질 수 있게 서비스를 제공하는 소프트웨어는?', '해싱 함수 중 레코드 키를 여러 부분으로 나누고 , 나눈 부분의 각 숫자를 더하거나 XOR 한 값을 홈 주소로 사용하는 방식은 ?', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며 , 인터페이스를 통해서만 접근할 수 있는 것은?', '브리지와 구내 정보 통신망(LAN)으로 구성된 통신망에서 루프(폐회로)를 형성하지 않으면서 연결을 설정하는 알고리즘은?']","['TCP/IP 프로토콜- ARP 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치 의 물리적 주소(MAC Address)로 바꾼다.', 'TCP/IP 프로토콜- ARP 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치 의 물리적 주소(MAC Address)로 바꾼다.', '인터넷 계층의 주요 프로토콜- 전송할 데이터에 주소를 지정하고, 경 로를 설정하는 기능을 함 IP(Internet Protocol)- 비연결형인 데이터그램 방식을 사용하 는 것으로 신뢰성이 보장되지 않음 ICMP IP와 조합하여 통신중에 발생하는 오류의 (Internet Control 처리와 전송 경로 변경 등을 위한 제어 Message 메시지를 관리하는 역할을 하며, 헤더는 Protocol, 인터넷 제어 8Byte로 구성됨 메시지 프로토콜) IGMP(Internet Group 멀티캐스트를 지원하는 호스트나 라우터 Management Protocol, 사이에서 멀티캐스트 그룹 유지를 위해 인터넷 그룹 관리 프로 사용됨 토콜) ARP 호스트의 IP 주소를 호스트와 연결된 네 (Address Resolution 트워크 접속 장치의 물리적 주소 (MAC Protocol, Address)로 바꿈 주소 분석 프로토콜) RARP(Reverse ARP와 반대로 물리적 주소를 IP 주소로 Addr', '(Internet Protocol Address) IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.- 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있다.- IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다. 96 국가나 대형 통신망에 사용 (0~127로 시작) A 1\x08 8 9\x08 16 17\x08 24 25 32bit 24 Class 2 = 16,777,216개의 호스트 사 용 가능 중대형 통신망에 사용 (128~191로 시작) B 16 Class 2 = 65,536개의 호스트 사용 가능 소규모 통신망에 사용 C (192~223으로 시작) Class 8 2 = 256개의 호스트 사용 가능 D 멀티캐스트용으로 사용 Class (224~239로 시작) 네트워크 부분 E 호스트 부분 실험적 주소이며 공용되지 않음 Class 2459', '응용 계층의 주요 프로토콜 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이 FTP (File Transfer 에서 파일을 주고받을 수 있도록 하는 원격 Protocol) 파일 전송 프로토콜 SMTP(Simple Mail 전자 우편을 교환하는 서비스 Transfer Protocol)- 멀리 떨어져 있는 컴퓨터에 접속하여 자신 의 컴퓨터처럼 사용할 수 있도록 해주는 서 비스 TELNET- 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널(Virtual Terminal) 기 능을 수행 SNMP(Simple TCP/IP의 네트워크 관리 프로토콜로, 라우터 Network 나 허브 등 네트워크 기기의 네트워크 정보를 Management 네트워크 관리 시스템에 보내는 데 사용되는 Protocol) 표준 통신 규약 DNS 도메인 네임을 IP 주소로 매핑(Mapping)하는 (Domain Name 시스템 System) 월드 와이드 웹(WWW)에서 HTML 문서를 송 HTTP(Hyper']","['분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신환경 등을 연결하여 응용 프로그램과 운영환경 간에 원만한 통신이 이루어질 수 있게 서비스를 제공하는 소프트웨어는?\n\n[보기]\n1) 미들웨어\n2) 하드웨어\n3) 오픈허브웨어\n4) 그레이웨어', '해싱 함수 중 레코드 키를 여러 부분으로 나누고 , 나눈 부분의 각 숫자를 더하거나 XOR 한 값을 홈 주소로 사용하는 방식은 ?\n\n[보기]\n1) 제산법\n2) 폴딩법\n3) 기수 변환법\n4) 숫자 분석법', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?\n\n[보기]\n1) Model\n2) Sheet\n3) Component\n4) Cell', '명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며 , 인터페이스를 통해서만 접근할 수 있는 것은?\n\n[보기]\n1) Model\n2) Sheet\n3) Component\n4) Cell', '브리지와 구내 정보 통신망(LAN)으로 구성된 통신망에서 루프(폐회로)를 형성하지 않으면서 연결을 설정하는 알고리즘은?\n\n[보기]\n1) Spanning Tree Algorithm\n2) Diffie-Hellman Algorithm\n3) Hash Algorithm\n4) Digital Signature Algorithm', 'TCP/IP 프로토콜- ARP 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치 의 물리적 주소(MAC Address)로 바꾼다.', 'TCP/IP 프로토콜- ARP 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치 의 물리적 주소(MAC Address)로 바꾼다.', '인터넷 계층의 주요 프로토콜- 전송할 데이터에 주소를 지정하고, 경 로를 설정하는 기능을 함 IP(Internet Protocol)- 비연결형인 데이터그램 방식을 사용하 는 것으로 신뢰성이 보장되지 않음 ICMP IP와 조합하여 통신중에 발생하는 오류의 (Internet Control 처리와 전송 경로 변경 등을 위한 제어 Message 메시지를 관리하는 역할을 하며, 헤더는 Protocol, 인터넷 제어 8Byte로 구성됨 메시지 프로토콜) IGMP(Internet Group 멀티캐스트를 지원하는 호스트나 라우터 Management Protocol, 사이에서 멀티캐스트 그룹 유지를 위해 인터넷 그룹 관리 프로 사용됨 토콜) ARP 호스트의 IP 주소를 호스트와 연결된 네 (Address Resolution 트워크 접속 장치의 물리적 주소 (MAC Protocol, Address)로 바꿈 주소 분석 프로토콜) RARP(Reverse ARP와 반대로 물리적 주소를 IP 주소로 Address 변환하는 기능을 함 Resolution Protocol) 22.7, 21.3 2416', '(Internet Protocol Address) IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.- 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있다.- IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다. 96 국가나 대형 통신망에 사용 (0~127로 시작) A 1\x08 8 9\x08 16 17\x08 24 25 32bit 24 Class 2 = 16,777,216개의 호스트 사 용 가능 중대형 통신망에 사용 (128~191로 시작) B 16 Class 2 = 65,536개의 호스트 사용 가능 소규모 통신망에 사용 C (192~223으로 시작) Class 8 2 = 256개의 호스트 사용 가능 D 멀티캐스트용으로 사용 Class (224~239로 시작) 네트워크 부분 E 호스트 부분 실험적 주소이며 공용되지 않음 Class 2459', '응용 계층의 주요 프로토콜 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이 FTP (File Transfer 에서 파일을 주고받을 수 있도록 하는 원격 Protocol) 파일 전송 프로토콜 SMTP(Simple Mail 전자 우편을 교환하는 서비스 Transfer Protocol)- 멀리 떨어져 있는 컴퓨터에 접속하여 자신 의 컴퓨터처럼 사용할 수 있도록 해주는 서 비스 TELNET- 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널(Virtual Terminal) 기 능을 수행 SNMP(Simple TCP/IP의 네트워크 관리 프로토콜로, 라우터 Network 나 허브 등 네트워크 기기의 네트워크 정보를 Management 네트워크 관리 시스템에 보내는 데 사용되는 Protocol) 표준 통신 규약 DNS 도메인 네임을 IP 주소로 매핑(Mapping)하는 (Domain Name 시스템 System) 월드 와이드 웹(WWW)에서 HTML 문서를 송 HTTP(HyperText Transfer Protocol) 수신 하기 위한 표준 프로토콜 2416']"
21,라이브러리의 개념과 구성에 대한 설명 중 틀린 것은 ?,"[""라이브러리란 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 프로그램을 말한다."", ""프로그래밍 언어에 따라 일반적으로 도움말 , 설치 파일 , 샘플코드 등을 제공한다."", ""외부 라이브러리는 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미하며 , 표준 라이브러리는 별도의 파일설치를 필요로 하는 라이브러리를 의미한다."", ""라이브러리는 모듈과 패키지를 총칭하며 , 모듈이 개별 파일이라면 패키지는 파일들을 모아 놓은 폴더라고 볼 수 있다.""]",3,3,프로그래밍 언어 활용,프로그래밍 언어 활용,"라이브러리의 개념과 구성에 대한 설명 중 틀린 것은 외부 라이브러리는 프로그래밍 언어가 기본적으로 가지고 있는 라이브러리를 의미하며, 표준 라이브러리는 별도의 파일 설치를 필요로 하는 라이브러리를 의미한다. 라이브러리는 필요할 때 찾아서 쓸 수 있도록 모듈화되어 제공되는 프로그램을 말한다. 라이브러리는 모듈과 패키지를 총칭하며, 모듈이 개별 파일이라면 패키지는 파일들을 모아 놓은 폴더라고 볼 수 있다. 프로그래밍 언어에 따라 일반적으로 도움말, 설치 파일, 샘플 코드 등을 제공한다. 표준 라이브러리는 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리로, 여러 종류의 모듈이나 패키지로 구성된다. 외부 라이브러리는 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용한다. 따라서 외부 라이브러리와 표준 라이브러리의 설명이 반대이므로 3번이 정답이다.
과목: 프로그래밍 언어 활용","['동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?', '공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해되고 한 가지로 해석될 수 있도록 작성하는 원칙은?', '소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법을 무엇이라고 하는가?', '소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?', '소프트웨어 개발 방법론의 테일러링 (Tailoring) 과 관련한 설명으로 틀린 것은?']","['객체(Object) 객체는 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡 슐화한) 하나의 소프트웨어 모듈이다.- 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 데이터 나타냄- 속성(Attribute), 상태, 변수, 상수, 자료 구조라고도 함- 객체가 수행하는 기능으로 객체가 갖는 데이터(속성, 상 태)를 처리하는 알고리즘 함수- 객체의 상태를 참조하거나 변경하는 수단이 되는 것 으로 메소드(Method, 행위), 서비스(Service), 동작 (Operation), 연산이라고도 함- 객체의 특성- 객체는 독립적으로 식별 가능한 이름을 가지고 있다.- 객체가 가질 수 있는 조건을 상태(State)라고 하는 데, 일반적으로 상태는 시간에 따라 변한다.- 객체와 객체는 상호 연관성에 의한 관계가 형성된다.- \u200c 객체가 반응할 수 있는 메시지(Message)의 집합을 행 위라고 하며, 객체는 행위의 특징을 나타낼 수 있다.- \u200c 객체는 일정한 기억장소를 가지고 있다.- 객체의 메', '라이브러리- 표준 라이브러리 : 프로그래밍 언어에 기본적으로 포함 되어 있는 라이브러리로, 여러 종류의 모듈이나 패키지 로 구성됨- 외부 라이브러리 : 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용함', '라이브러리- 표준 라이브러리 : 프로그래밍 언어에 기본적으로 포함 되어 있는 라이브러리로, 여러 종류의 모듈이나 패키지 로 구성됨- 외부 라이브러리 : 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용함', '표준 라이브러리 C언어는 라이브러리를 헤더 파일로 제공하는데, 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되 어 있다.- C언어에서 헤더 파일을 사용하려면 ‘#include <stdio.h>’ 와 같이 include문을 이용해 선언한 후 사용해야 한다. 헤더 파일 기능- 데이터의 입·출력에 사용되는 기능들을 제공함 stdio.h- 주요 함수 : printf, scanf, fprintf, fscanf, fclose, fopen 등- 수학 함수들을 제공함 math.h- 주요 함수 : sqrt, pow, abs 등- 문자열 처리에 사용되는 기능들을 제공함 string.h- 주요 함수 : strlen, strcpy, strcmp 등- 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기 stdlib.h 능들을 제공함- 주요 함수 : atoi, atof, srand, rand, malloc, free 등- 시간 처리에 사용되는 기능들을 제공함 time.h- 주요 함수 : ti', '편집기, 컴파일러, 디버거 등의 다양한 도구를 하나의 인터페이스로 통합하여 제공한다. \n오류 체크를 시각화하여 확인 및 수정을 쉽도록 지원한다. \n컴파일에 필요한 외부 추가 기능을 연계하여 개발의 편의성을 높였다. \n종류 : 이클립스, 비주얼 스튜디오, XCode, 안드로이드 스튜디오, IDEA, VSC 등 \n빌드 자동화 도구 \n \n소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만든다. \n소프트웨어 개발자가 반복 작업해야 하는 코딩을 잘 짜여진 프로세스를 통해 자동으로 \n실행하여, 신뢰성 있는 결과물을 생산해 낼 수 있는 작업 방식 및 방법이다. \n소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 \n생성하는 프로그램이며, 지속해서 증가하는 라이브러리의 자동 추가 및 관리(전처리, \nPreprocessing)를 지원한다. \n최근에는 오픈소스인 Gradle 이 등장했으며, 구글이 안드로이드의 기본 빌드 시스템으로 \nGradle 을 선']","['동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?\n\n[보기]\n1) RCS(Revision Control System)\n2) RTS(Reliable Transfer Service)\n3) RPC(Remote Procedure Call)\n4) RVS(Relative Version System)', '공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해되고 한 가지로 해석될 수 있도록 작성하는 원칙은?\n\n[보기]\n1) 상호작용성\n2) 명확성\n3) 독립성\n4) 내용성', '소프트웨어 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법을 무엇이라고 하는가?\n\n[보기]\n1) 모듈 분해\n2) 디자인 패턴\n3) 연관 관계\n4) 클래스 도출', '소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.\n2) 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.\n3) 관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.\n4) 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.', '소프트웨어 개발 방법론의 테일러링 (Tailoring) 과 관련한 설명으로 틀린 것은?\n\n[보기]\n1) 프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.\n2) 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차 , 산출물 등을 적절히 변경하는 활동이다.\n3) 관리 측면에서의 목적 중 하나는 최단 기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.\n4) 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.', '객체(Object) 객체는 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡 슐화한) 하나의 소프트웨어 모듈이다.- 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 데이터 나타냄- 속성(Attribute), 상태, 변수, 상수, 자료 구조라고도 함- 객체가 수행하는 기능으로 객체가 갖는 데이터(속성, 상 태)를 처리하는 알고리즘 함수- 객체의 상태를 참조하거나 변경하는 수단이 되는 것 으로 메소드(Method, 행위), 서비스(Service), 동작 (Operation), 연산이라고도 함- 객체의 특성- 객체는 독립적으로 식별 가능한 이름을 가지고 있다.- 객체가 가질 수 있는 조건을 상태(State)라고 하는 데, 일반적으로 상태는 시간에 따라 변한다.- 객체와 객체는 상호 연관성에 의한 관계가 형성된다.- \u200c 객체가 반응할 수 있는 메시지(Message)의 집합을 행 위라고 하며, 객체는 행위의 특징을 나타낼 수 있다.- \u200c 객체는 일정한 기억장소를 가지고 있다.- 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다. 2402', '라이브러리- 표준 라이브러리 : 프로그래밍 언어에 기본적으로 포함 되어 있는 라이브러리로, 여러 종류의 모듈이나 패키지 로 구성됨- 외부 라이브러리 : 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용함', '라이브러리- 표준 라이브러리 : 프로그래밍 언어에 기본적으로 포함 되어 있는 라이브러리로, 여러 종류의 모듈이나 패키지 로 구성됨- 외부 라이브러리 : 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용함', '표준 라이브러리 C언어는 라이브러리를 헤더 파일로 제공하는데, 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되 어 있다.- C언어에서 헤더 파일을 사용하려면 ‘#include <stdio.h>’ 와 같이 include문을 이용해 선언한 후 사용해야 한다. 헤더 파일 기능- 데이터의 입·출력에 사용되는 기능들을 제공함 stdio.h- 주요 함수 : printf, scanf, fprintf, fscanf, fclose, fopen 등- 수학 함수들을 제공함 math.h- 주요 함수 : sqrt, pow, abs 등- 문자열 처리에 사용되는 기능들을 제공함 string.h- 주요 함수 : strlen, strcpy, strcmp 등- 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기 stdlib.h 능들을 제공함- 주요 함수 : atoi, atof, srand, rand, malloc, free 등- 시간 처리에 사용되는 기능들을 제공함 time.h- 주요 함수 : time, clock 등 401', '편집기, 컴파일러, 디버거 등의 다양한 도구를 하나의 인터페이스로 통합하여 제공한다. \n오류 체크를 시각화하여 확인 및 수정을 쉽도록 지원한다. \n컴파일에 필요한 외부 추가 기능을 연계하여 개발의 편의성을 높였다. \n종류 : 이클립스, 비주얼 스튜디오, XCode, 안드로이드 스튜디오, IDEA, VSC 등 \n빌드 자동화 도구 \n \n소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만든다. \n소프트웨어 개발자가 반복 작업해야 하는 코딩을 잘 짜여진 프로세스를 통해 자동으로 \n실행하여, 신뢰성 있는 결과물을 생산해 낼 수 있는 작업 방식 및 방법이다. \n소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 \n생성하는 프로그램이며, 지속해서 증가하는 라이브러리의 자동 추가 및 관리(전처리, \nPreprocessing)를 지원한다. \n최근에는 오픈소스인 Gradle 이 등장했으며, 구글이 안드로이드의 기본 빌드 시스템으로 \nGradle 을 선택하면서 사용자가 급증하였다. \n기능 : 코드 컴파일, 컴포넌트 패키징, 파일 조작, 개발 테스트 실행, 버전 관리 도구 \n통합, 문서 생성, 배포 기능, 코드 품질 분석 \n프로세스 : 컴파일 => 패키징 => 단위 테스트 => 정적 분석 => 리포팅 => 배포 => 최종 \n빌드 \n종류 : Gradle, Jenkins, Makefile, Ant, Maven 등 \nAnt \n아파치 소프트웨어 재단에서 개발. XML 기반 빌드 스크립트를 사용한다. \n정해진 규칙이 없고, 절차적이다.(명확한 빌드 절차 정의가 필요). \n생명주기를 갖지 않아 각 Target 에 대한 의존관계와 작업을 정의해 주어야 한다. \n유연성이 높으나 프로젝트가 복잡해지는 경우 Build 과정의 이해가 어려워진다. \nXML, Remote Repository 를 가져올 수 없고 스크립트의 재사용이 어렵다. \nMaven \n프로젝트에 필요한 모든 종속성(Dependency)을 리스트의 형태로 Maven 에 알려서']"
22,C 언어 라이브러리 중 stdlib.h 에 대한 설명으로 옳은 것은 ?,"[""문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 있다."", ""문자열 처리 함수로 strlen() 이 포함되어 있다 ."", ""표준 입출력 라이브러리이다."", ""삼각 함수 , 제곱근 , 지수 등 수학적인 함수를 내장하고 있다 .""]",1,1,프로그래밍 언어 활용,프로그래밍 언어 활용,"stdlib.h 라이브러리는 문자열을 수치 데이터로 바꾸는 문자 변환 함수(예: atoi(), atof())와 수치를 문자열로 바꿔주는 변환 함수 등이 포함되어 있습니다. 또한, 메모리 할당 함수(예: malloc(), free())나 프로세스 제어 함수(예: exit(), abort()) 등의 기능도 제공됩니다. 보기 중에서 '문자열을 수치 데이터로 바꾸는 문자 변환함수와 수치를 문자열로 바꿔주는 변환함수 등이 있다.'라는 설명이 stdlib.h에 정확히 일치합니다.

과목: 프로그래밍 언어 활용","['주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법으로 , 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행하는 할당 기법은?', 'DBA 가 사용자 PARK 에게 테이블 [STUDENT] 의 데이터를 갱신할 수 있는 시스템 권한을 부여하고자 하는 SQL 문을 작성하고자 한다 . 다음에 주어진 SQL 문의 빈칸을 알맞게 채운 것은 ? SQL ＞ GRANT ㉠ ㉡ STUDENT TO PARK;', 'Python 데이터 타입 중 시퀀스(Sequence) 데이터 타입에 해당하며 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것은?', 'JAVA에서 힙(Heap)에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?', 'JAVA 에서 힙 (Heap) 에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?']","['4과목: 프로그래밍 언어 활용\n\n출제 경향 \n\u200b 2장(언어) / 3장(알고리즘) 집중.\u200b\n\u200b 실기와 직접 연결됨.\u200b\n핵심 개념 \n\u200b 자료형: C, Java, Python (list, tuple, range)\u200b\n\u200b 연산자/반복문: for, while / 산술, 논리, 비트\u200b\n\u200b 포인터: *, & 연산자 / 포인터 배열 구분\u200b\n\u200b 스크립트 언어: JS, PHP, Python, 쉘\u200b\n\u200b 라이브러리: stdio.h, math.h, string.h, stdlib.h\u200b\n\u200b 운영체제 명령어: uname, fork, chmod, ls\u200b\n\u200b 가상기억장치:\u200b\n\u200b 페이징 vs 세그먼트\u200b\n\u200b 교체 알고리즘: FIFO, LRU, LFU\u200b\n\u200b 워킹셋, 스래싱 개념\u200b\n\u200b 프로세스/스레드 상태: ready, running, blocked 등\u200b\n\u200b 스케줄링: SJF, HRN\u200b\n\u200b TCP/IP: TCP(양방향), IP, UDP, ICMP, ARP\u200b\n\u200b OSI 7계층 / IPv4 vs IPv6 차이\u200b', '표준 라이브러리 C언어는 라이브러리를 헤더 파일로 제공하는데, 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되 어 있다.- C언어에서 헤더 파일을 사용하려면 ‘#include <stdio.h>’ 와 같이 include문을 이용해 선언한 후 사용해야 한다. 헤더 파일 기능- 데이터의 입·출력에 사용되는 기능들을 제공함 stdio.h- 주요 함수 : printf, scanf, fprintf, fscanf, fclose, fopen 등- 수학 함수들을 제공함 math.h- 주요 함수 : sqrt, pow, abs 등- 문자열 처리에 사용되는 기능들을 제공함 string.h- 주요 함수 : strlen, strcpy, strcmp 등- 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기 stdlib.h 능들을 제공함- 주요 함수 : atoi, atof, srand, rand, malloc, free 등- 시간 처리에 사용되는 기능들을 제공함 time.h- 주요 함수 : ti', '-> \n \n조건 연산자 ? : \n<- \n \n할당 연산자 =, +=, -=, *=, /=, %=, <<=, >>= \n<- \n \n콤마 연산자 , \n-> \n낮음 \nC 언어 연산자의 특징 \n단항 연산자 \n \n! : 부정(NOT) \n~ : 1 의 보수(0->1, 1->0)를 구한다. \n++ : 1 씩 증가를 의미한다. \n-- : 1 씩 감소를 의미한다. \n& : 변수의 주소를 의미한다. \n* : 변수의 내용을 의미한다. \nsizeof : 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구한다. \n산술 연산자 \n \n이항 연산자는 +, -는 *, /, % 보다 우선순위가 낮다. \n% : 정수 나눗셈 연산 후 나머지를 구한다. \n시프트(shift) 연산자 \n \n<<는 비트를 왼쪽으로 이동시킨다. \n>>는 비트를 오른쪽으로 이동시킨다. \n관계 연산자 \n \n< : ~보다 작다. \n> : ~보다 크다. \n<= : ~보다 작거나 같다. \n>\\ : ~보다 크거나 같다. \n== : ~와 같다. \n', '프로그램을 컴퓨터에서 실행가능한 형태로 변환 \n디버깅 \n버그를 찾아 수정 \n배포 \n사용자에게 배포 \n2. 인터페이스 구현  \n1) 모듈 연계 방법 (데이터 교환을 위한 관계 설정) : EAI \n2) 인터페이스 구현 \n(1) 통신 기술 : AJAX (Javascript를 이용한 비동기 통신 기술) \n데이터 포맷: JSON (데이터 객체를 속성-값의 쌍 형태로 표현), XML (마크업 언어) \n(2) 보안 : 스니핑(수동적 공격)을 막기 위해 네트워크 트래픽에 대한 암호화 설정 \n=> 방식 : IPSec, SSL, S-HTTP 등 \n3) 구현 검증 도구 \nxUnit \nJava(Junit), C++(CppUnit) 등 다양한 언어를 지원 \nSTAF \n다양한 환경을 지원 \nFitNess \n웹기반 \nNTAF \nFitNess + STAF \nwatir \nRuby 기반 \nEAI 구축 유형 \n설명 \nPoint-to-Point \n애플리케이션의 1:1 연결 \nHub & Spoke \n허브를 통해 데이터를', ""입·출력 함수 input( ) 함수- input( ) 함수는 Python의 표준 입력 함수로, 키보드로 입력받아 변수에 저장하는 함수이다.- 형식 변수 = input(출력문자)- ‘출력문자’는 생략이 가능하며, ‘변수’ 는 사용자가 임의로 지정할 수 있다.- 값을 입력하고 를 누르면, 입력 J \x08 한 값이 ‘변수’에 저장된다. 화면에 입력하세요. \ue355 \u200c a = input('입력하세요.' ) → \u200c 가 출력 되고 그 뒤에서 커서가 깜빡거리며 입력을 기다린다. 키보드로 값을 입력하면 변수 a에 저장된다. print( ) 함수- 형식1 print( 출력값1, 출력값2, …, sep = 분리문자, end = 종료문자)- ‘출력값’에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식이 올 수 있다.- ‘sep’는 여러 값을 출력할 때 값과 값 사이를 구분하기 위해 출력하는 문 자로, 생략할 경우 기본값은 공백 한 칸(‘ ’)이다. \x08- ‘end’는 맨 마지막에 표시할 문자로, 생략할 경우 ""]","['주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법으로 , 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행하는 할당 기법은?\n\n[보기]\n1) 오버레이\n2) 스와핑\n3) 페이징\n4) 세그먼테이션', 'DBA 가 사용자 PARK 에게 테이블 [STUDENT] 의 데이터를 갱신할 수 있는 시스템 권한을 부여하고자 하는 SQL 문을 작성하고자 한다 . 다음에 주어진 SQL 문의 빈칸을 알맞게 채운 것은 ? SQL ＞ GRANT ㉠ ㉡ STUDENT TO PARK;\n\n[보기]\n1) ㉠ INSERT, ㉡ INTO\n2) ㉠ ALTER, ㉡ TO\n3) ㉠ UPDATE, ㉡ ON\n4) ㉠ REPLACE, ㉡ IN', 'Python 데이터 타입 중 시퀀스(Sequence) 데이터 타입에 해당하며 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것은?\n\n[보기]\n1) 복소수(complex) 타입\n2) 리스트(list) 타입\n3) 사전(dict) 타입\n4) 튜플(tuple) 타입', 'JAVA에서 힙(Heap)에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?\n\n[보기]\n1) Heap Collector\n2) Garbage Collector\n3) Memory Collector\n4) Variable Collector', 'JAVA 에서 힙 (Heap) 에 남아있으나 변수가 가지고 있던 참조값을 잃거나 변수 자체가 없어짐으로써 더 이상 사용되지 않는 객체를 제거해주는 역할을 하는 모듈은?\n\n[보기]\n1) Heap Collector\n2) Garbage Collector\n3) Memory Collector\n4) Variable Collector', '4과목: 프로그래밍 언어 활용\n\n출제 경향 \n\u200b 2장(언어) / 3장(알고리즘) 집중.\u200b\n\u200b 실기와 직접 연결됨.\u200b\n핵심 개념 \n\u200b 자료형: C, Java, Python (list, tuple, range)\u200b\n\u200b 연산자/반복문: for, while / 산술, 논리, 비트\u200b\n\u200b 포인터: *, & 연산자 / 포인터 배열 구분\u200b\n\u200b 스크립트 언어: JS, PHP, Python, 쉘\u200b\n\u200b 라이브러리: stdio.h, math.h, string.h, stdlib.h\u200b\n\u200b 운영체제 명령어: uname, fork, chmod, ls\u200b\n\u200b 가상기억장치:\u200b\n\u200b 페이징 vs 세그먼트\u200b\n\u200b 교체 알고리즘: FIFO, LRU, LFU\u200b\n\u200b 워킹셋, 스래싱 개념\u200b\n\u200b 프로세스/스레드 상태: ready, running, blocked 등\u200b\n\u200b 스케줄링: SJF, HRN\u200b\n\u200b TCP/IP: TCP(양방향), IP, UDP, ICMP, ARP\u200b\n\u200b OSI 7계층 / IPv4 vs IPv6 차이\u200b', '표준 라이브러리 C언어는 라이브러리를 헤더 파일로 제공하는데, 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되 어 있다.- C언어에서 헤더 파일을 사용하려면 ‘#include <stdio.h>’ 와 같이 include문을 이용해 선언한 후 사용해야 한다. 헤더 파일 기능- 데이터의 입·출력에 사용되는 기능들을 제공함 stdio.h- 주요 함수 : printf, scanf, fprintf, fscanf, fclose, fopen 등- 수학 함수들을 제공함 math.h- 주요 함수 : sqrt, pow, abs 등- 문자열 처리에 사용되는 기능들을 제공함 string.h- 주요 함수 : strlen, strcpy, strcmp 등- 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기 stdlib.h 능들을 제공함- 주요 함수 : atoi, atof, srand, rand, malloc, free 등- 시간 처리에 사용되는 기능들을 제공함 time.h- 주요 함수 : time, clock 등 401', '-> \n \n조건 연산자 ? : \n<- \n \n할당 연산자 =, +=, -=, *=, /=, %=, <<=, >>= \n<- \n \n콤마 연산자 , \n-> \n낮음 \nC 언어 연산자의 특징 \n단항 연산자 \n \n! : 부정(NOT) \n~ : 1 의 보수(0->1, 1->0)를 구한다. \n++ : 1 씩 증가를 의미한다. \n-- : 1 씩 감소를 의미한다. \n& : 변수의 주소를 의미한다. \n* : 변수의 내용을 의미한다. \nsizeof : 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구한다. \n산술 연산자 \n \n이항 연산자는 +, -는 *, /, % 보다 우선순위가 낮다. \n% : 정수 나눗셈 연산 후 나머지를 구한다. \n시프트(shift) 연산자 \n \n<<는 비트를 왼쪽으로 이동시킨다. \n>>는 비트를 오른쪽으로 이동시킨다. \n관계 연산자 \n \n< : ~보다 작다. \n> : ~보다 크다. \n<= : ~보다 작거나 같다. \n>\\ : ~보다 크거나 같다. \n== : ~와 같다. \n!= : ~와 같지 않다. \n비트 연산자 \n \n& : 논리곱(AND) \n| : 논리합(OR) \n^ : 배타적 논리합(XOR) \n#include <stdio.h> \nint main(int argc, char *argv[]) { \n    int a = 4; \n    int b = 7; \n    int c = a|b; \n    printf(""%d"", c); \n    return 0; \n} \n// 1. 변수 a 와 b 의 4, 7 을 (2 진수)비트 연산자 |(OR)로 연산한다. \n// 2. 비트 연산자는 2 진수로 변환 후 계산하낟. \n// 3. OR 연산자는 두 비트 중 1 개라도 1 이면 1 이 출력된다. \n//     0100 (10 진수: 4) \n// OR  0111 (10 진수: 7) \n// =   0111(둘 중 1 개라도 1 이면 1 이기 때문에 10 진수: 7) \n// 4. 0111 는 ""%d"" 출력 형식 지정 문자에 의해 10 진수로 변환하면 7 이 되어 \n출력된다.', '프로그램을 컴퓨터에서 실행가능한 형태로 변환 \n디버깅 \n버그를 찾아 수정 \n배포 \n사용자에게 배포 \n2. 인터페이스 구현  \n1) 모듈 연계 방법 (데이터 교환을 위한 관계 설정) : EAI \n2) 인터페이스 구현 \n(1) 통신 기술 : AJAX (Javascript를 이용한 비동기 통신 기술) \n데이터 포맷: JSON (데이터 객체를 속성-값의 쌍 형태로 표현), XML (마크업 언어) \n(2) 보안 : 스니핑(수동적 공격)을 막기 위해 네트워크 트래픽에 대한 암호화 설정 \n=> 방식 : IPSec, SSL, S-HTTP 등 \n3) 구현 검증 도구 \nxUnit \nJava(Junit), C++(CppUnit) 등 다양한 언어를 지원 \nSTAF \n다양한 환경을 지원 \nFitNess \n웹기반 \nNTAF \nFitNess + STAF \nwatir \nRuby 기반 \nEAI 구축 유형 \n설명 \nPoint-to-Point \n애플리케이션의 1:1 연결 \nHub & Spoke \n허브를 통해 데이터를 전송하는 중앙 집중형 방식 \nMessage Bus (ESB 방식) \n애플리케이션 사이에 미들웨어를 두어 처리 \nHybrid \nHub & Spoke(그룹내) + Message Bus(그룹간) \n3. 테스트 \n1) 애플리케이션 테스트 : 애플리케이션에 잠재되어 있는 결함을 찾아내는 행위 \n(1) 확인과 검증 \n확인 : 요구사항 만족 확인 (사용자 중심) \n검증 : 명세서에 맞게 만들어졌는지 검증 (개발자 중심) \n(2) 기본 원리  \n파레토법칙 : 오류의 80%는 20%의 모듈에서 발견된다 => 결함 집중 \n(3) 테스트 오라클: 결과를 판단하기 위해 테스트케이스에 대한 예상결과 계산, 확인 \n참오라클 \n모든 테스트 케이스의 입력값에 대한 기대값 제공 \n샘플링 오라클 \n특정 케이스에 대한 기대값 제공 \n추정 오라클 \n특정 케이스에 대한 기댓값 + 나머지는 추정으로 처리 \n일관성 검사 오라클 \n애플리케이션 변경 시, 변경 전과 후의 결과값이 동일한지 비교', ""입·출력 함수 input( ) 함수- input( ) 함수는 Python의 표준 입력 함수로, 키보드로 입력받아 변수에 저장하는 함수이다.- 형식 변수 = input(출력문자)- ‘출력문자’는 생략이 가능하며, ‘변수’ 는 사용자가 임의로 지정할 수 있다.- 값을 입력하고 를 누르면, 입력 J \x08 한 값이 ‘변수’에 저장된다. 화면에 입력하세요. \ue355 \u200c a = input('입력하세요.' ) → \u200c 가 출력 되고 그 뒤에서 커서가 깜빡거리며 입력을 기다린다. 키보드로 값을 입력하면 변수 a에 저장된다. print( ) 함수- 형식1 print( 출력값1, 출력값2, …, sep = 분리문자, end = 종료문자)- ‘출력값’에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식이 올 수 있다.- ‘sep’는 여러 값을 출력할 때 값과 값 사이를 구분하기 위해 출력하는 문 자로, 생략할 경우 기본값은 공백 한 칸(‘ ’)이다. \x08- ‘end’는 맨 마지막에 표시할 문자로, 생략할 경우 기본값은 줄 나눔이다. \ue355 \u200c print(82, 24, sep = '- ', end = ',' ) → 82와 24 사이 에 분리문자 ‘- ’가 출력되고, 마지막에 종료문자 ‘,’가 출력된다. 82- 24, 결과 정보처리기사 필기 요약 2414""]"
