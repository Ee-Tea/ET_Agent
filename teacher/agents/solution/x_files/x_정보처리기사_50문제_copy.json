{
  "exam_title": "정보처리기사 모의고사 (Groq 순차 버전)",
  "total_questions": 30,
  "difficulty": "중급",
  "subjects": {
    "소프트웨어설계": {
      "requested_count": 10,
      "actual_count": 10,
      "questions": [
        {
          "question": "소프트웨어 설계에서 객체의 행위를 분석하는 다이어그램은?",
          "options": [
            "  1. 클래스 다이어그램",
            "  2. 유스케이스 다이어그램",
            "  3. 시퀀스 다이어그램",
            "  4. 상태 다이어그램"
          ],
          "answer": "2",
          "explanation": "유스케이스 다이어그램은 사용자의 요구를 분석하는 것으로 객체의 행위를 표현한다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "다음 중 소프트웨어 설계의 주요 항목이 아닌 것은?",
          "options": [
            "  1. 화면 설계",
            "  2. 애플리케이션 설계",
            "  3. 데이터베이스 설계",
            "  4. 네트워크 설계"
          ],
          "answer": "4",
          "explanation": "소프트웨어 설계의 주요 항목은 화면 설계, 애플리케이션 설계, 인터페이스 설계 등이 있다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 아키텍처의 유형 중 '파이프 필터 아키텍처'에 대한 설명으로 옳은 것은?",
          "options": [
            "  1. 데이터는 파이프를 통해 단방향으로 흐른다.",
            "  2. 데이터는 파이프를 통해 양방향으로 흐른다.",
            "  3. 필터는 데이터를 변환하고 처리한다.",
            "  4. 파이프는 데이터를 저장하는 역할을 한다."
          ],
          "answer": "1",
          "explanation": "파이프 필터 아키텍처에서 데이터는 파이프를 통해 단방향으로 흐른다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "디자인 패턴의 종류 중 생성 패턴에 해당하는 것은?",
          "options": [
            "  1. Adapter 패턴",
            "  2. Bridge 패턴",
            "  3. Builder 패턴",
            "  4. Proxy 패턴"
          ],
          "answer": "3",
          "explanation": "생성 패턴에는 Singleton, Factory, Builder 등이 있다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 설계에서 결합도에 대한 설명으로 옳은 것은?",
          "options": [
            "  1. 결합도가 높을수록 소프트웨어의 유지보수가 쉽다.",
            "  2. 결합도가 낮을수록 소프트웨어의 재사용성이 높다.",
            "  3. 결합도는 모듈 간의 의존성을 나타낸다.",
            "  4. 결합도는 모듈의 응집력을 나타낸다."
          ],
          "answer": "2",
          "explanation": "결합도가 낮을수록 소프트웨어의 재사용성이 높고 유지보수가 쉽다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "객체지향 설계에서 다이어그램을 사용하여 객체의 행위를 표현하는 것은?",
          "options": [
            "  1. 클래스 다이어그램",
            "  2. 유스케이스 다이어그램",
            "  3. 시퀀스 다이어그램",
            "  4. 상태 다이어그램"
          ],
          "answer": "3",
          "explanation": "시퀀스 다이어그램은 객체 간의 상호작용을 시간순으로 보여준다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 설계에서 모듈의 응집도에 대한 설명으로 옳은 것은?",
          "options": [
            "  1. 응집도가 높을수록 모듈의 재사용성이 낮다.",
            "  2. 응집도가 낮을수록 모듈의 재사용성이 높다.",
            "  3. 응집도는 모듈의 내부 응집력을 나타낸다.",
            "  4. 응집도는 모듈 간의 결합력을 나타낸다."
          ],
          "answer": "3",
          "explanation": "응집도는 모듈이 얼마나 하나의 완전한 기능을 수행하는지 나타낸다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "다음 중 소프트웨어 설계의 검증 방법이 아닌 것은?",
          "options": [
            "  1. 테스트",
            "  2. 리뷰",
            "  3. 워크스루",
            "  4. 컴파일"
          ],
          "answer": "4",
          "explanation": "컴파일은 소프트웨어 개발 과정의 일부이지만 설계 검증 방법은 아니다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 설계에서 인터페이스 설계의 중요성이 아닌 것은?",
          "options": [
            "  1. 시스템 간의 호환성",
            "  2. 사용자의 편의성",
            "  3. 소프트웨어의 유지보수",
            "  4. 하드웨어의 성능"
          ],
          "answer": "4",
          "explanation": "인터페이스 설계는 시스템 간의 호환성과 사용자의 편의성 등에 중요하다.",
          "subject": "소프트웨어설계"
        },
        {
          "question": "소프트웨어 아키텍처의 유형 중 '데이터 중심 아키텍처'에 대한 설명으로 옳은 것은?",
          "options": [
            "  1. 데이터는 중앙 집중식으로 관리된다.",
            "  2. 데이터는 분산되어 관리된다.",
            "  3. 데이터는 애플리케이션과 독립적이다.",
            "  4. 데이터는 시스템의 일부이다."
          ],
          "answer": "1",
          "explanation": "데이터 중심 아키텍처는 데이터를 중앙에서 관리하는 방식이다.",
          "subject": "소프트웨어설계"
        }
      ],
      "status": "SUCCESS"
    },
    "소프트웨어개발": {
      "requested_count": 10,
      "actual_count": 10,
      "questions": [
        {
          "question": "소프트웨어 패키징의 정의로 가장 적절한 것은?",
          "options": [
            "  1. 모듈별로 생성한 실행 파일을 묶어 배포용 설치파일을 만드는 것",
            "  2. 소프트웨어 개발 과정의 첫 단계",
            "  3. 사용자 요구사항을 분석하는 과정",
            "  4. 소프트웨어 테스트를 수행하는 과정"
          ],
          "answer": "1",
          "explanation": "패키징은 모듈별로 생성한 실행 파일을 묶어 배포용 설치파일을 만드는 것입니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?",
          "options": [
            "  1. Correctness",
            "  2. Portability",
            "  3. Efficiency",
            "  4. Usability"
          ],
          "answer": "2",
          "explanation": "Portability는 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미합니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "단위 테스트(Unit Test)의 주목적인 것은?",
          "options": [
            "  1. 통합 테스트",
            "  2. 시스템 테스트",
            "  3. 인수 테스트",
            "  4. 개별 모듈이 정확하게 구현되었는지 확인하는 것"
          ],
          "answer": "4",
          "explanation": "단위 테스트는 개별 모듈이 정확하게 구현되었는지 확인하는 것입니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "DRM(Digital Rights Management)의 구성 요소에 포함되지 않는 것은?",
          "options": [
            "  1. 클리어링 하우스",
            "  2. 콘텐츠 제공자",
            "  3. 분배자(유통)",
            "  4. 소비자"
          ],
          "answer": "4",
          "explanation": "DRM의 구성 요소는 클리어링 하우스, 콘텐츠 제공자, 분배자(유통)입니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "소프트웨어 생명주기 모형 중 폭포수 모형의 장점이 아닌 것은?",
          "options": [
            "  1. 모형의 적용 경험과 성공 사례가 많음",
            "  2. 단계별 정의가 분명하고, 전체 공조의 이해가 용이",
            "  3. 단계별 산출물이 정확하여 개발 공정의 기준점을 잘 제시",
            "  4. 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 쉬움"
          ],
          "answer": "4",
          "explanation": "폭포수 모형은 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 어렵습니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "소프트웨어 재공학의 이점으로 틀린 것은?",
          "options": [
            "  1. 위험 부담 감소",
            "  2. 개발 시간 단축",
            "  3. 개발 비용 절감",
            "  4. 시스템 명세의 오류 증가"
          ],
          "answer": "4",
          "explanation": "소프트웨어 재공학의 이점에는 시스템 명세의 오류 억제가 포함됩니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "소프트웨어 재사용 방법 중 합성 중심 방법에 해당하는 것은?",
          "options": [
            "  1. 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추어 소프트웨어를 완성시키는 방법",
            "  2. 추상화 형태로 쓰여진 명세를 구체화하여 프로그램을 만드는 방법",
            "  3. 소프트웨어 개발 과정을 테스트하는 방법",
            "  4. 소프트웨어 결과를 테스트하는 방법"
          ],
          "answer": "1",
          "explanation": "합성 중심 방법은 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추어 소프트웨어를 완성시키는 방법입니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "COCOMO 모형이 사용되는 목적은?",
          "options": [
            "  1. 소프트웨어 개발 비용 산정",
            "  2. 소프트웨어 개발 시간 산정",
            "  3. 소프트웨어 개발 자원 산정",
            "  4. 소프트웨어 개발 위험 산정"
          ],
          "answer": "1",
          "explanation": "COCOMO 모형은 소프트웨어 개발 비용을 산정하기 위해 사용됩니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "기능 점수(Function Point) 모형의 설명으로 맞는 것은?",
          "options": [
            "  1. 소프트웨어 개발 비용을 산정하는 방법",
            "  2. 소프트웨어 개발 시간을 산정하는 방법",
            "  3. 소프트웨어의 기능에 따라 점수를 부여하여 개발 규모를 산정하는 방법",
            "  4. 소프트웨어의 성능에 따라 점수를 부여하여 개발 규모를 산정하는 방법"
          ],
          "answer": "3",
          "explanation": "기능 점수(Function Point) 모형은 소프트웨어의 기능에 따라 점수를 부여하여 개발 규모를 산정하는 방법입니다.",
          "subject": "소프트웨어개발"
        },
        {
          "question": "내장형(Embedded Mode) 소프트웨어 개발 유형에 해당하는 것은?",
          "options": [
            "  1. 5만 라인 이하의 소프트웨어를 개발하는 유형",
            "  2. 30만 라인 이하의 소프트웨어를 개발하는 유형",
            "  3. 30만 라인 이상의 초대형 규모의 트랜잭션 처리 시스템이나 운영체제 등을 개발하는 유형",
            "  4. 범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행되는 유형"
          ],
          "answer": "3",
          "explanation": "내장형(Embedded Mode) 소프트웨어 개발 유형은 30만 라인 이상의 초대형 규모의 트랜잭션 처리 시스템이나 운영체제 등을 개발하는 유형입니다.",
          "subject": "소프트웨어개발"
        }
      ],
      "status": "SUCCESS"
    },
    "데이터베이스구축": {
      "requested_count": 10,
      "actual_count": 10,
      "questions": [
        {
          "question": "DDL에 속하는 명령어는?",
          "options": [
            "  1. SELECT",
            "  2. INSERT",
            "  3. CREATE",
            "  4. UPDATE"
          ],
          "answer": "3",
          "explanation": "DDL은 데이터 정의어로 CREATE, ALTER, DROP 등이 포함됩니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "DML에 속하는 명령어들은?",
          "options": [
            "  1. SELECT, INSERT, UPDATE, DELETE",
            "  2. CREATE, ALTER, DROP",
            "  3. COMMIT, ROLLBACK",
            "  4. GRANT, REVOKE"
          ],
          "answer": "1",
          "explanation": "DML은 데이터 조작어로 SELECT, INSERT, UPDATE, DELETE 등이 포함됩니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "SQL에서 데이터를 입력하는 명령어는?",
          "options": [
            "  1. INSERT INTO",
            "  2. UPDATE",
            "  3. DELETE FROM",
            "  4. SELECT"
          ],
          "answer": "1",
          "explanation": "INSERT INTO 명령어는 새로운 데이터를 테이블에 추가합니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "SELECT 문의 기본 구조로 옳은 것은?",
          "options": [
            "  1. SELECT * FROM 테이블명",
            "  2. INSERT INTO 테이블명 VALUES (값)",
            "  3. UPDATE 테이블명 SET 열=값",
            "  4. DELETE FROM 테이블명"
          ],
          "answer": "1",
          "explanation": "SELECT 문의 기본 구조는 SELECT 속성군 FROM 테이블명 [WHERE 조건]입니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "데이터베이스의 논리적 설계 단계에서 수행하는 작업은?",
          "options": [
            "  1. 데이터 모델링",
            "  2. 데이터베이스 구조 설계",
            "  3. 데이터 사전 작성",
            "  4. 데이터 변환"
          ],
          "answer": "1",
          "explanation": "논리적 설계 단계에서는 데이터 모델링을 수행합니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "관계형 데이터 모델에서 릴레이션의 차수(degree)는 무엇을 의미합니까?",
          "options": [
            "  1. 릴레이션의 행 수",
            "  2. 릴레이션의 열 수",
            "  3. 릴레이션의 속성 수",
            "  4. 릴레이션의 튜플 수"
          ],
          "answer": "2",
          "explanation": "릴레이션의 차수는 릴레이션에서 속성의 수를 의미합니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "트랜잭션의 실행이 실패하였음을 알리는 연산자는?",
          "options": [
            "  1. COMMIT",
            "  2. ROLLBACK",
            "  3. BACKUP",
            "  4. LOG"
          ],
          "answer": "2",
          "explanation": "ROLLBACK 연산자는 트랜잭션의 실행이 실패하였을 때 사용됩니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "다음 중 데이터베이스의 물리적 설계 단계에서 수행하는 작업은?",
          "options": [
            "  1. 데이터 모델링",
            "  2. 데이터베이스 구조 설계",
            "  3. 데이터 사전 작성",
            "  4. 스토리지 할당"
          ],
          "answer": "4",
          "explanation": "물리적 설계 단계에서는 스토리지 할당 등의 작업을 수행합니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "SQL에서 데이터를 삭제하는 명령어는?",
          "options": [
            "  1. DELETE FROM",
            "  2. UPDATE",
            "  3. INSERT INTO",
            "  4. SELECT"
          ],
          "answer": "1",
          "explanation": "DELETE FROM 명령어는 테이블의 데이터를 삭제합니다.",
          "subject": "데이터베이스구축"
        },
        {
          "question": "다음 중 데이터베이스의 보안과 관련된 내용은?",
          "options": [
            "  1. 접근 통제",
            "  2. 데이터 암호화",
            "  3. 데이터 백업",
            "  4. 데이터 모델링"
          ],
          "answer": "1",
          "explanation": "접근 통제는 데이터베이스의 보안과 관련됩니다.",
          "subject": "데이터베이스구축"
        }
      ],
      "status": "SUCCESS"
    },
    "프로그래밍언어활용": {
      "requested_count": 10,
      "actual_count": 0,
      "questions": [],
      "status": "PARTIAL"
    },
    "정보시스템구축관리": {
      "requested_count": 10,
      "actual_count": 0,
      "questions": [],
      "status": "PARTIAL"
    }
  },
  "all_questions": [
    {
      "question": "소프트웨어 설계에서 객체의 행위를 분석하는 다이어그램은?",
      "options": [
        "  1. 클래스 다이어그램",
        "  2. 유스케이스 다이어그램",
        "  3. 시퀀스 다이어그램",
        "  4. 상태 다이어그램"
      ],
      "answer": "2",
      "explanation": "유스케이스 다이어그램은 사용자의 요구를 분석하는 것으로 객체의 행위를 표현한다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "다음 중 소프트웨어 설계의 주요 항목이 아닌 것은?",
      "options": [
        "  1. 화면 설계",
        "  2. 애플리케이션 설계",
        "  3. 데이터베이스 설계",
        "  4. 네트워크 설계"
      ],
      "answer": "4",
      "explanation": "소프트웨어 설계의 주요 항목은 화면 설계, 애플리케이션 설계, 인터페이스 설계 등이 있다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 아키텍처의 유형 중 '파이프 필터 아키텍처'에 대한 설명으로 옳은 것은?",
      "options": [
        "  1. 데이터는 파이프를 통해 단방향으로 흐른다.",
        "  2. 데이터는 파이프를 통해 양방향으로 흐른다.",
        "  3. 필터는 데이터를 변환하고 처리한다.",
        "  4. 파이프는 데이터를 저장하는 역할을 한다."
      ],
      "answer": "1",
      "explanation": "파이프 필터 아키텍처에서 데이터는 파이프를 통해 단방향으로 흐른다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "디자인 패턴의 종류 중 생성 패턴에 해당하는 것은?",
      "options": [
        "  1. Adapter 패턴",
        "  2. Bridge 패턴",
        "  3. Builder 패턴",
        "  4. Proxy 패턴"
      ],
      "answer": "3",
      "explanation": "생성 패턴에는 Singleton, Factory, Builder 등이 있다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 설계에서 결합도에 대한 설명으로 옳은 것은?",
      "options": [
        "  1. 결합도가 높을수록 소프트웨어의 유지보수가 쉽다.",
        "  2. 결합도가 낮을수록 소프트웨어의 재사용성이 높다.",
        "  3. 결합도는 모듈 간의 의존성을 나타낸다.",
        "  4. 결합도는 모듈의 응집력을 나타낸다."
      ],
      "answer": "2",
      "explanation": "결합도가 낮을수록 소프트웨어의 재사용성이 높고 유지보수가 쉽다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "객체지향 설계에서 다이어그램을 사용하여 객체의 행위를 표현하는 것은?",
      "options": [
        "  1. 클래스 다이어그램",
        "  2. 유스케이스 다이어그램",
        "  3. 시퀀스 다이어그램",
        "  4. 상태 다이어그램"
      ],
      "answer": "3",
      "explanation": "시퀀스 다이어그램은 객체 간의 상호작용을 시간순으로 보여준다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 설계에서 모듈의 응집도에 대한 설명으로 옳은 것은?",
      "options": [
        "  1. 응집도가 높을수록 모듈의 재사용성이 낮다.",
        "  2. 응집도가 낮을수록 모듈의 재사용성이 높다.",
        "  3. 응집도는 모듈의 내부 응집력을 나타낸다.",
        "  4. 응집도는 모듈 간의 결합력을 나타낸다."
      ],
      "answer": "3",
      "explanation": "응집도는 모듈이 얼마나 하나의 완전한 기능을 수행하는지 나타낸다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "다음 중 소프트웨어 설계의 검증 방법이 아닌 것은?",
      "options": [
        "  1. 테스트",
        "  2. 리뷰",
        "  3. 워크스루",
        "  4. 컴파일"
      ],
      "answer": "4",
      "explanation": "컴파일은 소프트웨어 개발 과정의 일부이지만 설계 검증 방법은 아니다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 설계에서 인터페이스 설계의 중요성이 아닌 것은?",
      "options": [
        "  1. 시스템 간의 호환성",
        "  2. 사용자의 편의성",
        "  3. 소프트웨어의 유지보수",
        "  4. 하드웨어의 성능"
      ],
      "answer": "4",
      "explanation": "인터페이스 설계는 시스템 간의 호환성과 사용자의 편의성 등에 중요하다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 아키텍처의 유형 중 '데이터 중심 아키텍처'에 대한 설명으로 옳은 것은?",
      "options": [
        "  1. 데이터는 중앙 집중식으로 관리된다.",
        "  2. 데이터는 분산되어 관리된다.",
        "  3. 데이터는 애플리케이션과 독립적이다.",
        "  4. 데이터는 시스템의 일부이다."
      ],
      "answer": "1",
      "explanation": "데이터 중심 아키텍처는 데이터를 중앙에서 관리하는 방식이다.",
      "subject": "소프트웨어설계"
    },
    {
      "question": "소프트웨어 패키징의 정의로 가장 적절한 것은?",
      "options": [
        "  1. 모듈별로 생성한 실행 파일을 묶어 배포용 설치파일을 만드는 것",
        "  2. 소프트웨어 개발 과정의 첫 단계",
        "  3. 사용자 요구사항을 분석하는 과정",
        "  4. 소프트웨어 테스트를 수행하는 과정"
      ],
      "answer": "1",
      "explanation": "패키징은 모듈별로 생성한 실행 파일을 묶어 배포용 설치파일을 만드는 것입니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?",
      "options": [
        "  1. Correctness",
        "  2. Portability",
        "  3. Efficiency",
        "  4. Usability"
      ],
      "answer": "2",
      "explanation": "Portability는 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미합니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "단위 테스트(Unit Test)의 주목적인 것은?",
      "options": [
        "  1. 통합 테스트",
        "  2. 시스템 테스트",
        "  3. 인수 테스트",
        "  4. 개별 모듈이 정확하게 구현되었는지 확인하는 것"
      ],
      "answer": "4",
      "explanation": "단위 테스트는 개별 모듈이 정확하게 구현되었는지 확인하는 것입니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "DRM(Digital Rights Management)의 구성 요소에 포함되지 않는 것은?",
      "options": [
        "  1. 클리어링 하우스",
        "  2. 콘텐츠 제공자",
        "  3. 분배자(유통)",
        "  4. 소비자"
      ],
      "answer": "4",
      "explanation": "DRM의 구성 요소는 클리어링 하우스, 콘텐츠 제공자, 분배자(유통)입니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "소프트웨어 생명주기 모형 중 폭포수 모형의 장점이 아닌 것은?",
      "options": [
        "  1. 모형의 적용 경험과 성공 사례가 많음",
        "  2. 단계별 정의가 분명하고, 전체 공조의 이해가 용이",
        "  3. 단계별 산출물이 정확하여 개발 공정의 기준점을 잘 제시",
        "  4. 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 쉬움"
      ],
      "answer": "4",
      "explanation": "폭포수 모형은 개발 과정 중에 발생하는 새로운 요구나 경험을 설계에 반영하기 어렵습니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "소프트웨어 재공학의 이점으로 틀린 것은?",
      "options": [
        "  1. 위험 부담 감소",
        "  2. 개발 시간 단축",
        "  3. 개발 비용 절감",
        "  4. 시스템 명세의 오류 증가"
      ],
      "answer": "4",
      "explanation": "소프트웨어 재공학의 이점에는 시스템 명세의 오류 억제가 포함됩니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "소프트웨어 재사용 방법 중 합성 중심 방법에 해당하는 것은?",
      "options": [
        "  1. 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추어 소프트웨어를 완성시키는 방법",
        "  2. 추상화 형태로 쓰여진 명세를 구체화하여 프로그램을 만드는 방법",
        "  3. 소프트웨어 개발 과정을 테스트하는 방법",
        "  4. 소프트웨어 결과를 테스트하는 방법"
      ],
      "answer": "1",
      "explanation": "합성 중심 방법은 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추어 소프트웨어를 완성시키는 방법입니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "COCOMO 모형이 사용되는 목적은?",
      "options": [
        "  1. 소프트웨어 개발 비용 산정",
        "  2. 소프트웨어 개발 시간 산정",
        "  3. 소프트웨어 개발 자원 산정",
        "  4. 소프트웨어 개발 위험 산정"
      ],
      "answer": "1",
      "explanation": "COCOMO 모형은 소프트웨어 개발 비용을 산정하기 위해 사용됩니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "기능 점수(Function Point) 모형의 설명으로 맞는 것은?",
      "options": [
        "  1. 소프트웨어 개발 비용을 산정하는 방법",
        "  2. 소프트웨어 개발 시간을 산정하는 방법",
        "  3. 소프트웨어의 기능에 따라 점수를 부여하여 개발 규모를 산정하는 방법",
        "  4. 소프트웨어의 성능에 따라 점수를 부여하여 개발 규모를 산정하는 방법"
      ],
      "answer": "3",
      "explanation": "기능 점수(Function Point) 모형은 소프트웨어의 기능에 따라 점수를 부여하여 개발 규모를 산정하는 방법입니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "내장형(Embedded Mode) 소프트웨어 개발 유형에 해당하는 것은?",
      "options": [
        "  1. 5만 라인 이하의 소프트웨어를 개발하는 유형",
        "  2. 30만 라인 이하의 소프트웨어를 개발하는 유형",
        "  3. 30만 라인 이상의 초대형 규모의 트랜잭션 처리 시스템이나 운영체제 등을 개발하는 유형",
        "  4. 범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행되는 유형"
      ],
      "answer": "3",
      "explanation": "내장형(Embedded Mode) 소프트웨어 개발 유형은 30만 라인 이상의 초대형 규모의 트랜잭션 처리 시스템이나 운영체제 등을 개발하는 유형입니다.",
      "subject": "소프트웨어개발"
    },
    {
      "question": "DDL에 속하는 명령어는?",
      "options": [
        "  1. SELECT",
        "  2. INSERT",
        "  3. CREATE",
        "  4. UPDATE"
      ],
      "answer": "3",
      "explanation": "DDL은 데이터 정의어로 CREATE, ALTER, DROP 등이 포함됩니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "DML에 속하는 명령어들은?",
      "options": [
        "  1. SELECT, INSERT, UPDATE, DELETE",
        "  2. CREATE, ALTER, DROP",
        "  3. COMMIT, ROLLBACK",
        "  4. GRANT, REVOKE"
      ],
      "answer": "1",
      "explanation": "DML은 데이터 조작어로 SELECT, INSERT, UPDATE, DELETE 등이 포함됩니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "SQL에서 데이터를 입력하는 명령어는?",
      "options": [
        "  1. INSERT INTO",
        "  2. UPDATE",
        "  3. DELETE FROM",
        "  4. SELECT"
      ],
      "answer": "1",
      "explanation": "INSERT INTO 명령어는 새로운 데이터를 테이블에 추가합니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "SELECT 문의 기본 구조로 옳은 것은?",
      "options": [
        "  1. SELECT * FROM 테이블명",
        "  2. INSERT INTO 테이블명 VALUES (값)",
        "  3. UPDATE 테이블명 SET 열=값",
        "  4. DELETE FROM 테이블명"
      ],
      "answer": "1",
      "explanation": "SELECT 문의 기본 구조는 SELECT 속성군 FROM 테이블명 [WHERE 조건]입니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "데이터베이스의 논리적 설계 단계에서 수행하는 작업은?",
      "options": [
        "  1. 데이터 모델링",
        "  2. 데이터베이스 구조 설계",
        "  3. 데이터 사전 작성",
        "  4. 데이터 변환"
      ],
      "answer": "1",
      "explanation": "논리적 설계 단계에서는 데이터 모델링을 수행합니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "관계형 데이터 모델에서 릴레이션의 차수(degree)는 무엇을 의미합니까?",
      "options": [
        "  1. 릴레이션의 행 수",
        "  2. 릴레이션의 열 수",
        "  3. 릴레이션의 속성 수",
        "  4. 릴레이션의 튜플 수"
      ],
      "answer": "2",
      "explanation": "릴레이션의 차수는 릴레이션에서 속성의 수를 의미합니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "트랜잭션의 실행이 실패하였음을 알리는 연산자는?",
      "options": [
        "  1. COMMIT",
        "  2. ROLLBACK",
        "  3. BACKUP",
        "  4. LOG"
      ],
      "answer": "2",
      "explanation": "ROLLBACK 연산자는 트랜잭션의 실행이 실패하였을 때 사용됩니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "다음 중 데이터베이스의 물리적 설계 단계에서 수행하는 작업은?",
      "options": [
        "  1. 데이터 모델링",
        "  2. 데이터베이스 구조 설계",
        "  3. 데이터 사전 작성",
        "  4. 스토리지 할당"
      ],
      "answer": "4",
      "explanation": "물리적 설계 단계에서는 스토리지 할당 등의 작업을 수행합니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "SQL에서 데이터를 삭제하는 명령어는?",
      "options": [
        "  1. DELETE FROM",
        "  2. UPDATE",
        "  3. INSERT INTO",
        "  4. SELECT"
      ],
      "answer": "1",
      "explanation": "DELETE FROM 명령어는 테이블의 데이터를 삭제합니다.",
      "subject": "데이터베이스구축"
    },
    {
      "question": "다음 중 데이터베이스의 보안과 관련된 내용은?",
      "options": [
        "  1. 접근 통제",
        "  2. 데이터 암호화",
        "  3. 데이터 백업",
        "  4. 데이터 모델링"
      ],
      "answer": "1",
      "explanation": "접근 통제는 데이터베이스의 보안과 관련됩니다.",
      "subject": "데이터베이스구축"
    }
  ],
  "generation_summary": {
    "target_total": 50,
    "actual_total": 30,
    "success_rate": "60.0%",
    "successful_subjects": 5,
    "failed_subjects": 0,
    "completion_status": "PARTIAL",
    "generation_time": "1112.1초"
  },
  "failed_subjects": [],
  "model_info": "Groq llama-3.3-70b-versatile"
}